---
name: Privasi pada Bitcoin
goal: Memahami dan menguasai prinsip-prinsip perlindungan privasi saat menggunakan Bitcoin
objectives: 

  - Mendefinisikan konsep teoretis yang diperlukan untuk memahami masalah privasi
  - Mengidentifikasi dan memitigasi risiko yang terkait dengan hilangnya kerahasiaan pengguna Bitcoin
  - Menggunakan metode dan alat untuk melindungi privasi Anda di Bitcoin
  - Memahami metode analisis rantai dan mengembangkan strategi pertahanan

---
# Lindungi privasi Anda di Bitcoin

Di dunia di mana kerahasiaan transaksi keuangan secara bertahap menjadi sebuah kemewahan, memahami dan menguasai prinsip-prinsip perlindungan privasi saat menggunakan Bitcoin sangatlah penting. Kursus pelatihan ini memberikan Anda semua kunci, baik secara teoritis maupun praktis, untuk mencapai hal ini secara mandiri.

Saat ini, di Bitcoin, banyak perusahaan yang mengkhususkan diri dalam analisis blockchain. Bisnis inti mereka justru adalah mengganggu ruang pribadi Anda, untuk mengorbankan kerahasiaan transaksi Anda. Pada kenyataannya, tidak ada yang namanya "hak privasi" dalam Bitcoin. Jadi, terserah kepada Anda, pengguna, untuk menegaskan hak-hak alami Anda dan melindungi kerahasiaan transaksi Anda, karena tidak ada orang lain yang akan melakukannya untuk Anda.

Kursus ini dirancang secara komprehensif dan umum. Setiap konsep teknis dibahas secara rinci dan didukung oleh diagram penjelasan. Tujuannya adalah untuk membuat pengetahuan dapat diakses oleh semua orang. Oleh karena itu, BTC204 terjangkau untuk pemula dan pengguna tingkat menengah. Kursus ini juga menawarkan nilai tambah bagi para pengguna bitcoin yang lebih berpengalaman, karena kami mempelajari lebih dalam konsep-konsep teknis tertentu yang sering disalahpahami.

Bergabunglah dengan kami untuk mengubah penggunaan Bitcoin Anda dan menjadi pengguna yang terinformasi, yang mampu memahami isu-isu seputar kerahasiaan dan melindungi privasi Anda.

+++
# Pendahuluan

<partId>e17474a8-8899-4bdb-a7f8-bc52ddb01440</partId>

## Ikhtisar Kursus

<chapterId>08ba1933-f393-4fb5-8279-777d874caedb</chapterId>

Selamat datang di kursus BTC204!

Di dunia di mana kerahasiaan transaksi keuangan secara bertahap menjadi sebuah kemewahan, memahami dan menguasai prinsip-prinsip perlindungan privasi saat menggunakan Bitcoin sangatlah penting. Kursus pelatihan ini memberikan Anda semua kunci, baik secara teoritis maupun praktis, untuk mencapai hal ini secara mandiri.

Saat ini, di Bitcoin, banyak perusahaan yang mengkhususkan diri dalam analisis blockchain. Bisnis inti mereka justru adalah mengganggu ruang pribadi Anda, untuk mengorbankan kerahasiaan transaksi Anda. Pada kenyataannya, tidak ada yang namanya "hak privasi" dalam Bitcoin. Jadi, terserah kepada Anda, pengguna, untuk menegaskan hak-hak alami Anda dan melindungi kerahasiaan transaksi Anda, karena tidak ada orang lain yang akan melakukannya untuk Anda.

Bitcoin bukan hanya tentang "Angka Naik" dan menjaga nilai tabungan. Dengan karakteristik dan sejarahnya yang unik, Bitcoin merupakan alat ekonomi tandingan yang pertama dan terutama. Berkat penemuan yang luar biasa ini, Anda dapat dengan bebas membuang uang Anda, membelanjakannya, dan mengakumulasikannya, tanpa ada yang bisa menghentikan Anda.

Bitcoin menawarkan sebuah pelarian yang damai dari kuk negara, memungkinkan Anda untuk menikmati hak-hak alamiah Anda sepenuhnya, yang tidak dapat diganggu gugat oleh hukum yang ada. Berkat penemuan Satoshi Nakamoto, Anda memiliki kekuatan untuk menegakkan penghormatan terhadap properti pribadi Anda dan mendapatkan kembali kebebasan untuk membuat kontrak.

Akan tetapi, Bitcoin tidak anonim secara default, yang dapat menjadi risiko bagi individu yang terlibat dalam ekonomi tandingan, terutama di wilayah-wilayah yang berada di bawah pemerintahan despotik. Namun, ini bukan satu-satunya bahaya. Karena bitcoin adalah aset yang berharga dan tidak dapat dipindahtangankan, maka ia dapat menjadi target bagi para pencuri. Jadi, melindungi privasi Anda juga menjadi masalah keamanan: hal ini dapat membantu Anda mencegah peretasan dan serangan fisik.

Seperti yang akan kita lihat, meskipun protokol menawarkan perlindungan kerahasiaan tertentu dengan sendirinya, sangat penting untuk menggunakan alat bantu tambahan untuk mengoptimalkan dan mempertahankan kerahasiaan ini.

Kursus pelatihan ini dirancang untuk memberikan gambaran umum yang komprehensif dan menyeluruh mengenai isu-isu yang terlibat dalam kerahasiaan Bitcoin. Setiap konsep teknis akan dibahas secara rinci, didukung oleh diagram penjelasan. Tujuannya adalah agar pengetahuan ini dapat diakses oleh semua orang, bahkan oleh pemula dan pengguna tingkat menengah. Untuk para Bitcoiners yang lebih berpengalaman, kami juga akan membahas konsep-konsep yang sangat teknis dan terkadang tidak banyak diketahui di sepanjang kursus, untuk memperdalam pemahaman tentang setiap subjek.

Tujuan dari kursus pelatihan ini bukan untuk membuat Anda benar-benar anonim dalam penggunaan Bitcoin, melainkan untuk memberi Anda alat penting untuk mengetahui cara melindungi kerahasiaan Anda sesuai dengan tujuan pribadi Anda. Anda akan memiliki kebebasan untuk memilih dari konsep dan alat yang disajikan untuk mengembangkan strategi Anda sendiri, yang disesuaikan dengan tujuan dan kebutuhan Anda.

**Bagian 1: Definisi dan konsep utama**

Sebagai permulaan, kita akan meninjau prinsip-prinsip dasar yang mengatur pengoperasian Bitcoin, sehingga kita dapat dengan tenang membahas pengertian-pengertian yang berkaitan dengan kerahasiaan. Sangat penting untuk menguasai beberapa konsep dasar, seperti UTXO, menerima alamat dan skrip, sebelum Anda dapat sepenuhnya memahami konsep-konsep yang akan kita bahas di bagian berikut. Kami juga akan memperkenalkan model kerahasiaan umum Bitcoin, seperti yang dibayangkan oleh Satoshi Nakamoto, yang akan memungkinkan kita untuk memahami taruhan dan risiko yang terkait.

![BTC204](assets/fr/001.webp)

**Bagian 2: Memahami dan melindungi dari analisis rantai**

Pada bagian kedua, kita akan melihat teknik yang digunakan oleh perusahaan analisis blockchain untuk melacak aktivitas Anda di Bitcoin. Memahami metode-metode ini sangat penting untuk memperkuat perlindungan privasi Anda. Tujuan dari bagian ini adalah untuk memeriksa strategi penyerang untuk lebih memahami risiko dan mempersiapkan diri untuk teknik-teknik yang akan kita pelajari di bagian selanjutnya. Kita akan menganalisa pola-pola transaksi, heuristik internal dan eksternal, dan kemungkinan interpretasi dari pola-pola ini. Selain teori, kita akan mempelajari cara menggunakan block explorer untuk analisis rantai, melalui contoh-contoh praktis dan latihan.

![BTC204](assets/fr/002.webp)

**Bagian 3: Menguasai praktik terbaik untuk melindungi privasi Anda**

Pada bagian ketiga dari kursus pelatihan ini, kita akan membahas hal-hal yang lebih detail: latihan! Tujuannya adalah untuk menguasai semua praktik terbaik yang penting yang seharusnya menjadi refleks alami bagi setiap pengguna Bitcoin. Kita akan membahas penggunaan alamat kosong, penandaan, konsolidasi, penggunaan node lengkap, serta metode KYC dan akuisisi. Tujuannya adalah untuk memberikan Anda gambaran umum yang komprehensif mengenai jebakan-jebakan yang perlu dihindari untuk membangun fondasi yang kuat dalam upaya kita melindungi privasi. Untuk beberapa praktik ini, Anda akan dipandu ke tutorial khusus tentang cara menerapkannya.

![BTC204](assets/fr/003.webp)

**Bagian 4: Memahami transaksi coinjoin**

Bagaimana kita bisa membicarakan privasi di Bitcoin tanpa menyebutkan koin bersama? Di bagian 4, Anda akan mengetahui semua yang perlu Anda ketahui tentang metode pencampuran ini. Anda akan mempelajari apa itu coinjoin, sejarah dan tujuannya, serta berbagai jenis coinjoin yang ada. Terakhir, untuk pengguna yang lebih berpengalaman, kita akan melihat apa itu anonset dan entropi, dan bagaimana cara menghitungnya.

![BTC204](assets/fr/004.webp)

**Bagian 5: Memahami tantangan teknik kerahasiaan tingkat lanjut lainnya**

Pada bagian kelima, kita akan melihat semua teknik lain yang tersedia untuk melindungi privasi Anda di Bitcoin, selain coinjoin. Selama bertahun-tahun, para pengembang telah menunjukkan kreativitas yang luar biasa dalam mendesain alat yang didedikasikan untuk privasi. Kita akan melihat semua metode ini, seperti payjoin, transaksi kolaboratif, Coin Swap dan Atomic Swap, dengan merinci cara kerjanya, tujuan dan kelemahannya.

Kita juga akan melihat privasi pada tingkat jaringan node dan penyebaran transaksi. Kita juga akan mendiskusikan berbagai protokol yang telah diusulkan selama bertahun-tahun untuk meningkatkan privasi pengguna Bitcoin, termasuk protokol alamat statis.

![BTC204](assets/fr/005.webp)
Siap menjelajahi seluk-beluk privasi di Bitcoin? Ayo mulai!

# Definisi dan konsep utama

<partId>b9bbbde3-34c0-4851-83e8-e2ffb029cf31</partId>

## Model UTXO Bitcoin

<chapterId>8d6b50c5-bf74-44f4-922b-25204991cb75</chapterId>


Bitcoin adalah mata uang, tetapi apakah Anda benar-benar tahu bagaimana BTC direpresentasikan dalam protokol?

### UTXO pada Bitcoin: apa itu?

Protokol Bitcoin didasarkan pada model UTXO, yang merupakan singkatan dari "Unspent Transaction Output".

Model ini sangat berbeda dengan sistem perbankan tradisional, yang mengandalkan mekanisme rekening dan saldo untuk melacak arus keuangan. Memang, dalam sistem perbankan, saldo individu disimpan dalam rekening yang dilampirkan pada sebuah identitas. Misalnya, ketika Anda membeli baguette dari tukang roti, bank Anda hanya mendebet jumlah pembelian dari rekening Anda, mengurangi saldo Anda, sementara rekening tukang roti dikreditkan dengan jumlah yang sama, meningkatkan saldonya. Dalam sistem ini, tidak ada hubungan antara uang yang masuk ke rekening Anda dan uang yang keluar dari rekening Anda, selain catatan transaksi.

![BTC204](assets/fr/006.webp)

Bitcoin bekerja dengan cara yang berbeda. Konsep akun tidak ada, dan unit moneter tidak dikelola melalui saldo, tetapi melalui UTXO. UTXO mewakili jumlah bitcoin tertentu yang belum dibelanjakan, sehingga membentuk "sepotong bitcoin", yang bisa berukuran besar atau kecil. Sebagai contoh, satu UTXO dapat bernilai `500 BTC` atau hanya `700 SATS`.

**> Satoshi, sering disingkat menjadi sat, adalah unit terkecil Bitcoin, sebanding dengan centime dalam mata uang fiat.

```plaintext
1 BTC = 100 000 000 SATS
```

Secara teoritis, satu UTXO dapat mewakili nilai berapa pun dalam bitcoin, mulai dari nilai terendah hingga nilai maksimum teoritis sekitar 21 juta BTC. Namun, secara logika tidak mungkin untuk memiliki semua 21 juta bitcoin, dan ada ambang batas ekonomi yang lebih rendah yang disebut "debu", di bawahnya UTXO dianggap tidak menguntungkan secara ekonomi untuk dibelanjakan.

**> UTXO terbesar yang pernah dibuat di Bitcoin memiliki nilai `500.000 BTC`. Ini dibuat oleh platform MtGox selama operasi konsolidasi pada bulan November 2011: [29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf](https://mempool.space/fr/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)

### UTXO dan ketentuan pembelanjaan

UTXO adalah alat tukar dalam Bitcoin. Setiap transaksi menghasilkan konsumsi UTXO sebagai input dan pembuatan UTXO baru sebagai output. Ketika transaksi selesai, UTXO yang digunakan sebagai input dianggap "dihabiskan", dan UTXO baru dibuat dan dialokasikan ke penerima yang ditunjukkan dalam output transaksi. Dengan demikian, UTXO hanya mewakili output transaksi yang tidak terpakai, dan oleh karena itu merupakan jumlah bitcoin milik pengguna pada waktu tertentu.

![BTC204](assets/fr/007.webp)

Semua UTXO diamankan dengan skrip yang menentukan kondisi di mana UTXO dapat digunakan. Untuk menggunakan UTXO, pengguna harus menunjukkan kepada jaringan bahwa dia memenuhi persyaratan yang ditentukan oleh skrip yang mengamankan UTXO tersebut. Biasanya, UTXO dilindungi oleh kunci publik (atau alamat penerima yang mewakili kunci publik). Untuk membelanjakan UTXO yang terkait dengan kunci publik ini, pengguna harus membuktikan bahwa ia memegang kunci privat yang sesuai, dengan memberikan tanda tangan digital yang dibuat dengan kunci ini. Inilah mengapa kami mengatakan bahwa dompet Bitcoin Anda tidak benar-benar berisi bitcoin, tetapi menyimpan kunci pribadi Anda, yang pada gilirannya memberi Anda akses ke UTXO Anda dan, lebih jauh lagi, ke bitcoin yang diwakilinya.

![BTC204](assets/fr/008.webp)

Karena tidak ada konsep rekening dalam Bitcoin, saldo dompet hanyalah jumlah nilai dari semua UTXO yang dapat dibelanjakan. Sebagai contoh, jika dompet Bitcoin Anda dapat membelanjakan 4 UTXO berikut ini:

```plaintext
- 2 BTC
- 8 BTC
- 5 BTC
- 2 BTC
```

Total saldo portofolio Anda adalah `17 BTC`.

![BTC204](assets/fr/009.webp)

## Struktur transaksi Bitcoin

<chapterId>29d3aaab-de2e-4746-ab40-c9748898850c</chapterId>


### Input dan output transaksi

Transaksi Bitcoin adalah sebuah operasi yang tercatat di blockchain yang mentransfer kepemilikan bitcoin dari satu orang ke orang lain. Lebih tepatnya, karena kita menggunakan model UTXO dan tidak ada akun, transaksi memenuhi syarat pengeluaran yang mengamankan satu atau lebih UTXO, mengkonsumsinya, dan secara ekuivalen menciptakan UTXO baru dengan syarat pengeluaran baru. Singkatnya, sebuah transaksi memindahkan bitcoin dari skrip yang terpenuhi ke skrip baru yang dirancang untuk mengamankannya.

![BTC204](assets/fr/010.webp)

Oleh karena itu, setiap transaksi Bitcoin terdiri dari satu atau lebih input dan satu atau lebih output. Input adalah UTXO yang dikonsumsi oleh transaksi untuk menghasilkan output. Keluaran adalah UTXO baru yang dapat digunakan sebagai input untuk transaksi selanjutnya.

![BTC204](assets/fr/011.webp)

**> Secara teoritis, sebuah transaksi bitcoin dapat memiliki jumlah input dan output yang tidak terbatas. Satu-satunya batasan adalah ukuran blok maksimum.

Setiap input dalam transaksi Bitcoin mengacu pada UTXO yang belum dibelanjakan sebelumnya. Untuk menggunakan UTXO sebagai input, pemegangnya harus menunjukkan bahwa ia adalah pemilik yang sah dengan memvalidasi skrip yang terkait, yaitu dengan memenuhi syarat pembelanjaan yang diberlakukan. Secara umum, ini berarti memberikan tanda tangan digital yang dihasilkan dengan kunci pribadi yang sesuai dengan kunci publik yang pada awalnya mengamankan UTXO ini. Oleh karena itu, skrip ini terdiri dari verifikasi bahwa tanda tangan tersebut sesuai dengan kunci publik yang digunakan ketika dana diterima.

![BTC204](assets/fr/012.webp)

Setiap output, pada gilirannya, menentukan jumlah bitcoin yang akan ditransfer, serta penerima. Yang terakhir ini ditentukan oleh skrip baru, yang biasanya memblokir UTXO yang baru dibuat dengan alamat penerima atau kunci publik baru.

Agar transaksi dianggap sah menurut aturan konsensus, total output harus kurang dari atau sama dengan total input. Dengan kata lain, jumlah UTXO baru yang dihasilkan oleh transaksi tidak boleh melebihi jumlah UTXO yang dikonsumsi sebagai input. Prinsip ini logis: jika Anda hanya memiliki `500.000 SATS`, Anda tidak dapat melakukan pembelian `700.000 SATS`.

### Pertukaran dan penggabungan dalam transaksi Bitcoin

Dengan demikian, tindakan transaksi Bitcoin pada UTXO dapat dibandingkan dengan membentuk ulang koin emas. Memang, UTXO tidak dapat dibagi, tetapi hanya dapat dilebur. Ini berarti bahwa seorang pengguna tidak dapat dengan mudah membagi UTXO yang mewakili jumlah tertentu dalam bitcoin menjadi beberapa UTXO yang lebih kecil. Ia harus menghabiskannya seluruhnya dalam sebuah transaksi untuk membuat satu atau lebih UTXO baru dengan nilai sembarang yang hasilnya harus kurang dari atau sama dengan nilai awal.

Mekanisme ini mirip dengan koin emas. Katakanlah Anda memiliki koin 2 ons dan ingin melakukan pembayaran sebesar 1 ons, dengan asumsi penjual tidak dapat memberikan kembalian. Anda harus melebur koin Anda dan melemparkan 2 koin baru dengan berat masing-masing 1 ons.

Bitcoin bekerja dengan cara yang sama. Bayangkan Alice memiliki UTXO sebesar `10.000 SATS` dan ingin membeli baguette seharga `4.000 SATS`. Alice akan melakukan transaksi dengan 1 UTXO sebesar `10.000 SATS` sebagai input, yang akan ia konsumsi secara penuh, dan 2 UTXO sebesar `4.000 SATS` dan `6.000 SATS` sebagai output. UTXO sebesar `4.000 SATS` akan dikirim ke tukang roti sebagai pembayaran untuk baguette, sedangkan UTXO sebesar `6.000 SATS` akan kembali ke Alice dalam bentuk uang kembalian. UTXO ini, yang kembali ke penerbit asli transaksi, dikenal sebagai "pertukaran" dalam jargon Bitcoin.

![BTC204](assets/fr/013.webp)

Sekarang mari kita bayangkan bahwa Alice tidak memiliki satu UTXO dengan `10.000 SATS`, melainkan dua UTXO dengan `3.000 SATS`. Dalam situasi ini, tidak satu pun dari UTXO tersebut yang cukup untuk mengatur `4.000 SATS` tongkat. Oleh karena itu, Alice harus secara bersamaan menggunakan 2 UTXO dengan `3.000 SATS` sebagai input untuk transaksinya. Dengan cara ini, jumlah total input akan mencapai `6.000 SATS`, yang memungkinkannya untuk memenuhi pembayaran `4.000 SATS` kepada tukang roti. Metode ini, di mana beberapa UTXO dikelompokkan bersama sebagai input untuk sebuah transaksi, sering disebut sebagai "penggabungan".

![BTC204](assets/fr/014.webp)

### Biaya transaksi

Secara intuitif, orang mungkin berpikir bahwa biaya transaksi juga mewakili hasil dari sebuah transaksi. Namun pada kenyataannya, tidak demikian. Biaya transaksi mewakili selisih antara total input dan total output. Artinya, setelah menggunakan sebagian dari nilai input untuk menghasilkan output yang diinginkan dalam sebuah transaksi, ada sejumlah input yang tidak terpakai. Jumlah sisa ini merupakan biaya transaksi.

```plaintext
Frais = total inputs - total outputs
```

Mari kita ambil contoh Alice, yang memiliki UTXO sebesar `10.000 SATS` dan ingin membeli sebuah baguette dengan harga `4.000 SATS`. Alice membuat transaksi dengan UTXO-nya sebesar `10.000 SATS` sebagai input. Dia kemudian menghasilkan output sebesar `4.000 SATS` untuk tukang roti untuk membayar roti baguette tersebut. Untuk mendorong para penambang mengintegrasikan transaksinya ke dalam sebuah blok, Alice mengalokasikan biaya sebesar `200 SATS`. Dia kemudian membuat output kedua, yaitu pertukaran, yang akan dikembalikan kepadanya, sebesar `5.800 SATS`.

![BTC204](assets/fr/015.webp)

Dengan menerapkan rumus biaya, kami melihat bahwa memang ada `200 SATS` yang tersisa untuk anak di bawah umur:

```plaintext
Frais = total inputs - total outputs
Frais = 10 000 - (4 000 + 5 800)
Frais = 10 000 - 9 800
Frais = 200
```

Ketika seorang penambang berhasil memvalidasi sebuah blok, ia memiliki wewenang untuk mengumpulkan biaya ini untuk semua transaksi yang termasuk dalam bloknya, melalui apa yang disebut dengan transaksi "coinbase".

### Membuat UTXO di Bitcoin

Jika Anda telah mengikuti paragraf sebelumnya dengan cermat, Anda sekarang akan mengetahui bahwa UTXO hanya dapat dibuat dengan mengonsumsi UTXO lain yang sudah ada. Dengan cara ini, koin Bitcoin membentuk sebuah rantai yang berkesinambungan. Namun, Anda mungkin bertanya-tanya bagaimana UTXO pertama dalam rantai ini muncul. Hal ini menimbulkan masalah yang mirip dengan ayam dan telur: dari mana asal UTXO yang pertama kali muncul?

Jawabannya ada di **transaction coinbase**.

Coinbase adalah jenis transaksi Bitcoin yang spesifik, yang unik untuk setiap blok dan selalu menjadi yang pertama. Hal ini memungkinkan penambang yang telah menemukan bukti kerja yang valid untuk menerima hadiah bloknya. Hadiah ini terdiri dari dua elemen: **block grant** dan **biaya transaksi**, yang telah dibahas di bagian sebelumnya.

Transaksi coinbase unik karena merupakan satu-satunya transaksi yang mampu menciptakan bitcoin secara ex nihilo, tanpa perlu mengonsumsi input untuk menghasilkan output. Bitcoin yang baru dibuat ini adalah apa yang bisa kita sebut sebagai "UTXO asli".

![BTC204](assets/fr/016.webp)

Bitcoin yang disubsidi blok adalah BTC baru yang dibuat dari awal, sesuai dengan jadwal penerbitan yang telah ditetapkan sebelumnya dalam aturan konsensus. Subsidi blok dibagi dua setiap 210.000 blok, yaitu kira-kira setiap empat tahun, dalam sebuah proses yang dikenal dengan istilah "halving". Awalnya, 50 bitcoin dibuat dengan setiap subsidi, tetapi jumlah ini secara bertahap menurun; saat ini, 3,125 bitcoin per blok.

Sedangkan untuk biaya transaksi, meskipun biaya ini juga mewakili BTC yang baru dibuat, biaya ini tidak boleh melebihi selisih antara total input dan output semua transaksi dalam satu blok. Kita telah melihat sebelumnya bahwa biaya ini mewakili porsi input yang tidak digunakan dalam output transaksi. Bagian ini secara teknis "hilang" selama transaksi, dan penambang memiliki hak untuk membuat ulang nilai ini dalam bentuk satu atau lebih UTXO baru. Ini adalah transfer nilai antara penerbit transaksi dan penambang yang menambahkannya ke blockchain.

**> Bitcoin yang dihasilkan oleh transaksi coinbase tunduk pada periode jatuh tempo 100 blok, di mana mereka tidak dapat dibelanjakan oleh penambang. Aturan ini dirancang untuk menghindari komplikasi yang terkait dengan penggunaan bitcoin yang baru dibuat pada sebuah rantai yang nantinya dapat menjadi usang.

### Implikasi dari model UTXO

Pertama-tama, model UTXO secara langsung mempengaruhi biaya transaksi Bitcoin. Karena kapasitas setiap blok terbatas, para penambang memilih transaksi yang menawarkan biaya terbaik sehubungan dengan ruang yang akan mereka gunakan dalam blok tersebut. Memang, semakin banyak UTXO yang disertakan dalam input dan output transaksi, maka semakin berat transaksi tersebut, dan oleh karena itu membutuhkan biaya yang lebih tinggi. Ini adalah salah satu alasan mengapa kami sering mencoba mengurangi jumlah UTXO dalam portofolio kami, yang juga dapat memengaruhi kerahasiaan, sebuah topik yang akan kita bahas secara mendetail di bagian ketiga kursus ini.

Kedua, seperti yang telah disebutkan di bagian sebelumnya, koin Bitcoin pada dasarnya adalah sebuah rantai UTXO. Setiap transaksi menciptakan hubungan antara UTXO masa lalu dan UTXO masa depan. Oleh karena itu, UTXO memungkinkan untuk secara eksplisit mengikuti jalur Bitcoin dari pembuatannya hingga penggunaannya saat ini. Transparansi ini dapat dilihat secara positif, karena memungkinkan setiap pengguna untuk memastikan keaslian bitcoin yang diterima. Akan tetapi, prinsip ketertelusuran dan kemampuan untuk diaudit inilah yang mendasari analisis blockchain, sebuah praktik yang dirancang untuk membahayakan kerahasiaan Anda. Kita akan membahas praktik ini secara mendalam di bagian kedua dari kursus ini.

## Model privasi Bitcoin

<chapterId>769d8963-3ed5-4094-b21d-9203c7d9e465</chapterId>


### Uang: keaslian, integritas, dan pengeluaran ganda

Salah satu fungsi uang adalah untuk memecahkan masalah kebetulan ganda dari kebutuhan. Dalam sistem barter, penyelesaian pertukaran tidak hanya membutuhkan seseorang yang memberikan barang yang sesuai dengan kebutuhan saya, tetapi juga menyediakan barang yang nilainya setara yang memuaskan kebutuhannya sendiri. Mencapai keseimbangan ini adalah masalah yang kompleks.

![BTC204](assets/fr/017.webp)

Itulah mengapa kami menggunakan uang untuk memindahkan nilai dalam ruang dan waktu.

![BTC204](assets/fr/018.webp)

Agar mata uang kripto dapat mengatasi masalah ini, sangat penting bahwa pihak yang menyediakan barang atau jasa yakin akan kemampuannya untuk membelanjakan uang tersebut di kemudian hari. Dengan demikian, setiap individu yang rasional yang ingin menerima koin, baik digital maupun fisik, akan memastikan bahwa koin tersebut memenuhi dua kriteria mendasar:


- Karya tersebut harus memiliki integritas dan keaslian; **)
- dan tidak boleh digunakan dua kali.**

Jika Anda menggunakan mata uang fisik, ini adalah karakteristik pertama yang paling rumit untuk ditegaskan. Pada periode yang berbeda dalam sejarah, integritas koin logam sering kali dipengaruhi oleh praktik-praktik seperti pemangkasan atau penindikan. Di Romawi kuno, misalnya, adalah praktik umum bagi warga untuk mengikis tepi koin emas untuk mengumpulkan sedikit logam mulia, sambil menyimpannya untuk transaksi di masa depan. Dengan demikian, nilai intrinsik koin berkurang, tetapi nilai nominalnya tetap sama. Ini adalah salah satu alasan mengapa tepi koin kemudian bergalur.

Keaslian juga merupakan karakteristik yang sulit untuk diverifikasi pada media moneter fisik. Teknik-teknik untuk memerangi mata uang palsu saat ini semakin kompleks, sehingga memaksa para peritel untuk berinvestasi dalam sistem verifikasi yang mahal.

Di sisi lain, karena sifatnya, pembelanjaan ganda tidak menjadi masalah untuk mata uang fisik. Jika saya memberi Anda uang kertas €10, uang tersebut secara permanen meninggalkan kepemilikan saya dan menjadi milik Anda, yang secara alami mengesampingkan kemungkinan pembelanjaan ganda dari unit moneter yang diwujudkannya. Singkatnya, saya tidak akan bisa membelanjakan uang kertas €10 ini lagi.

![BTC204](assets/fr/019.webp)

Untuk mata uang digital, kesulitannya berbeda. Memastikan keaslian dan integritas sebuah koin seringkali lebih sederhana. Seperti yang kita lihat pada bagian sebelumnya, model UTXO Bitcoin memungkinkan untuk melacak koin kembali ke asalnya, dan dengan demikian memverifikasi bahwa koin tersebut memang dibuat oleh penambang yang mematuhi aturan konsensus.

Di sisi lain, memastikan bahwa tidak ada pengeluaran ganda lebih kompleks, karena semua barang digital pada dasarnya adalah informasi. Tidak seperti barang fisik, informasi tidak terbagi-bagi saat dipertukarkan, tetapi menyebar dengan cara digandakan. Sebagai contoh, jika saya mengirimi Anda sebuah dokumen melalui email, dokumen tersebut akan digandakan. Anda tidak dapat memastikan bahwa saya telah menghapus dokumen aslinya.

![BTC204](assets/fr/020.webp)

### Mencegah pengeluaran ganda untuk Bitcoin

Satu-satunya cara untuk menghindari duplikasi aset digital ini adalah dengan mengetahui semua pertukaran pada sistem. Dengan cara ini, kita dapat mengetahui siapa yang memiliki apa dan memperbarui kepemilikan setiap orang sesuai dengan transaksi yang dilakukan. Inilah yang terjadi, misalnya, dengan uang kertas dalam sistem perbankan. Ketika Anda membayar €10 kepada pedagang dengan kartu kredit, bank mencatat pertukaran dan memperbarui buku rekening.

![BTC204](assets/fr/021.webp)

Pada Bitcoin, pembelanjaan ganda dicegah dengan cara yang sama. Kami berusaha memastikan tidak adanya transaksi yang telah membelanjakan koin yang bersangkutan. Jika koin tersebut belum pernah digunakan, maka dapat dipastikan tidak akan ada pembelanjaan ganda yang terjadi. Prinsip ini dijelaskan oleh Satoshi Nakamoto dalam White Paper dengan kalimat yang terkenal:

**Satu-satunya cara untuk mengonfirmasi tidak adanya transaksi adalah dengan mengetahui semua transaksi

Namun, tidak seperti model perbankan, kita tidak ingin mempercayai entitas pusat pada Bitcoin. Jadi, semua pengguna harus bisa memastikan tidak adanya pembelanjaan ganda, tanpa bergantung pada pihak ketiga. Jadi setiap orang perlu mengetahui semua transaksi Bitcoin. Inilah sebabnya mengapa transaksi Bitcoin disiarkan secara publik di semua node jaringan dan dicatat dalam teks yang jelas di blockchain.

Justru penyebaran informasi secara publik inilah yang mempersulit perlindungan privasi dalam Bitcoin. Dalam sistem perbankan tradisional, secara teori, hanya lembaga keuangan yang mengetahui transaksi yang dilakukan. Dengan Bitcoin, di sisi lain, semua pengguna diberitahu tentang semua transaksi, melalui node masing-masing.

### Model kerahasiaan: sistem perbankan vs. Bitcoin

Dalam sistem tradisional, rekening bank Anda ditautkan dengan identitas Anda. Bank dapat mengetahui rekening bank mana yang dimiliki oleh nasabah mana, dan transaksi apa saja yang terkait dengannya. Namun, aliran informasi ini terputus antara bank dan domain publik. Dengan kata lain, tidak mungkin untuk mengetahui saldo dan transaksi rekening bank milik individu lain. Hanya bank yang memiliki akses ke informasi ini.

![BTC204](assets/fr/022.webp)

Sebagai contoh, bankir Anda mengetahui bahwa Anda membeli baguette setiap pagi dari tukang roti setempat, tetapi tetangga Anda tidak mengetahui transaksi ini. Dengan cara ini, arus informasi dapat diakses oleh pihak-pihak terkait, terutama bank, tetapi tetap tidak dapat diakses oleh pihak luar.

![BTC204](assets/fr/023.webp)

Karena kendala penyebaran transaksi ke publik yang telah kita lihat pada bagian sebelumnya, model kerahasiaan Bitcoin tidak dapat mengikuti model sistem perbankan. Dalam kasus Bitcoin, karena aliran informasi tidak dapat dipecah antara transaksi dan domain publik, maka model kerahasiaan bergantung pada pemisahan antara identitas pengguna dan transaksi itu sendiri.

![BTC204](assets/fr/024.webp)

Sebagai contoh, jika Anda membeli sebuah baguette dari tukang roti, dengan membayar menggunakan BTC, tetangga Anda, yang memiliki node lengkapnya sendiri, dapat melihat transaksi Anda, seperti halnya dia dapat melihat semua transaksi lain dalam sistem. Namun, jika prinsip kerahasiaan dihormati, dia seharusnya tidak dapat menghubungkan transaksi khusus ini dengan identitas Anda.

![BTC204](assets/fr/025.webp)

Namun karena transaksi Bitcoin bersifat publik, maka masih memungkinkan untuk membuat hubungan di antara mereka untuk menyimpulkan informasi mengenai pihak-pihak yang terlibat. Kegiatan ini bahkan merupakan spesialisasi tersendiri, yang dikenal sebagai "analisis blockchain". Di bagian selanjutnya dari kursus ini, saya mengundang Anda untuk menjelajahi dasar-dasar analisis blockchain, sehingga Anda dapat memahami bagaimana bitcoin Anda dilacak dan melindungi diri Anda dengan lebih baik.

# Memahami dan melindungi dari analisis rantai

<partId>4739371e-9fef-45b0-bcaa-b7a4df6b4470</partId>

## Apa itu analisis rantai Bitcoin?

<chapterId>7d198ba6-4af2-4f24-86cb-3c79cb25627e</chapterId>


### Definisi dan pengoperasian

Analisis blockchain adalah praktik melacak aliran bitcoin di blockchain. Secara umum, analisis rantai didasarkan pada pengamatan karakteristik dalam sampel transaksi sebelumnya. Kemudian, analisis ini terdiri dari identifikasi karakteristik yang sama pada transaksi yang ingin kita analisis, dan menyimpulkan interpretasi yang masuk akal darinya. Metode pemecahan masalah ini, berdasarkan pada pendekatan praktis untuk menemukan solusi yang cukup baik, dikenal sebagai "heuristik".

Dalam istilah awam, ada tiga tahap utama dalam analisis rantai:

1. **Mengamati blockchain; ** Mengamati blockchain

2. **Identifikasi fitur yang diketahui; ** Identifikasi fitur yang diketahui

3. **Pengurangan asumsi ** Pengurangan asumsi

![BTC204](assets/fr/026.webp)

Analisis blockchain dapat dilakukan oleh siapa saja. Yang Anda perlukan hanyalah akses ke informasi publik blockchain melalui sebuah node yang lengkap untuk mengamati pergerakan transaksi dan membuat hipotesis. Ada juga alat gratis yang memfasilitasi analisis ini, seperti [OXT.me] (https://oxt.me/), yang akan kita bahas secara rinci dalam dua bab terakhir bagian ini. Akan tetapi, risiko utama terhadap kerahasiaan berasal dari perusahaan yang berspesialisasi dalam analisis string. Perusahaan-perusahaan ini telah membawa analisis blockchain ke dalam skala industri dan menjual jasa mereka kepada institusi keuangan dan pemerintah. Di antara perusahaan-perusahaan ini, Chainalysis adalah yang paling terkenal.

### Tujuan analisis rantai

Salah satu tujuan analisis blockchain adalah untuk mengelompokkan berbagai aktivitas di Bitcoin untuk menentukan keunikan pengguna yang melakukannya. Selanjutnya, akan memungkinkan untuk mencoba menghubungkan kelompok aktivitas ini dengan identitas asli.

![BTC204](assets/fr/027.webp)

Pikirkan kembali bab sebelumnya. Saya telah menjelaskan mengapa model privasi Bitcoin pada awalnya didasarkan pada pemisahan identitas pengguna dari transaksi. Oleh karena itu, akan sangat menggoda untuk berpikir bahwa analisis blockchain tidak berguna, karena meskipun kita dapat mengumpulkan aktivitas onchain, kita tidak dapat mengaitkannya dengan identitas yang sebenarnya.

Secara teoritis, pernyataan ini benar. Pada bagian pertama kursus ini, kita telah melihat bahwa pasangan kunci kriptografi digunakan untuk menetapkan kondisi pada UTXO. Pada intinya, pasangan kunci ini tidak membocorkan informasi tentang identitas pemegangnya. Jadi, meskipun kita berhasil mengelompokkan aktivitas yang terkait dengan pasangan kunci yang berbeda, hal ini tidak memberi tahu kita apa pun tentang entitas di balik aktivitas tersebut.

![BTC204](assets/fr/028.webp)

Akan tetapi, kenyataan praktisnya jauh lebih kompleks. Ada banyak sekali perilaku yang dapat menghubungkan identitas nyata dengan aktivitas onchain. Dalam analisis, ini disebut titik masuk, dan ada banyak sekali.

Yang paling umum adalah KYC (*Know Your Customer*). Jika Anda menarik Bitcoin Anda dari platform yang teregulasi ke salah satu alamat penerima pribadi Anda, maka beberapa orang dapat menautkan identitas Anda ke alamat tersebut. Secara lebih luas, titik masuk dapat berupa segala bentuk interaksi antara kehidupan nyata Anda dan transaksi Bitcoin. Sebagai contoh, jika Anda mempublikasikan alamat penerima di jejaring sosial Anda, ini bisa menjadi titik masuk untuk analisis. Jika Anda melakukan pembayaran dengan Bitcoin kepada penjual roti, ia akan dapat mengasosiasikan wajah Anda (bagian dari identitas Anda) dengan alamat Bitcoin.

Titik-titik masuk ini hampir tidak dapat dihindari ketika menggunakan Bitcoin. Meskipun kita mungkin berusaha untuk membatasi cakupannya, mereka akan selalu ada. Oleh karena itu, sangat penting untuk menggabungkan metode-metode yang bertujuan untuk menjaga privasi Anda. Meskipun menjaga pemisahan antara identitas asli dan transaksi Anda adalah pendekatan yang menarik, namun hal ini masih belum cukup untuk saat ini. Memang, jika semua aktivitas onchain Anda dapat dikelompokkan bersama, maka titik masuk terkecil sekalipun kemungkinan besar akan mengganggu lapisan kerahasiaan yang telah Anda buat.

![BTC204](assets/fr/029.webp)

### Mempertahankan diri Anda dari analisis berantai

Jadi, kita juga harus mampu mengatasi analisis blockchain dalam penggunaan Bitcoin. Dengan demikian, kita bisa meminimalkan agregasi aktivitas kita dan membatasi dampak dari sebuah titik masuk terhadap privasi kita.

![BTC204](assets/fr/030.webp)

Apa cara yang lebih baik untuk melawan analisis blockchain selain mempelajari metode yang digunakan di dalamnya? Jika Anda ingin tahu cara meningkatkan privasi Anda di Bitcoin, Anda perlu memahami metode-metode ini. Ini akan memberi Anda pemahaman yang lebih baik tentang teknik-teknik seperti coinjoin atau payjoin (teknik yang akan kita bahas di bagian akhir kursus ini), dan mengurangi kesalahan yang mungkin Anda buat.

https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef

https://planb.network/tutorials/privacy/on-chain/payjoin-848b6a23-deb2-4c5f-a27e-93e2f842140f

Dalam hal ini, kita dapat menarik analogi dengan kriptografi dan kriptanalisis. Seorang kriptografer yang baik pertama-tama adalah seorang kriptanalis yang baik. Untuk merancang sebuah algoritma enkripsi baru, Anda perlu mengetahui serangan apa yang akan dihadapi, dan juga mempelajari mengapa algoritma sebelumnya telah dibobol. Prinsip yang sama berlaku untuk privasi Bitcoin. Memahami metode analisis blockchain adalah kunci untuk melindungi diri dari serangan tersebut. Itulah mengapa saya telah memasukkan seluruh bagian tentang analisis rantai dalam kursus ini.

### Metode analisis rantai

Penting untuk dipahami bahwa analisis string bukanlah ilmu pasti. Analisis ini bergantung pada heuristik yang berasal dari pengamatan sebelumnya atau interpretasi logis. Aturan-aturan ini memungkinkan kita untuk mendapatkan hasil yang cukup dapat diandalkan, tetapi tidak pernah dengan ketepatan yang mutlak. Dengan kata lain, **analisis rantai selalu melibatkan dimensi probabilitas dalam kesimpulan yang dicapai**. Sebagai contoh, mungkin saja kita dapat memperkirakan dengan berbagai tingkat kepastian bahwa dua alamat adalah milik entitas yang sama, tetapi kepastian total akan selalu berada di luar jangkauan.

Inti dari analisis rantai terletak pada agregasi berbagai heuristik untuk meminimalkan risiko kesalahan. Di satu sisi, ini adalah akumulasi bukti yang membawa kita lebih dekat dengan kenyataan.

Heuristik terkenal ini dapat dikelompokkan ke dalam berbagai kategori, yang akan kami jelaskan secara rinci di bawah ini:


- Pola transaksi ;**;
- Heuristik transaksi-internal; ** Heuristik transaksi-internal; ** Heuristik transaksi-internal
- Heuristik di luar transaksi.**

### Satoshi Nakamoto dan analisis rantai

Dua heuristik analisis rantai pertama ditemukan oleh Satoshi Nakamoto sendiri. Dia membicarakannya di Bagian 10 dari Buku Putih Bitcoin. Mereka adalah :


- cIOH (*Common Input Ownership Heuristic*);
- dan penggunaan ulang alamat.

![BTC204](assets/fr/031.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

Kita akan melihat apa saja yang akan dibahas pada bab-bab selanjutnya, tetapi sudah menarik untuk dicatat bahwa kedua heuristik ini masih tetap menjadi yang terdepan dalam analisis rantai saat ini.

## Pola transaksi

<chapterId>d365a101-2d37-46a5-bfb9-3c51e37bf96b</chapterId>


Pola transaksi adalah sebuah model atau struktur keseluruhan dari sebuah transaksi, yang dapat ditemukan di blockchain, dan yang kemungkinan interpretasinya dapat diketahui. Ketika mempelajari pola, kita fokus pada satu transaksi dan menganalisanya pada tingkat yang tinggi.

Dengan kata lain, kita hanya akan melihat jumlah UTXO yang masuk dan jumlah UTXO yang keluar, tanpa memikirkan detail atau lingkungan transaksi yang lebih spesifik. Berdasarkan pola yang diamati, kita dapat menginterpretasikan sifat dari transaksi tersebut. Kita kemudian akan mencari karakteristik strukturnya dan menyimpulkan interpretasi.

![BTC204](assets/fr/032.webp)

Pada bagian ini, kita akan melihat bersama model-model transaksi utama yang ditemukan dalam analisis rantai, dan untuk setiap model, saya akan memberi Anda interpretasi yang mungkin dari struktur ini, serta contoh konkret.

### Pengiriman tunggal (atau pembayaran tunggal)

Mari kita mulai dengan pola yang sangat umum, karena pola inilah yang muncul pada sebagian besar pembayaran bitcoin. Model pembayaran sederhana ditandai dengan konsumsi satu atau lebih UTXO sebagai input dan produksi 2 UTXO sebagai output. Oleh karena itu, model ini terlihat seperti ini:

![BTC204](assets/fr/033.webp)

Ketika kita melihat struktur transaksi ini pada blockchain, kita sudah dapat menarik sebuah interpretasi. Seperti namanya, model ini menunjukkan bahwa kita sedang melakukan transaksi pengiriman atau pembayaran. Pengguna telah menggunakan UTXO miliknya sebagai input untuk menghasilkan output berupa UTXO pembayaran dan UTXO penukaran (uang yang dikembalikan ke pengguna yang sama).

Oleh karena itu, kita tahu bahwa pengguna yang diamati mungkin tidak lagi memiliki salah satu dari dua output UTXO (UTXO pembayaran), tetapi masih memiliki UTXO lainnya (UTXO pertukaran).

Untuk saat ini, kita tidak dapat menentukan output mana yang mewakili UTXO yang mana, karena ini bukan tujuan dari studi pola. Kita akan sampai di sana dengan mengandalkan heuristik yang akan kita pelajari di bagian berikut. Pada tahap ini, tujuan kita terbatas pada mengidentifikasi sifat transaksi yang dimaksud, yang dalam hal ini adalah pengiriman sederhana.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang menggunakan pola pengiriman sederhana:

```plaintext
b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769
```

![BTC204](assets/fr/034.webp)

Source : [Mempool.space](https://mempool.space/fr/tx/b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769)

Setelah contoh pertama ini, Anda seharusnya memiliki pemahaman yang lebih baik tentang apa yang dimaksud dengan mempelajari "model transaksi". Kita mempelajari sebuah transaksi dengan hanya berfokus pada strukturnya, tanpa memperhitungkan lingkungan atau detail spesifik dari transaksi tersebut. Pada langkah pertama ini, kita hanya melihat gambaran besarnya saja.

Sekarang, setelah Anda memahami apa itu pola, mari kita beralih ke model lain yang ada.

### Menyapu

Model kedua ini dicirikan oleh konsumsi satu UTXO sebagai input dan produksi satu UTXO sebagai output.

![BTC204](assets/fr/035.webp)

Interpretasi dari model ini adalah bahwa kita berada di hadapan transfer sendiri. Pengguna telah mentransfer bitcoin-nya ke dirinya sendiri, ke alamat lain miliknya. Karena tidak ada pertukaran dalam transaksi ini, maka sangat kecil kemungkinannya bahwa kita sedang melakukan pembayaran. Memang, ketika pembayaran dilakukan, hampir tidak mungkin bagi pembayar untuk mendapatkan UTXO yang sesuai dengan jumlah yang diminta oleh penjual, ditambah dengan biaya transaksi. Oleh karena itu, secara umum, pembayar diwajibkan untuk menghasilkan output pertukaran.

Kita kemudian tahu bahwa pengguna yang diamati mungkin masih memiliki UTXO ini. Dalam konteks analisis rantai, jika kita tahu bahwa UTXO yang digunakan sebagai input transaksi adalah milik Alice, kita dapat mengasumsikan bahwa UTXO yang digunakan sebagai output juga adalah miliknya. Yang akan menjadi menarik nantinya adalah menemukan heuristik transaksi-internal yang dapat memperkuat asumsi ini (kita akan melihat heuristik ini di bab 3.3).

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi pola sapuan:

```plaintext
35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d
```

![BTC204](assets/fr/036.webp)

Source : [Mempool.space](https://mempool.space/fr/tx/35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d)

Akan tetapi, berhati-hatilah karena pola seperti ini juga dapat mengungkap transfer mandiri ke akun platform bursa mata uang kripto. Studi mengenai alamat yang diketahui dan konteks transaksi yang akan memberi tahu kita apakah itu merupakan penggesekan ke dompet penyimpanan mandiri atau penarikan ke platform. Memang, alamat platform bursa sering kali mudah dikenali.

Mari kita ambil contoh Alice lagi: jika pemindaian mengarah ke alamat yang diketahui oleh sebuah platform (seperti Binance, misalnya), ini mungkin berarti bahwa bitcoin telah ditransfer keluar dari kepemilikan langsung Alice, mungkin dengan tujuan untuk menjual atau menyimpannya di platform ini. Di sisi lain, jika alamat tujuan tidak diketahui, masuk akal untuk mengasumsikan bahwa itu hanyalah dompet lain yang masih milik Alice. Tetapi jenis penelitian ini lebih masuk dalam kategori heuristik daripada pola.

### Konsolidasi

Model ini dicirikan oleh konsumsi beberapa UTXO pada input dan produksi satu UTXO pada output.

![BTC204](assets/fr/037.webp)

Interpretasi dari pola ini adalah bahwa kita sedang berada di tengah-tengah konsolidasi. Ini adalah praktik umum di kalangan pengguna Bitcoin, yang bertujuan untuk menggabungkan beberapa UTXO untuk mengantisipasi kemungkinan kenaikan biaya transaksi. Dengan melakukan operasi ini selama periode ketika biaya rendah, Anda dapat menghemat biaya di masa mendatang. Kita akan membahas lebih lanjut mengenai praktik ini di bab 4.3.

Kita dapat menyimpulkan bahwa pengguna di balik model transaksi ini mungkin memiliki semua UTXO sebagai input dan masih memiliki UTXO sebagai output. Jadi, ini mungkin merupakan transfer otomatis.

Seperti sapuan, jenis pola ini juga dapat mengungkapkan transfer mandiri ke akun platform bursa. Studi mengenai alamat yang diketahui dan konteks transaksi yang akan memberi tahu kita apakah itu konsolidasi ke portofolio penyimpanan sendiri atau penarikan ke platform.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi pola konsolidasi:

```plaintext
77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94
```

![BTC204](assets/fr/038.webp)

Source : [Mempool.space](https://mempool.space/fr/tx/77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94)

Dalam analisis rantai, model ini dapat mengungkapkan banyak informasi. Sebagai contoh, jika kita mengetahui bahwa salah satu input adalah milik Alice, kita dapat mengasumsikan bahwa semua input lainnya dan output dari transaksi ini juga merupakan miliknya. Asumsi ini kemudian memungkinkan kita untuk menelusuri rantai transaksi sebelumnya untuk menemukan dan menganalisis transaksi lain yang mungkin terkait dengan Alice.

![BTC204](assets/fr/039.webp)

### Pengeluaran yang dikelompokkan

Model ini dicirikan oleh konsumsi beberapa UTXO sebagai input (seringkali hanya satu) dan produksi banyak UTXO sebagai output.

![BTC204](assets/fr/040.webp)

Interpretasi dari model ini adalah bahwa kita berada di hadapan pengeluaran yang dikelompokkan. Ini adalah praktik yang mungkin menunjukkan aktivitas ekonomi yang sangat besar, seperti platform pertukaran. Pengeluaran yang dikelompokkan memungkinkan entitas-entitas ini untuk menghemat biaya dengan menggabungkan pengeluaran mereka dalam satu transaksi.

Kita dapat menyimpulkan dari model ini bahwa UTXO dalam input berasal dari perusahaan dengan tingkat aktivitas ekonomi yang tinggi, dan bahwa UTXO dalam output akan menyebar. Sebagian besar akan menjadi milik pelanggan perusahaan yang telah menarik bitcoin dari platform. Sebagian lagi mungkin akan diberikan kepada perusahaan mitra. Akhirnya, pasti akan ada satu atau lebih bursa yang kembali ke perusahaan penerbit.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi pola pembelanjaan yang dibundel (mungkin, ini adalah transaksi yang dikeluarkan oleh platform Bybit):

```plaintext
8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43
```

![BTC204](assets/fr/041.webp)

Source : [Mempool.space](https://mempool.space/fr/tx/8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43)

### Transaksi khusus protokol

Di antara pola-pola transaksi, kita juga dapat mengidentifikasi pola-pola yang menunjukkan penggunaan protokol tertentu. Sebagai contoh, Whirlpool coinjoins (dibahas pada bagian 5) akan memiliki struktur yang mudah diidentifikasi yang membedakannya dari transaksi lain yang lebih konvensional.

![BTC204](assets/fr/042.webp)

Analisis dari pola ini menunjukkan bahwa kita kemungkinan besar berada dalam sebuah transaksi kolaboratif. Kita juga dapat mengamati sebuah coinjoin. Jika hipotesis terakhir ini terbukti benar, maka jumlah pintu keluar dapat memberikan perkiraan kasar jumlah peserta dalam coinjoin.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi pola transaksi kolaboratif coinjoin:

```plaintext
00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea
```

![BTC204](assets/fr/043.webp)

Source : [Mempool.space](https://mempool.space/fr/tx/00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea)

Ada banyak protokol lain dengan struktur spesifiknya masing-masing. Sebagai contoh, ada transaksi Wabisabi, transaksi Stamps, dan transaksi Rune.

Berkat pola-pola transaksi ini, kita sudah dapat menginterpretasikan sejumlah informasi tentang transaksi tertentu. Namun, struktur transaksi bukanlah satu-satunya sumber informasi untuk analisis. Kita juga dapat mempelajari detailnya. Detail internal ini adalah apa yang saya sebut sebagai "heuristik internal", dan kita akan membahasnya di bab berikutnya.

## Heuristik internal

<chapterId>c54b5abe-872f-40f4-a0d0-c59faff228ba</chapterId>


Heuristik internal adalah karakteristik spesifik yang kita identifikasi di dalam transaksi itu sendiri, tanpa perlu memeriksa lingkungannya, dan yang memungkinkan kita untuk membuat kesimpulan. Tidak seperti pola, yang berfokus pada keseluruhan struktur transaksi pada tingkat yang tinggi, heuristik internal didasarkan pada sekumpulan data yang dapat diekstrak. Ini termasuk:


- Jumlah berbagai UTXO yang masuk dan keluar;
- Segala sesuatu yang berkaitan dengan skrip: alamat penerimaan, versi, waktu penguncian ...

Secara umum, jenis heuristik ini akan memungkinkan kita untuk mengidentifikasi pertukaran dalam transaksi tertentu. Dengan demikian, kita dapat melacak sebuah entitas melalui beberapa transaksi yang berbeda. Memang, jika kita mengidentifikasi UTXO milik pengguna yang ingin kita lacak, sangat penting untuk menentukan, ketika dia melakukan transaksi, output mana yang telah ditransfer ke pengguna lain dan output mana yang mewakili bursa, yang dengan demikian tetap dalam kepemilikannya.

![BTC204](assets/fr/044.webp)

Sekali lagi, izinkan saya mengingatkan Anda bahwa heuristik ini tidak sepenuhnya tepat. Jika digunakan secara terpisah, mereka hanya memungkinkan kita untuk mengidentifikasi skenario yang mungkin terjadi. Ini adalah akumulasi dari beberapa heuristik yang membantu mengurangi ketidakpastian, tanpa bisa menghilangkannya sepenuhnya.

### Kesamaan internal

Heuristik ini melibatkan studi tentang kesamaan antara input dan output dari transaksi yang sama. Jika karakteristik yang sama terlihat pada input dan hanya pada salah satu output transaksi, maka kemungkinan output ini merupakan pertukaran.

Fitur yang paling jelas adalah penggunaan ulang alamat penerima dalam transaksi yang sama.

![BTC204](assets/fr/045.webp)

Heuristik ini hanya menyisakan sedikit ruang untuk keraguan. Kecuali jika kunci pribadinya diretas, alamat penerima yang sama akan mengungkapkan aktivitas dari satu pengguna. Interpretasi yang dihasilkan adalah bahwa pertukaran transaksi adalah output dengan alamat yang sama dengan input. Kita kemudian dapat terus melacak individu dari pertukaran ini.

Sebagai contoh, berikut ini adalah sebuah transaksi di mana heuristik ini dapat diterapkan:

```plaintext
54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0
```

![BTC204](assets/fr/046.webp)

Source : [Mempool.space](https://mempool.space/tx/54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0)

Kemiripan antara input dan output ini tidak berhenti pada penggunaan ulang alamat. Kesamaan dalam penggunaan skrip dapat digunakan untuk menerapkan heuristik. Sebagai contoh, terkadang kita dapat mengamati versi yang sama antara input dan salah satu output transaksi.

![BTC204](assets/fr/047.webp)

Pada diagram ini, kita dapat melihat bahwa input n° 0 membuka skrip P2WPKH (SegWit V0 yang dimulai dengan `bc1q`). Keluaran n° 0 menggunakan jenis skrip yang sama. Sebaliknya, keluaran nomor 1 menggunakan skrip P2TR (SegWit V1 yang dimulai dengan `bc1p`). Interpretasi dari fitur ini adalah kemungkinan alamat dengan versi yang sama dengan input adalah alamat pertukaran. Oleh karena itu, alamat tersebut akan selalu menjadi milik pengguna yang sama.

Berikut ini adalah sebuah transaksi di mana heuristik ini mungkin dapat diterapkan:

```plaintext
db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578
```

![BTC204](assets/fr/048.webp)

Source : [Mempool.space](https://mempool.space/tx/db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578)

Pada yang terakhir, kita dapat melihat bahwa input no. 0 dan output no. 1 menggunakan skrip P2WPKH (SegWit V0), sementara output no. 0 menggunakan skrip P2PKH yang berbeda (Legacy).

Pada awal tahun 2010-an, heuristik berdasarkan versi skrip ini relatif tidak membantu karena terbatasnya jenis skrip yang tersedia. Namun, seiring berjalannya waktu dan dengan pembaruan Bitcoin, semakin banyak jenis skrip yang diperkenalkan. Oleh karena itu, heuristik ini menjadi semakin relevan, karena dengan semakin banyaknya jenis skrip, pengguna terbagi ke dalam kelompok-kelompok yang lebih kecil, sehingga meningkatkan peluang untuk menerapkan heuristik penggunaan ulang versi internal ini. Untuk alasan ini, dari perspektif kerahasiaan saja, disarankan untuk memilih jenis skrip yang paling umum. Sebagai contoh, saat saya menulis baris-baris ini, skrip Taproot (`bc1p`) lebih jarang digunakan daripada skrip SegWit V0 (`bc1q`). Meskipun yang pertama menawarkan manfaat ekonomi dan kerahasiaan dalam konteks tertentu, untuk penggunaan tanda tangan tunggal yang lebih tradisional, mungkin masuk akal untuk tetap menggunakan standar yang lebih lama untuk alasan kerahasiaan, sampai standar baru lebih banyak diadopsi.

### Pembayaran angka bulat

Heuristik internal lain yang dapat membantu kita mengidentifikasi pertukaran adalah heuristik angka bulat. Secara umum, ketika dihadapkan pada pola pembayaran sederhana (1 input dan 2 output), jika salah satu output mengeluarkan jumlah yang bulat, maka ini mewakili pembayaran.

![BTC204](assets/fr/049.webp)

Dengan eliminasi, jika satu output mewakili pembayaran, maka output lainnya mewakili pertukaran. Oleh karena itu, dapat diartikan bahwa pengguna input selalu memiliki output yang diidentifikasi sebagai pertukaran.

Perlu ditekankan bahwa heuristik ini tidak selalu dapat diterapkan, karena sebagian besar pembayaran masih dilakukan dalam unit akun fidusia. Memang, ketika pengecer di Prancis menerima bitcoin, ia umumnya tidak akan menampilkan harga yang stabil dalam sat. Sebaliknya, ia akan memilih konversi antara harga dalam euro dan jumlah bitcoin yang harus dibayar. Oleh karena itu, seharusnya tidak ada angka bulat di akhir transaksi.

Namun demikian, seorang analis dapat mencoba melakukan konversi ini dengan mempertimbangkan nilai tukar yang berlaku saat transaksi disiarkan di jaringan. Mari kita ambil contoh transaksi dengan input `97.552 sats` dan dua output, satu dari `31.085 sats` dan satu lagi `64.152 sats`. Sekilas, transaksi ini tidak terlihat seperti melibatkan jumlah yang bulat. Namun, dengan menggunakan nilai tukar €64.339 pada saat transaksi, kita mendapatkan konversi ke dalam euro sebagai berikut:


- Masukan sebesar €62,76;
- Keluaran sebesar €20;
- Output sebesar €41,27.

Setelah dikonversi ke dalam mata uang fiat, transaksi ini dapat digunakan untuk menerapkan heuristik pembayaran jumlah bulat. Hasil €20 mungkin diberikan kepada pedagang, atau setidaknya berpindah kepemilikan. Dengan pengurangan, hasil €41,27 kemungkinan besar tetap menjadi milik pengguna asli.

![BTC204](assets/fr/050.webp)

Jika suatu hari nanti, bitcoin menjadi unit akun yang lebih disukai di bursa kita, heuristik ini dapat menjadi lebih berguna untuk analisis.

Sebagai contoh, berikut ini adalah sebuah transaksi di mana heuristik ini dapat diterapkan:

```plaintext
2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a
```

![BTC204](assets/fr/051.webp)

Source : [Mempool.space](https://mempool.space/tx/2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a)

### Output terbesar

Ketika kita mengidentifikasi kesenjangan yang cukup besar antara 2 output transaksi pada model pembayaran sederhana, kita dapat memperkirakan bahwa output terbesar kemungkinan besar adalah valuta asing.

![BTC204](assets/fr/052.webp)

Heuristik keluaran terbesar ini tentunya adalah yang paling tidak tepat dari semuanya. Dengan sendirinya, ini cukup lemah. Namun, fitur ini dapat dikombinasikan dengan heuristik lain untuk mengurangi ketidakpastian interpretasi kita.

Sebagai contoh, jika kita melihat sebuah transaksi dengan pembayaran bulat dan pembayaran yang lebih besar, menerapkan heuristik pembayaran bulat dan heuristik pembayaran yang lebih besar secara bersamaan akan mengurangi tingkat ketidakpastian.

Sebagai contoh, berikut ini adalah sebuah transaksi di mana heuristik ini dapat diterapkan:

```plaintext
b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf
```

![BTC204](assets/fr/053.webp)

Source : [Mempool.space](https://mempool.space/tx/b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf)

## Heuristik eksternal

<chapterId>4a170e3b-200d-431a-8285-18a23ff617ba</chapterId>


Studi heuristik eksternal berarti menganalisis kesamaan, pola, dan karakteristik dari elemen-elemen tertentu yang tidak spesifik untuk transaksi itu sendiri. Dengan kata lain, jika sebelumnya kita membatasi diri untuk mengeksploitasi elemen-elemen intrinsik dari transaksi dengan heuristik internal, sekarang kita memperluas bidang analisis kita dengan menyertakan lingkungan transaksi, berkat heuristik eksternal.

### Penggunaan kembali alamat

Ini adalah salah satu heuristik yang paling terkenal di kalangan pengguna bitcoin. Penggunaan ulang alamat memungkinkan untuk membuat hubungan antara transaksi yang berbeda dan UTXO yang berbeda. Hal ini terjadi ketika sebuah alamat penerima Bitcoin digunakan beberapa kali.

Dengan demikian, dimungkinkan untuk mengeksploitasi penggunaan ulang alamat dalam transaksi yang sama sebagai heuristik internal untuk mengidentifikasi pertukaran (seperti yang kita lihat di bab sebelumnya). Tetapi penggunaan ulang alamat juga dapat digunakan sebagai heuristik eksternal untuk mengenali keunikan sebuah entitas di balik beberapa transaksi.

Interpretasi dari penggunaan kembali sebuah alamat adalah bahwa semua UTXO yang diblokir pada alamat tersebut adalah milik (atau pernah menjadi milik) entitas yang sama. Heuristik ini hanya menyisakan sedikit ruang untuk ketidakpastian. Setelah diidentifikasi, interpretasi yang dihasilkan kemungkinan besar akan sesuai dengan kenyataan. Oleh karena itu, hal ini memungkinkan pengelompokan aktivitas onchain yang berbeda.

![BTC204](assets/fr/054.webp)

Seperti yang dijelaskan pada pendahuluan di Bagian 3, heuristik ini ditemukan oleh Satoshi Nakamoto sendiri. Dalam White Paper, ia menyebutkan sebuah solusi untuk membantu pengguna menghindari pembuatannya, yaitu dengan menggunakan alamat kosong untuk setiap transaksi baru:

"Sebagai firewall tambahan, pasangan kunci baru dapat digunakan untuk setiap transaksi agar tidak terhubung dengan pemilik yang sama."

![BTC204](assets/fr/055.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

Sebagai contoh, berikut ini adalah alamat yang digunakan kembali dalam beberapa transaksi:

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/fr/056.webp)

Sumber : [Mempool.space](https://mempool.space/address/bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0)

### Kemiripan skrip dan jejak dompet

Selain penggunaan ulang alamat, ada banyak heuristik lain yang memungkinkan Anda menautkan tindakan ke portofolio atau klaster alamat yang sama.

Pertama, seorang analis dapat mencari kesamaan dalam penggunaan skrip. Sebagai contoh, skrip minoritas tertentu seperti multisig mungkin lebih mudah dikenali daripada skrip SegWit V0. Semakin besar kelompok tempat kita bersembunyi, semakin sulit untuk menemukan kita. Ini adalah salah satu alasan mengapa, pada protokol Coinjoin yang baik, semua peserta menggunakan jenis skrip yang sama persis.

Secara lebih umum, seorang analis juga dapat berfokus pada sidik jari karakteristik portofolio. Ini adalah proses spesifik penggunaan yang dapat diidentifikasi dengan tujuan untuk mengeksploitasinya sebagai heuristik penelusuran. Dengan kata lain, jika kita mengamati akumulasi karakteristik internal yang sama pada transaksi yang dikaitkan dengan entitas yang ditelusuri, kita dapat mencoba mengidentifikasi karakteristik yang sama pada transaksi lainnya.

Sebagai contoh, kita akan dapat mengidentifikasi bahwa pengguna yang dilacak secara sistematis mengirimkan perubahannya ke alamat P2TR (`bc1p...`). Jika proses ini diulang, kita bisa menggunakannya sebagai heuristik untuk analisis selanjutnya. Kita juga dapat menggunakan sidik jari lain, seperti urutan UTXO, tempat perubahan pada output, sinyal RBF (Replace-by-Fee), atau nomor versi, bidang `nSequence` dan bidang `nLockTime`.

![BTC204](assets/fr/057.webp)

Seperti yang ditunjukkan oleh [@LaurentMT] (https://twitter.com/LaurentMT) dalam [Space Kek #19] (https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji) (podcast berbahasa Prancis), kegunaan sidik jari portofolio dalam analisis rantai meningkat secara signifikan dari waktu ke waktu. Memang, semakin banyaknya jenis skrip dan penyebaran fitur-fitur baru yang semakin progresif oleh perangkat lunak portofolio menonjolkan perbedaannya. Dalam beberapa kasus, bahkan dimungkinkan untuk mengidentifikasi perangkat lunak yang tepat yang digunakan oleh entitas yang dilacak. Oleh karena itu, penting untuk memahami bahwa studi tentang jejak portofolio sangat relevan untuk transaksi-transaksi terkini, daripada transaksi yang dimulai pada awal tahun 2010.

Singkatnya, sebuah footprint dapat berupa praktik tertentu, yang dilakukan secara otomatis oleh wallet atau secara manual oleh pengguna, yang dapat kita temukan pada transaksi lain untuk membantu kita dalam analisis.

### Heuristik Kepemilikan Masukan Umum (CIOH)

Common Input Ownership Heuristic (CIOH) adalah heuristik yang menyatakan bahwa ketika sebuah transaksi memiliki beberapa input, semuanya kemungkinan besar berasal dari satu entitas. Oleh karena itu, kepemilikannya bersifat umum.

![BTC204](assets/fr/058.webp)

Untuk menerapkan CIOH, pertama-tama kita mengamati sebuah transaksi dengan beberapa input. Ini bisa berupa 2 input, atau 30 input. Setelah karakteristik ini teridentifikasi, kita memeriksa apakah transaksi tersebut cocok dengan model transaksi yang sudah diketahui. Sebagai contoh, jika ada 5 input dengan jumlah yang kurang lebih sama dan 5 output dengan jumlah yang sama persis, kita akan mengetahui bahwa ini adalah struktur coinjoin. Kita tidak akan bisa menerapkan CIOH.

![BTC204](assets/fr/059.webp)

Di sisi lain, jika transaksi tidak sesuai dengan model transaksi kolaboratif yang diketahui, maka kita dapat menginterpretasikan bahwa semua input kemungkinan besar berasal dari entitas yang sama. Hal ini bisa sangat berguna untuk memperluas klaster yang sudah diketahui atau melanjutkan penelusuran.

![BTC204](assets/fr/060.webp)

CIOH ditemukan oleh Satoshi Nakamoto. Dia membicarakannya di bagian 10 Buku Putih:

"_[...] penautan tidak dapat dihindari dengan transaksi multi entri, yang tentu saja mengungkapkan bahwa entri-entri tersebut dipegang oleh pemilik yang sama. Risikonya adalah jika pemilik sebuah kunci terungkap, tautan tersebut dapat mengungkapkan transaksi lain yang dimiliki oleh pemilik yang sama."

![BTC204](assets/fr/061.webp)

Sangat menarik untuk dicatat bahwa Satoshi Nakamoto, bahkan sebelum peluncuran resmi Bitcoin, telah mengidentifikasi dua kerentanan privasi utama bagi para pengguna, yaitu CIOH dan penggunaan ulang alamat. Pandangan ke depan tersebut cukup luar biasa, karena kedua heuristik ini tetap menjadi yang paling berguna dalam analisis blockchain hingga saat ini.

Sebagai contoh, berikut ini adalah sebuah transaksi yang mungkin bisa kita terapkan CIOH:

```plaintext
20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712
```

![BTC204](assets/fr/062.webp)

Source : [Mempool.space](https://mempool.space/tx/20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712)

### Data off-chain

Tentu saja, analisis rantai tidak terbatas secara eksklusif pada data onchain. Data apa pun dari analisis sebelumnya atau yang tersedia di Internet juga dapat digunakan untuk menyempurnakan analisis.

Sebagai contoh, jika kita mengamati bahwa transaksi yang dilacak disiarkan secara sistematis dari node Bitcoin yang sama, dan kita berhasil mengidentifikasi alamat IP-nya, kita mungkin dapat mengidentifikasi transaksi lain dari entitas yang sama, serta menentukan bagian dari identitas penerbit. Walaupun praktik ini tidak mudah untuk dilakukan, karena membutuhkan pengoperasian banyak node, hal ini dapat dilakukan oleh beberapa perusahaan yang berspesialisasi dalam analisis blockchain.

Analis juga memiliki pilihan untuk mengandalkan analisis yang sebelumnya dibuat secara open-source, atau pada analisis sebelumnya. Mungkin kita akan dapat menemukan output yang mengarah ke sekelompok alamat yang telah kita identifikasi. Terkadang, kita juga dapat mengandalkan output yang mengarah ke platform bursa, karena alamat perusahaan-perusahaan ini secara umum sudah diketahui.

Dengan cara yang sama, Anda dapat melakukan analisis dengan eliminasi. Sebagai contoh, jika saat menganalisis transaksi dengan dua keluaran, salah satunya berhubungan dengan klaster alamat yang sudah diketahui, tetapi berbeda dari entitas yang kita telusuri, maka kita bisa menginterpretasikan bahwa keluaran lainnya mungkin mewakili pertukaran.

Analisis saluran juga mencakup komponen OSINT (*Open Source Intelligence*) yang sedikit lebih umum, yang melibatkan pencarian di internet. Karena alasan inilah kami menyarankan agar Anda tidak mempublikasikan alamat secara langsung di jejaring sosial atau situs web, baik yang pseudonim maupun tidak.

![BTC204](assets/fr/063.webp)

### Model temporal

Kita tidak terlalu memikirkannya, tetapi perilaku manusia tertentu dapat dikenali di blockchain. Mungkin yang paling berguna dalam analisis adalah pola tidur Anda! Ya, ketika Anda tidur, Anda tidak menyiarkan transaksi Bitcoin. Namun, Anda biasanya tidur pada waktu yang kurang lebih sama. Inilah sebabnya mengapa analisis temporal merupakan praktik umum dalam analisis blockchain. Sederhananya, ini adalah sensus waktu di mana transaksi entitas tertentu disiarkan ke jaringan Bitcoin. Dengan menganalisis pola-pola temporal ini, kita dapat menyimpulkan banyak informasi.

Pertama-tama, analisis temporal terkadang dapat mengidentifikasi sifat entitas yang dilacak. Jika kita mengamati bahwa transaksi-transaksi tersebut disiarkan secara konsisten selama 24 jam, maka hal ini menunjukkan adanya tingkat aktivitas ekonomi yang tinggi. Entitas di balik transaksi ini kemungkinan besar adalah sebuah perusahaan, yang mungkin bersifat internasional dan mungkin memiliki prosedur internal yang terotomatisasi.

Sebagai contoh, [saya mengenali pola ini beberapa bulan yang lalu] (https://twitter.com/Loic_Pandul/status/1701127409712452072) ketika menganalisis [transaksi yang secara keliru mengalokasikan biaya 19 bitcoin] (https://mempool.space/tx/d5392d474b4c436e1c9d1f4ff4be5f5f9bb0eb2e26b61d2781751474b7e870fd). Analisis sementara yang sederhana memungkinkan saya untuk membuat hipotesis bahwa kami berurusan dengan layanan otomatis, dan oleh karena itu mungkin dengan entitas besar seperti platform bursa.

Memang, beberapa hari kemudian, ditemukan bahwa dana tersebut adalah milik PayPal, melalui platform pertukaran Paxos.

Sebaliknya, jika kita dapat melihat bahwa pola temporal agak tersebar di 16 jam tertentu, maka kita dapat memperkirakan bahwa kita berurusan dengan pengguna perorangan, atau mungkin perusahaan lokal tergantung pada volume yang dipertukarkan.

Di luar sifat entitas yang diamati, pola temporal juga dapat memberi tahu kita kira-kira di mana pengguna berada, berkat zona waktu. Dengan cara ini, kita bisa mencocokkan transaksi lain, dan menggunakan cap waktu mereka sebagai heuristik tambahan yang bisa ditambahkan ke dalam analisis kita.

Sebagai contoh, pada alamat multi-penggunaan yang saya sebutkan sebelumnya, kita dapat melihat bahwa transaksi, baik yang masuk maupun yang keluar, terkonsentrasi pada interval 13 jam.

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/fr/064.webp)

Sumber : OXT.me

Kisaran ini mungkin sesuai dengan Eropa, Afrika atau Timur Tengah. Oleh karena itu, kami dapat mengasumsikan bahwa pengguna di balik transaksi ini tinggal di wilayah-wilayah tersebut.

Dengan cara yang berbeda, analisis waktu jenis ini juga menghasilkan hipotesis bahwa Satoshi Nakamoto tidak beroperasi dari Jepang, tetapi dari Amerika Serikat: [*Zona Waktu Satoshi Nakamoto*] (https://medium.com/@insearchofsatoshi/the-time-zones-of-satoshi-nakamoto-aa40f035178f)

## Mempraktikkannya dengan penjelajah blok

<chapterId>6493cf2f-225c-405f-9375-c4304f1087ed</chapterId>

Dalam bab terakhir ini, kita akan mempraktikkan konsep-konsep yang telah kita pelajari sejauh ini. Saya akan menunjukkan kepada Anda contoh-contoh transaksi Bitcoin yang nyata, dan Anda harus mengekstrak informasi yang saya minta.

Idealnya, untuk melakukan latihan ini, penggunaan alat analisis chain profesional akan lebih baik. Namun, sejak penangkapan pencipta Samourai Wallet, satu-satunya alat analisis gratis OXT.me tidak lagi tersedia. Oleh karena itu, kami akan memilih penjelajah blok klasik untuk latihan ini. Saya merekomendasikan untuk menggunakan [Mempool.space](https://mempool.space/) karena memiliki banyak fitur dan berbagai alat analisis rantai, tetapi Anda juga dapat memilih penjelajah lain seperti [Bitcoin Explorer](https://bitcoinexplorer.org/).

Sebagai permulaan, saya akan memperkenalkan Anda pada latihan-latihannya. Gunakan penjelajah blok Anda untuk menyelesaikannya, dan tuliskan jawaban Anda pada selembar kertas. Kemudian, di akhir bab ini, saya akan memberikan jawabannya agar Anda dapat memeriksa dan mengoreksi hasil Anda.

*Transaksi yang dipilih untuk latihan ini telah dipilih murni karena karakteristiknya secara acak. Bab ini dimaksudkan untuk tujuan edukasi dan informatif saja. Saya ingin menjelaskan bahwa saya tidak mendukung atau mendorong penggunaan alat ini untuk tujuan jahat. Tujuannya adalah untuk mengajarkan Anda cara melindungi diri Anda dari analisis string, bukan untuk melakukan analisis untuk mengekspos informasi pribadi orang lain*

### Latihan 1

Pengidentifikasi transaksi yang akan dianalisis:

```plaintext
3769d3b124e47ef4ffb5b52d11df64b0a3f0b82bb10fd6b98c0fd5111789bef7
```

Apa nama model transaksi ini, dan interpretasi yang masuk akal apa yang dapat ditarik dengan hanya memeriksa modelnya, yaitu struktur transaksinya?

### Latihan 2

Pengidentifikasi transaksi yang akan dianalisis:

```plaintext
baa228f6859ca63e6b8eea24ffad7e871713749d693ebd85343859173b8d5c20
```

Apa nama model transaksi ini, dan interpretasi yang masuk akal apa yang dapat ditarik dengan hanya memeriksa modelnya, yaitu struktur transaksinya?

### Latihan 3

Pengidentifikasi transaksi yang akan dianalisis:

```plaintext
3a9eb9ccc3517cc25d1860924c66109262a4b68f4ed2d847f079b084da0cd32b
```

Bagaimana model transaksi ini?

Setelah mengidentifikasi modelnya, dengan menggunakan heuristik internal transaksi, output apa yang kemungkinan besar akan diwakili oleh bursa?

### Latihan 4

Pengidentifikasi transaksi yang akan dianalisis:

```plaintext
35f0b31c05503ebfdf7311df47f68a048e992e5cf4c97ec34aa2833cc0122a12
```

Bagaimana model transaksi ini?

Setelah mengidentifikasi modelnya, dengan menggunakan heuristik internal transaksi, output apa yang kemungkinan besar akan diwakili oleh bursa?

### Latihan 5

Bayangkan Loïc telah memposting salah satu alamat penerima Bitcoin-nya di jejaring sosial Twitter :

![BTC204](assets/fr/065.webp)

```plaintext
bc1qja0hycrv7g9ww00jcqanhfpqmzx7luqalum3vu
```

Berdasarkan informasi ini dan dengan menggunakan **hanya heuristik penggunaan ulang alamat**, transaksi Bitcoin mana yang dapat dihubungkan dengan identitas Loïc?

*Jelas, saya bukan pemilik sebenarnya dari alamat resepsi ini dan saya tidak mempostingnya di jejaring sosial. Ini adalah alamat yang saya ambil secara acak dari blockchain*

### Latihan 6

Setelah latihan 5, berkat heuristik penggunaan ulang alamat, Anda dapat mengidentifikasi beberapa transaksi Bitcoin yang melibatkan Loïc. Biasanya, di antara transaksi yang teridentifikasi, Anda akan menemukan transaksi ini:

```plaintext
2d9575553c99578268ffba49a1b2adc3b85a29926728bd0280703a04d051eace
```

Transaksi ini merupakan transaksi pertama yang mengirimkan dana ke alamat Loïc. Menurut Anda, dari mana asal bitcoin yang diterima oleh Loïc melalui transaksi ini?

### Latihan 7

Setelah mengikuti latihan 5, berkat heuristik penggunaan ulang alamat, Anda sudah dapat mengidentifikasi beberapa transaksi Bitcoin yang melibatkan Loïc. Sekarang, Anda ingin mencari tahu dari mana Loïc berasal. Berdasarkan transaksi yang ditemukan, lakukan analisis waktu untuk menemukan zona waktu yang paling mungkin digunakan oleh Loïc. Dari zona waktu ini, tentukan lokasi di mana Loïc tampaknya tinggal (negara, negara bagian/wilayah, kota...).

![BTC204](assets/fr/066.webp)

### Latihan 8

Berikut ini adalah transaksi Bitcoin untuk dipelajari:

```plaintext
bb346dae645d09d32ed6eca1391d2ee97c57e11b4c31ae4325bcffdec40afd4f
```

Melihat transaksi ini saja, informasi apa yang dapat kita tafsirkan?

### Solusi latihan

***Latihan 1:***

Model untuk transaksi ini adalah model pembayaran sederhana. Jika kita hanya mempelajari strukturnya, kita dapat menginterpretasikan bahwa satu output mewakili pertukaran dan output lainnya mewakili pembayaran yang sebenarnya. Oleh karena itu, kita tahu bahwa pengguna yang diamati mungkin tidak lagi memiliki salah satu dari dua UTXO dalam bentuk output (pembayaran), tetapi masih memiliki UTXO lainnya (pertukaran).

***Latihan 2:***

Model untuk transaksi ini adalah model pembelanjaan berkelompok. Model ini mungkin menunjukkan aktivitas ekonomi berskala besar, seperti platform pertukaran. Kita dapat menyimpulkan bahwa input UTXO berasal dari perusahaan dengan tingkat aktivitas ekonomi yang tinggi, dan output UTXO akan tersebar. Beberapa akan menjadi milik pelanggan perusahaan yang telah menarik bitcoin mereka ke dompet penyimpanan mandiri. Sebagian lainnya mungkin akan diberikan kepada perusahaan mitra. Akhirnya, tidak diragukan lagi akan ada beberapa pertukaran yang akan kembali ke perusahaan penerbit.

***Latihan 3:***

Model untuk transaksi ini adalah pembayaran sederhana. Oleh karena itu, kami dapat menerapkan heuristik internal pada transaksi tersebut untuk mencoba mengidentifikasi pertukaran.

Saya secara pribadi telah mengidentifikasi setidaknya dua heuristik internal yang mendukung hipotesis yang sama:


- Penggunaan kembali jenis skrip yang sama ;
- Output terbesar.

Heuristik yang paling jelas adalah menggunakan kembali jenis skrip yang sama. Memang, keluaran `0` adalah `P2SH`, yang dapat dikenali dari alamat penerimaannya yang dimulai dengan `3`:

```plaintext
3Lcdauq6eqCWwQ3UzgNb4cu9bs88sz3mKD
```

Sedangkan output `1` adalah `P2WPKH`, yang dapat diidentifikasi dengan alamatnya yang dimulai dengan `bc1q`:

```plaintext
bc1qya6sw6sta0mfr698n9jpd3j3nrkltdtwvelywa
```

UTXO yang digunakan sebagai input untuk transaksi ini juga menggunakan skrip `P2WPKH`:

```plaintext
bc1qyfuytw8pcvg5vx37kkgwjspg73rpt56l5mx89k
```

Dengan demikian, kita dapat mengasumsikan bahwa output `0` berhubungan dengan pembayaran dan output `1` adalah pertukaran transaksi, yang berarti bahwa pengguna input selalu memiliki output `1`.

Untuk mendukung atau menolak hipotesis ini, kita dapat mencari heuristik lain yang dapat mengonfirmasi pemikiran kita, atau mengurangi probabilitas bahwa hipotesis kita benar.

Saya telah mengidentifikasi setidaknya satu heuristik lainnya. Ini adalah heuristik keluaran terbesar. Keluaran `0` mengukur `123.689 sat`, sedangkan keluaran `1` mengukur `505.839 sat`. Oleh karena itu, terdapat perbedaan yang signifikan antara kedua output ini. Heuristik output terbesar menunjukkan bahwa output terbesar kemungkinan besar adalah devisa. Heuristik ini semakin memperkuat hipotesis awal kami.

Oleh karena itu, tampaknya pengguna yang memasok UTXO sebagai input masih memegang output `1`, yang tampaknya mewujudkan pertukaran transaksi.

***Latihan 4:***

Model untuk transaksi ini adalah pembayaran sederhana. Oleh karena itu, kami dapat menerapkan heuristik internal pada transaksi tersebut untuk mencoba mengidentifikasi pertukaran.

Saya secara pribadi telah mengidentifikasi setidaknya dua heuristik internal yang mendukung hipotesis yang sama:


- Penggunaan kembali jenis skrip yang sama ;
- Keluaran pos bulat.

Heuristik yang paling jelas adalah menggunakan kembali jenis skrip yang sama. Memang, keluaran `0` adalah `P2SH`, yang dapat dikenali dari alamat penerimaannya yang dimulai dengan `3`:

```plaintext
3FSH5Mnq6S5FyQoKR9Yjakk3X4KCGxeaD4
```

Sedangkan output `1` adalah `P2WPKH`, yang dapat diidentifikasi dengan alamatnya yang dimulai dengan `bc1q`:

```plaintext
bc1qvdywdcfsyavt4v8uxmmrdt6meu4vgeg439n7sg
```

UTXO yang digunakan sebagai input untuk transaksi ini juga menggunakan skrip `P2WPKH`:

```plaintext
bc1qku3f2y294h3ks5eusv63dslcua2xnlzxx0k6kp
```

Dengan demikian, kita dapat mengasumsikan bahwa output `0` berhubungan dengan pembayaran dan output `1` adalah pertukaran transaksi, yang berarti bahwa pengguna input selalu memiliki output `1`.

Untuk mendukung atau menolak hipotesis ini, kita dapat mencari heuristik lain yang dapat mengonfirmasi pemikiran kita, atau mengurangi probabilitas bahwa hipotesis kita benar.

Saya telah mengidentifikasi setidaknya satu heuristik lainnya. Ini adalah keluaran jumlah bulat. Output `0` mengukur `70.000 satoshi`, sedangkan output `1` mengukur `22.962 satoshi`. Oleh karena itu, kita memiliki output yang bulat sempurna dalam unit akun BTC. Heuristik output bulat menunjukkan bahwa UTXO dengan jumlah bulat kemungkinan besar adalah pembayaran, dan dengan eliminasi, yang lainnya mewakili pertukaran. Heuristik ini semakin memperkuat hipotesis awal kami.

Namun, dalam contoh ini, heuristik lain dapat menantang hipotesis awal kita. Memang, output `0` lebih besar dari output `1`. Berdasarkan heuristik bahwa output terbesar pada umumnya adalah valuta asing, kita dapat menyimpulkan bahwa output `0` adalah valuta asing. Namun, hipotesis tandingan ini tampaknya tidak masuk akal, karena dua heuristik lainnya terlihat jauh lebih meyakinkan dibandingkan dengan heuristik output terbesar. Oleh karena itu, tampaknya masuk akal untuk mempertahankan hipotesis awal kita meskipun terdapat kontradiksi yang jelas.

Oleh karena itu, tampaknya pengguna yang memasok UTXO sebagai input masih memegang output `1`, yang tampaknya mewujudkan pertukaran transaksi.

***Latihan 5:***

Kita dapat melihat bahwa 8 transaksi dapat dikaitkan dengan identitas Loïc. Dari jumlah tersebut, 4 di antaranya melibatkan penerimaan bitcoin:

```plaintext
2d9575553c99578268ffba49a1b2adc3b85a29926728bd0280703a04d051eace
8b70bd322e6118b8a002dbdb731d16b59c4a729c2379af376ae230cf8cdde0dd
d5864ea93e7a8db9d3fb113651d2131567e284e868021e114a67c3f5fb616ac4
bc4dcf2200c88ac1f976b8c9018ce70f9007e949435841fc5681fd33308dd762
```

Empat lainnya menyangkut pengiriman bitcoin:

```plaintext
8b52fe3c2cf8bef60828399d1c776c0e9e99e7aaeeff721fff70f4b68145d540
c12499e9a865b9e920012e39b4b9867ea821e44c047d022ebb5c9113f2910ed6
a6dbebebca119af3d05c0196b76f80fdbf78f20368ebef1b7fd3476d0814517d
3aeb7ce02c35eaecccc0a97a771d92c3e65e86bedff42a8185edd12ce89d89cc
```

***Latihan 6:***

Jika kita melihat model transaksi ini, jelas bahwa transaksi ini merupakan pengeluaran yang digabungkan. Memang, transaksi ini memiliki satu input dan 51 output, yang mengindikasikan tingkat aktivitas ekonomi yang tinggi. Oleh karena itu, kita dapat berhipotesis bahwa Loïc telah menarik bitcoin dari platform pertukaran.

Beberapa faktor memperkuat hipotesis ini. Pertama, jenis skrip yang digunakan untuk mengamankan input UTXO adalah skrip multisig P2SH 2/3, yang mengindikasikan tingkat keamanan tingkat lanjut yang khas pada platform bursa:

```plaintext
OP_PUSHNUM_2
OP_PUSHBYTES_33 03eae02975918af86577e1d8a257773118fd6ceaf43f1a543a4a04a410e9af4a59
OP_PUSHBYTES_33 03ba37b6c04aaf7099edc389e22eeb5eae643ce0ab89ac5afa4fb934f575f24b4e
OP_PUSHBYTES_33 03d95ef2dc0749859929f3ed4aa5668c7a95baa47133d3abec25896411321d2d2d
OP_PUSHNUM_3
OP_CHECKMULTISIG
```

Terlebih lagi, alamat yang diteliti `3PUv9tQMSDCEPSMsYSopA5wDW86pwRFbNF` digunakan kembali di lebih dari 220.000 transaksi yang berbeda, yang sering kali merupakan ciri khas platform bursa, yang pada umumnya tidak peduli dengan kerahasiaannya.

Heuristik temporal yang diterapkan pada alamat ini juga menunjukkan siaran reguler transaksi hampir setiap hari selama periode 3 bulan, dengan waktu yang diperpanjang lebih dari 24 jam, yang menunjukkan aktivitas berkelanjutan dari sebuah platform bursa.

Terakhir, volume yang ditangani oleh entitas ini sangat besar. Alamat tersebut menerima dan mengirim 44 BTC dalam 222.262 transaksi antara Desember 2022 dan Maret 2023. Volume yang besar ini semakin mengonfirmasi kemungkinan sifat aktivitas platform bursa.

***Latihan 7:***

Dengan menganalisis waktu konfirmasi transaksi, waktu UTC berikut ini dapat diidentifikasi:

```plaintext
05:43
20:51
18:12
17:16
04:28
23:38
07:45
21:55
```

Analisis terhadap jadwal-jadwal ini menunjukkan bahwa UTC-7 dan UTC-8 konsisten dengan rentang aktivitas manusia saat ini (antara pukul 08:00 dan 23:00) untuk sebagian besar jadwal:

```plaintext
05:43 UTC > 22:43 UTC-7
20:51 UTC > 13:51 UTC-7
18:12 UTC > 11:12 UTC-7
17:16 UTC > 10:16 UTC-7
04:28 UTC > 21:28 UTC-7
23:38 UTC > 16:38 UTC-7
07:45 UTC > 00:45 UTC-7
21:55 UTC > 14:55 UTC-7
05:43 UTC > 21:43 UTC-8
20:51 UTC > 12:51 UTC-8
18:12 UTC > 10:12 UTC-8
17:16 UTC > 09:16 UTC-8
04:28 UTC > 20:28 UTC-8
23:38 UTC > 15:38 UTC-8
07:45 UTC > 23:45 UTC-8
21:55 UTC > 13:55 UTC-8
```

![BTC204](assets/fr/066.webp)

Zona waktu UTC-7 sangat relevan pada musim panas, karena mencakup negara bagian dan wilayah seperti :


- California (dengan kota-kota seperti Los Angeles, San Francisco, dan San Diego);
- Nevada (dengan Las Vegas) ;
- Oregon (dengan Portland) ;
- Washington (dengan Seattle) ;
- Wilayah Kanada di British Columbia (dengan kota-kota seperti Vancouver dan Victoria).

Informasi ini menunjukkan bahwa Loïc kemungkinan besar tinggal di pantai barat Amerika Serikat atau Kanada.

***Latihan 8:***

Analisis dari transaksi ini menunjukkan 5 input dan satu output, yang menunjukkan adanya konsolidasi. Dengan menerapkan heuristik CIOH, kita dapat mengasumsikan bahwa semua input UTXO dimiliki oleh satu entitas, dan bahwa output UTXO juga dimiliki oleh entitas ini. Tampaknya pengguna memilih untuk mengelompokkan beberapa UTXO yang dimilikinya, untuk membentuk satu UTXO dalam bentuk output, dengan tujuan untuk mengkonsolidasikan bagian-bagiannya. Langkah ini mungkin dimotivasi oleh keinginan untuk mengambil keuntungan dari biaya transaksi yang rendah pada saat itu, untuk mengurangi biaya di masa depan.

___

*Untuk menulis bagian 3 tentang analisis rantai ini, saya menggunakan sumber-sumber berikut:*


- Rangkaian empat artikel berjudul: [Memahami Privasi Bitcoin dengan OXT] (https://medium.com/oxt-research/understanding-bitcoin-privacy-with-oxt-part-1-4-8177a40a5923), diproduksi oleh Samourai Wallet pada tahun 2021 ;*
- Berbagai laporan dari [OXT Research] (https://medium.com/oxt-research), serta alat analisis blockchain gratis mereka (tidak lagi tersedia untuk saat ini setelah penangkapan para pendiri Samourai Wallet) ;*
- Secara lebih luas, pengetahuan saya berasal dari berbagai tweet dan konten dari [@LaurentMT] (https://twitter.com/LaurentMT) dan [@ErgoBTC] (https://twitter.com/ErgoBTC) ;*
- Space Kek #19] (https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji) di mana saya berpartisipasi bersama dengan [@louneskmt] (https://twitter.com/louneskmt), [@TheoPantamis] (https://twitter.com/TheoPantamis), [@Sosthene___] (https://twitter.com/Sosthene___) dan [@LaurentMT] (https://twitter.com/LaurentMT).*

*Saya ingin berterima kasih kepada para penulis, pengembang dan produsernya. Terima kasih juga kepada para korektor yang dengan cermat mengoreksi artikel yang menjadi dasar bagian 3 ini, dan memberi saya saran ahli mereka :*


- [Gilles Cadignan](https://twitter.com/gillesCadignan) ;*
- [Ludovic Lars](https://viresinnumeris.fr/)

# Menguasai praktik terbaik untuk melindungi privasi Anda

<partId>9bd04b63-f1af-4e50-9061-6bc90009df68</partId>

## Penggunaan kembali alamat

<chapterId>f3e97645-3df3-41bc-a4ed-d2c740113d96</chapterId>


Setelah mempelajari teknik-teknik yang dapat membobol kerahasiaan Anda di Bitcoin, di bagian ketiga ini, kita akan membahas praktik-praktik terbaik yang dapat Anda terapkan untuk melindungi diri Anda sendiri. Tujuan dari bagian ini bukanlah untuk mengeksplorasi metode-metode untuk meningkatkan kerahasiaan, sebuah topik yang akan dibahas nanti, tetapi lebih kepada memahami cara berinteraksi dengan Bitcoin secara benar untuk mempertahankan kerahasiaan yang secara alamiah ditawarkannya, tanpa harus menggunakan teknik-teknik tambahan.

Tentunya, untuk memulai bagian ketiga ini, kita akan berbicara tentang penggunaan ulang alamat. Fenomena ini merupakan ancaman utama bagi kerahasiaan pengguna. Bab ini tentunya merupakan yang paling penting dari keseluruhan kursus ini.

### Apa yang dimaksud dengan alamat penerima?

Alamat penerima Bitcoin adalah sebuah string atau pengenal yang digunakan untuk menerima bitcoin di dompet.

Secara teknis, alamat penerima Bitcoin tidak "menerima" bitcoin dalam arti harfiah, tetapi berfungsi untuk menentukan kondisi di mana bitcoin dapat dibelanjakan. Secara konkret, ketika sebuah pembayaran dikirimkan kepada Anda, transaksi pengirim akan membuat UTXO baru untuk Anda sebagai output dari UTXO yang telah digunakan sebagai input. Pada output ini, ia membubuhkan skrip yang mendefinisikan bagaimana UTXO ini dapat digunakan di kemudian hari. Skrip ini dikenal sebagai "*SkripPubKey*" atau "*Skrip Penguncian*". Alamat penerima Anda, atau lebih tepatnya muatannya, diintegrasikan ke dalam skrip ini. Dalam istilah awam, skrip ini pada dasarnya menyatakan:

> "*Untuk membelanjakan UTXO baru ini, Anda harus memberikan tanda tangan digital menggunakan kunci privat yang terkait dengan alamat penerima ini.*"
![BTC204](assets/fr/067.webp)

Alamat Bitcoin memiliki beberapa jenis, tergantung pada model scripting yang digunakan. Model pertama, yang dikenal sebagai "Legacy*", termasuk alamat `P2PKH` (*Pay-to-PubKey-Hash*) dan `P2SH` (*Pay-to-Script-Hash*). Alamat P2PKH selalu dimulai dengan `1`, dan P2SH dengan `3`. Walaupun masih aman, format ini sekarang sudah tidak digunakan lagi, karena memerlukan biaya transaksi yang lebih tinggi dan menawarkan kerahasiaan yang lebih rendah dibandingkan dengan standar yang baru.

Alamat SegWit V0 (`P2WPKH` dan `P2WSH`) dan alamat Taproot / SegWit V1 (`P2TR`) mewakili format modern. Alamat SegWit dimulai dengan `bc1q` dan alamat Taproot, yang diperkenalkan pada tahun 2021, dimulai dengan `bc1p`.

Sebagai contoh, berikut ini adalah alamat penerimaan Taproot:

```text
bc1ps5gd2ys8kllz9alpmcwxqegn7kl3elrpnnlegwkm3xpq2h8da07spxwtf5
```

Bagaimana ScriptPubKey dibuat akan bergantung pada standar yang Anda gunakan:

| ScriptPubKey | Templat skrip

| ---------------- | ----------------------------------------------------------- |

| P2PKH | OP_DUP OP_HASH160 `<pubKeyHash>` OP_EQUALVERIFY OP_CHECKSIG |

| P2SH | OP_HASH160 `<scriptHash>` OP_EQUAL |

| P2WPKH | 0 `<pubKeyHash>` | | |

| P2WSH | 0 `<witnessScriptHash>` | | |

| P2SH - P2WPKH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL |

| P2SH - P2WSH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL |

| P2TR | 1 `<pubKey>` | | |

Konstruksi alamat penerimaan juga bergantung pada model skrip yang dipilih:


- Untuk alamat `P2PKH` dan `P2WPKH`, payload, yaitu inti dari alamat tersebut, merepresentasikan hash dari kunci publik;
- Untuk alamat `P2SH` dan `P2WSH`, payload mewakili hash dari file ;
- Sedangkan untuk alamat `P2TR`, muatannya adalah kunci publik yang diubah. Output P2TR menggabungkan aspek _Bayar-ke-PubKey_ dan _Bayar-ke-Script_. Tweak public key merupakan hasil dari penambahan public key pembelanjaan klasik dengan sebuah "tweak", yang berasal dari akar Merkle dari sekumpulan skrip yang juga dapat digunakan untuk membelanjakan bitcoin.

![BTC204](assets/fr/068.webp)

Alamat yang ditampilkan pada perangkat lunak portofolio Anda juga menyertakan HRP (*Human-Readable Part*), biasanya `bc` untuk alamat pasca-SegWit, pemisah `1`, dan nomor versi `q` untuk SegWit V0 dan `p` untuk Taproot / SegWit V1. Checksum juga ditambahkan untuk menjamin integritas dan keabsahan alamat selama transmisi.

Terakhir, alamat-alamat tersebut dimasukkan ke dalam format standar:


- Base58periksa untuk alamat lama Legacy;
- Bech32 untuk alamat SegWit;
- Bech32m untuk alamat Taproot.

Berikut ini adalah matriks penjumlahan untuk format bech32 dan bech32m (SegWit dan Taproot) dari basis 10:

| + | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |



| 0 | q | p | z | r | y | 9 | x | 8 |

| 8 | g | f | 2 | t | v | d | w | 0 |

| 16 | s | 3 | j | n | 5 | 4 | k | h |

| 24 | c | e | 6 | m | u | a | 7 | l |

### Apa yang dimaksud dengan penggunaan ulang alamat?

Penggunaan ulang alamat adalah penggunaan alamat penerima yang sama untuk memblokir beberapa UTXO yang berbeda.

Seperti yang telah kita lihat pada bagian sebelumnya, setiap UTXO memiliki ScriptPubKey-nya sendiri, yang menguncinya dan harus dipenuhi agar UTXO dapat digunakan sebagai input dalam transaksi baru. Di dalam ScriptPubKey inilah alamat payload diintegrasikan.

Ketika beberapa ScriptPubKey yang berbeda berisi alamat penerima yang sama, ini disebut dengan penggunaan ulang alamat. Dalam praktiknya, ini berarti seorang pengguna telah berulang kali memberikan alamat yang sama kepada pengirim untuk menerima bitcoin melalui beberapa pembayaran. Dan praktik inilah yang menjadi bencana bagi privasi Anda.

### Mengapa penggunaan ulang alamat menjadi masalah?

Karena blockchain bersifat publik, mudah untuk melihat alamat mana yang mengunci UTXO dan berapa banyak bitcoin. Jika alamat yang sama digunakan untuk beberapa transaksi, maka dapat disimpulkan bahwa semua bitcoin yang terkait dengan alamat tersebut adalah milik orang yang sama. Praktik ini membahayakan privasi pengguna dengan memungkinkan hubungan deterministik yang dibuat antara transaksi yang berbeda dan bitcoin yang akan dilacak di blockchain. Satoshi Nakamoto sendiri telah menyoroti masalah ini dalam Buku Putih Bitcoin:

> *Sebagai firewall tambahan, sepasang kunci baru dapat digunakan untuk setiap transaksi agar tidak terhubung dengan pemilik yang sama*
![BTC204](assets/fr/055.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

Maksud Satoshi dalam kalimat ini adalah untuk membuat sebuah firewall tambahan jika terjadi hubungan antara identitas pengguna dengan pasangan kunci pada Bitcoin, untuk mencegah seluruh aktivitasnya dihubungkan secara publik dengan identitasnya. Saat ini, dengan menjamurnya perusahaan analisis blockchain dan peraturan KYC, penggunaan alamat unik tidak lagi menjadi "firewall tambahan", tetapi menjadi praktik yang sangat diperlukan bagi siapa saja yang ingin menjaga privasi seminimal mungkin.

Ketika Anda menggunakan kembali sebuah alamat, Anda membuat hubungan yang hampir tidak dapat disangkal antara semua transaksi yang terkait dengan alamat tersebut. Meskipun hal ini tidak secara langsung membahayakan dana Anda, karena kriptografi kurva eliptik menjamin keamanan kunci pribadi Anda, namun hal ini memudahkan untuk memantau aktivitas Anda. Memang, siapa pun yang memiliki simpul dapat mengamati transaksi dan saldo dari alamat tersebut, yang benar-benar membahayakan anonimitas Anda.

![BTC204](assets/fr/054.webp)

Untuk mengilustrasikan hal ini, mari kita ambil contoh Bob, seorang pengguna yang secara teratur membeli bitcoin dalam jumlah kecil di DCA dan selalu mengirimkannya ke alamat yang sama. Setelah dua tahun, alamat ini berisi sejumlah besar bitcoin. Jika Bob menggunakan alamat ini untuk melakukan pembayaran kepada pedagang lokal, pedagang tersebut akan dapat melihat semua dana yang terkait dan menyimpulkan kekayaan Bob. Hal ini dapat menyebabkan risiko keamanan pribadi, seperti percobaan pencurian atau pemerasan. Jika Bob menggunakan alamat kosong untuk menerima setiap pembelian berkala, dia akan mengungkapkan informasi yang jauh lebih sedikit kepada pedagangnya.

Dalam analisis string, ada 2 jenis penggunaan ulang alamat:


- Penggunaan kembali eksternal;
- Penggunaan ulang internal dalam suatu transaksi.

Yang pertama adalah ketika sebuah alamat digunakan kembali dalam beberapa transaksi Bitcoin yang berbeda. Inilah yang kita bicarakan sebelumnya: heuristik ini menyimpulkan bahwa semua UTXO yang melewati alamat ini adalah milik satu entitas.

Penggunaan ulang alamat internal tidak terjadi ketika penggunaan ulang terjadi di beberapa transaksi, tetapi ketika terjadi dalam satu transaksi. Memang, jika alamat yang sama yang digunakan untuk mengunci input digunakan sebagai output dari sebuah transaksi, maka kita dapat menyimpulkan bahwa output ini masih milik pengguna yang sama (pertukaran), dan bahwa output kedua mewakili pembayaran yang sebenarnya. Heuristik lain ini memungkinkan untuk mengabadikan jejak dana pada beberapa transaksi.

![BTC204](assets/fr/045.webp)

Penggunaan ulang alamat adalah momok yang nyata pada Bitcoin. Menurut situs web OXT.me (saat ini tidak dapat diakses), tingkat penggunaan ulang alamat Bitcoin secara keseluruhan sekitar 52% pada tahun 2022:

![BTC204](assets/fr/069.webp)

Angka ini sangat besar, tetapi sebagian besar berasal dari platform pertukaran daripada pengguna individu.

### Bagaimana cara menghindari penggunaan ulang alamat?

Menghindari penggunaan ulang alamat cukup mudah: **cukup gunakan alamat baru yang kosong untuk semua pembayaran baru ke dompet Anda**.

Berkat BIP32, portofolio modern sekarang bersifat deterministik dan hirarkis. Ini berarti bahwa seorang pengguna dapat menghasilkan sejumlah besar alamat dari satu informasi awal: seed. Dengan menyimpan satu informasi ini, memungkinkan untuk mengembalikan semua private key dalam portofolio, memungkinkan akses ke dana yang diamankan oleh alamat yang sesuai.

![BTC204](assets/fr/070.webp)

Inilah sebabnya, ketika Anda menekan tombol "*receive*" pada perangkat lunak dompet Anda, alamat penerima yang tidak digunakan akan disarankan setiap saat. Setelah menerima bitcoin di alamat ini, perangkat lunak secara otomatis menyarankan alamat baru.

> *PS: Baru-baru ini, beberapa program perangkat lunak dompet telah mengumumkan niat mereka untuk berhenti membuat alamat kosong, karena khawatir hal ini akan dianggap sebagai bentuk pencucian uang oleh pihak berwenang. Jika perangkat lunak anda termasuk salah satunya, saya sangat menyarankan anda untuk segera menggantinya, karena hal ini tidak dapat diterima oleh pengguna.*
Jika Anda membutuhkan pengenal statis untuk menerima pembayaran, seperti donasi, tidak disarankan untuk menggunakan alamat Bitcoin klasik karena risiko penggunaan ulang. Sebagai gantinya, gunakan alamat Lightning, atau pilihlah pengenal pembayaran onchain statis, seperti BIP47 atau Silent Payments. Protokol-protokol ini dijelaskan secara detail di Bagian 6 dari kursus pelatihan ini.

## Memberi label dan memeriksa komponen

<chapterId>fbdb07cd-c025-48f2-97b0-bd1bc21c68a8</chapterId>


Seperti yang telah kita temukan di bagian analisis string, ada banyak heuristik dan pola yang dapat digunakan untuk menyimpulkan informasi tentang suatu transaksi. Sebagai pengguna, penting untuk mengetahui teknik-teknik ini untuk melindungi diri Anda dengan lebih baik.

Hal ini melibatkan pengelolaan dompet Anda secara ketat dalam penitipan mandiri, yang berarti mengetahui asal usul UTXO Anda, serta dengan hati-hati memilih UTXO mana yang akan digunakan saat melakukan pembayaran. Pengelolaan dompet yang efisien ini bergantung pada dua fitur penting dari dompet Bitcoin yang baik: penandaan dan kontrol koin.

Pada bab ini, kita akan melihat fitur-fitur ini dan melihat bagaimana Anda dapat menggunakannya secara cerdas, tanpa menambah beban kerja, untuk mengoptimalkan privasi Anda di Bitcoin.

### Apa yang dimaksud dengan pelabelan?

Pelabelan adalah praktik pemberian anotasi atau label pada UTXO tertentu dalam dompet Bitcoin. Anotasi ini disimpan secara lokal oleh perangkat lunak dompet dan tidak pernah dikirimkan melalui jaringan Bitcoin. Oleh karena itu, pelabelan adalah alat manajemen pribadi.

Misalnya, jika saya memiliki UTXO dari pembelian P2P di Bisq dengan Charles, saya dapat memberi label "`Non-KYC Bisq Charles`".

Penandaan adalah praktik yang baik yang membantu untuk mengingat asal atau tujuan UTXO, sehingga memudahkan pengelolaan dana dan optimalisasi privasi. Dompet Bitcoin Anda tentu saja menyimpan beberapa UTXO. Jika sumber UTXO ini berbeda, Anda mungkin tidak ingin menggabungkan UTXO ini di masa mendatang, jika tidak, Anda dapat mengungkapkan kepemilikan bersama mereka. Dengan memberi label yang tepat pada semua komponen Anda, Anda bisa yakin bahwa Anda akan mengingat dari mana asalnya ketika Anda perlu menggunakannya, meskipun itu bertahun-tahun dari sekarang.

### Apa yang dimaksud dengan kontrol sudut?

Penggunaan aktif pelabelan menjadi lebih menarik ketika digabungkan dengan opsi kontrol koin pada perangkat lunak portofolio Anda.

Kontrol koin adalah sebuah fitur yang terdapat pada perangkat lunak dompet Bitcoin yang baik, yang memberikan Anda kemampuan untuk memilih secara manual UTXO tertentu untuk digunakan sebagai input untuk menyelesaikan transaksi. Faktanya, untuk memenuhi pembayaran output, Anda perlu menggunakan UTXO input sebagai gantinya. Untuk beberapa alasan, yang akan kita bahas nanti, Anda mungkin ingin memilih dengan tepat bagian mana yang akan dikonsumsi sebagai input untuk memenuhi pembayaran tertentu. Inilah yang dapat Anda lakukan dengan kontrol koin. Sebagai analogi, fitur ini mirip dengan memilih koin tertentu dari dompet Anda saat Anda membayar baguette.

![BTC204](assets/fr/071.webp)

Penggunaan perangkat lunak portofolio dengan kontrol koin, ditambah dengan pelabelan UTXO, memungkinkan pengguna untuk membedakan dan memilih UTXO secara akurat untuk transaksi mereka.

### Bagaimana Anda memberi label pada UTXO Anda?

Tidak ada satu metode yang cocok untuk semua metode pelabelan UTXO. Terserah Anda untuk menentukan sistem pelabelan yang mudah dimengerti untuk portofolio Anda. Bagaimanapun, perlu diingat bahwa pelabelan yang baik adalah pelabelan yang dapat Anda pahami saat Anda membutuhkannya. Jika dompet Bitcoin Anda terutama ditujukan untuk tabungan, label tersebut mungkin tidak akan berguna bagi Anda selama beberapa dekade mendatang. Jadi, pastikan label tersebut jelas, tepat, dan komprehensif.

Sangat penting bagi orang yang Anda cintai untuk dapat dengan mudah mengidentifikasi asal usul dana jika suatu saat mereka membutuhkan akses ke portofolio Anda. Ini akan membantu mereka untuk alasan kerahasiaan dan untuk tujuan hukum, jika mereka perlu menjelaskan asal usul dana kepada pihak berwenang.

Hal terpenting yang perlu diperhatikan pada label adalah sumber UTXO. Anda cukup menunjukkan bagaimana koin tersebut bisa ada di dompet Anda. Apakah itu hasil pembelian di platform bursa? Pembayaran faktur dari pelanggan? Pertukaran peer-to-peer? Atau apakah itu merupakan pertukaran dari sebuah pengeluaran? Sebagai contoh, Anda dapat menentukan:


- hapus Exchange.com` ;
- pembayaran pelanggan David`;
- beli P2P Charles` ;
- `Ubah pembelian sofa`

![BTC204](assets/fr/072.webp)

Untuk menyempurnakan manajemen UTXO Anda dan menghormati strategi pemisahan dana dalam portofolio Anda, Anda dapat memperkaya label Anda dengan indikator tambahan yang mencerminkan pemisahan ini. Jika portofolio Anda berisi dua kategori UTXO yang tidak ingin Anda campur, Anda dapat memasukkan penanda ke dalam label Anda untuk membedakan kelompok-kelompok ini dengan jelas. Penanda pemisahan ini akan bergantung pada kriteria Anda sendiri, seperti membedakan antara UTXO yang dihasilkan dari proses akuisisi yang melibatkan KYC, atau antara dana profesional dan dana pribadi. Mengambil contoh label yang disebutkan di atas, hal ini dapat diterjemahkan menjadi:


- `KYC - Penarikan Exchange.com` ;
- `KYC - Pembayaran Pelanggan David`;
- `TANPA KYC - Beli P2P Charles`;
- `TANPA KYC - Ubah pembelian sofa`

![BTC204](assets/fr/073.webp)

Juga disarankan untuk mengabadikan pelabelan suatu bagian selama proses transaksi. Contohnya, ketika mengkonsolidasikan UTXO no-KYC, pastikan untuk menandai UTXO yang dihasilkan tidak hanya sebagai `konsolidasi`, tetapi secara khusus sebagai `konsolidasi no-KYC` untuk menyimpan catatan yang jelas tentang dari mana koin tersebut berasal.

Terakhir, tidak wajib untuk mencantumkan tanggal pada label. Kebanyakan perangkat lunak dompet sudah menampilkan tanggal transaksi, dan selalu memungkinkan untuk menemukan informasi ini pada penjelajah blok berkat TXID-nya.

### Bagaimana cara memilih komponen yang tepat?

Ketika Anda melakukan transaksi, kontrol koin memungkinkan Anda secara khusus memilih UTXO mana yang akan digunakan sebagai input untuk memenuhi output pembayaran. Ada dua aspek dalam pilihan ini:


- Kemungkinan bagi penerima pembayaran untuk menautkan bagian dari identitas Anda ke UTXO yang digunakan dalam input;
- Kemampuan pengamat eksternal untuk membuat hubungan antara semua UTXO yang dikonsumsi sebagai input.

Untuk mengilustrasikan poin pertama, mari kita ambil contoh konkret. Misalkan Anda membeli roti baguette dengan bitcoin dari tukang roti Anda. Anda menggunakan satu atau beberapa UTXO yang Anda pegang sebagai input untuk memenuhi setidaknya harga baguette dalam bentuk output, serta biaya transaksi. Pembuat roti Anda kemudian berpotensi mengaitkan wajah Anda, atau bagian lain dari identitas Anda yang dia ketahui, dengan koin yang digunakan sebagai input. Dengan mengetahui adanya hubungan ini, Anda mungkin lebih memilih untuk memilih UTXO tertentu daripada yang lain saat membayar.

![BTC204](assets/fr/074.webp)

Misalnya, jika salah satu UTXO Anda berasal dari platform pertukaran dan Anda lebih suka pembuat roti tidak mengetahui akun Anda di platform tersebut, Anda tidak akan menggunakan UTXO tersebut untuk pembayaran. Jika Anda memiliki UTXO bernilai tinggi yang menunjukkan jumlah bitcoin yang signifikan, Anda juga dapat memilih untuk tidak menggunakannya agar pembuat roti tidak mengetahui kekayaan BTC Anda.

Oleh karena itu, memilih UTXO mana yang akan digunakan untuk poin pertama ini merupakan keputusan pribadi, dipengaruhi oleh apa yang ingin Anda ungkapkan atau tidak. Label yang Anda berikan pada UTXO ketika Anda menerimanya akan membantu Anda memilih UTXO yang, setelah dibelanjakan, hanya mengungkapkan informasi yang Anda inginkan kepada penerima.

Di luar informasi yang berpotensi diungkapkan kepada penerima, pilihan input juga memengaruhi apa yang Anda ungkapkan kepada semua pengamat blockchain. Memang, dengan menggunakan beberapa UTXO sebagai input untuk transaksi Anda, Anda mengungkapkan bahwa mereka dimiliki oleh entitas yang sama, menurut heuristik CIOH (_Common Input Ownership Heuristic_).

![BTC204](assets/fr/075.webp)

Oleh karena itu, ketika memilih suku cadang, Anda harus menyadari bahwa transaksi yang akan Anda siarkan akan membuat tautan antara semua UTXO yang digunakan. Tautan ini dapat menjadi masalah bagi privasi pribadi Anda, terutama jika UTXO berasal dari sumber yang berbeda.

![BTC204](assets/fr/076.webp)

Mari kita ambil contoh UTXO tanpa KYC saya dari Bisq; saya ingin menghindari penggabungan dengan UTXO dari, katakanlah, platform bursa teregulasi yang mengetahui identitas saya. Memang, jika saya menggunakan 2 UTXO ini sebagai input untuk transaksi yang sama, platform yang teregulasi akan dapat menautkan identitas saya dengan UTXO yang saya beli di Bisq, yang sebelumnya tidak ditautkan dengan identitas saya.

![BTC204](assets/fr/077.webp)

Terakhir, ketika memilih UTXO mana yang akan digunakan sebagai input untuk transaksi, yang paling penting adalah hindari menggunakan banyak UTXO. Sebisa mungkin, jika memungkinkan, pilihlah satu koin yang cukup besar untuk memenuhi pembayaran Anda. Dengan cara ini, Anda benar-benar terhindar dari risiko yang terkait dengan CIOH. Namun, jika tidak ada satu pun UTXO yang mencukupi untuk pembayaran dan Anda perlu menggunakan beberapa UTXO, pastikan UTXO tersebut berasal dari sumber yang sama untuk meminimalkan risiko tautan yang tidak diinginkan. Ingatlah juga bahwa penerima dapat mengaitkan informasi yang mereka pegang tentang Anda dengan riwayat koin yang digunakan dalam input.

### Memahami pemilihan suku cadang otomatis

Pada bagian sebelumnya, kita telah membahas pemilihan UTXO secara manual yang akan digunakan untuk sebuah transaksi. Namun, apa yang terjadi jika perangkat lunak dompet melakukan pemilihan ini secara otomatis? Ada beberapa metode untuk menentukan koin mana yang akan digunakan, dan pemilihan UTXO merupakan salah satu bidang penelitian Bitcoin. Tujuan utama dari proses otomatis ini sering kali adalah untuk meminimalisir biaya transaksi bagi pengguna.

Metode pemilihan UTXO seperti FIFO (*First In First Out*) dan LIFO (*Last In First Out*) adalah yang paling sederhana, tetapi juga yang paling tidak efisien. Dengan FIFO, bagian tertua dalam portofolio digunakan terlebih dahulu. Pendekatan ini umumnya tidak efisien baik untuk meminimalkan biaya transaksi maupun untuk menjaga kerahasiaan, kecuali dalam kasus-kasus di mana batas waktu relatif digunakan dan perlu diperbarui secara teratur. Sebaliknya, LIFO memprioritaskan penggunaan UTXO terbaru. Kedua metode ini, meskipun sederhana, sering kali terbukti tidak efektif.

Metode yang lebih canggih adalah *Knapsack Solver*. Metode ini digunakan pada dompet Bitcoin Core hingga versi 0.17. Metode ini terdiri dari pemilihan UTXO secara iteratif dan acak dari dompet, menambahkannya ke dalam subset, dan menjaga solusi yang mengurangi bobot transaksi sebanyak mungkin, untuk mengurangi biaya bagi pengguna.

Algoritma *Branch-and-Bound* (BNB), yang sering dijuluki sebagai "algoritma Murch" sesuai dengan nama penemunya, telah menggantikan *Knapsack Solver* di Bitcoin Core pada versi 0.17. Metode yang lebih canggih ini bertujuan untuk menemukan sekumpulan UTXO yang sesuai dengan jumlah yang dibutuhkan untuk memenuhi hasil transaksi. Tujuan dari BNB adalah untuk meminimalkan jumlah pertukaran dan juga biaya, dengan mengurangi apa yang disebut sebagai kriteria pemborosan, yang memperhitungkan biaya langsung dan biaya yang diharapkan di masa depan dari pertukaran. Metode ini berasal dari konsep asli *Branch-and-Bound*, yang disusun pada tahun 1960 oleh Ailsa Land dan Alison Harcourt, dan menawarkan optimasi biaya yang lebih tepat daripada *Knapsack Solver*.

Semua metode pemilihan UTXO otomatis ini mungkin efektif dalam mengurangi biaya transaksi, tetapi sering kali tidak efektif dalam menjaga kerahasiaan pengguna. Memang, algoritme ini dapat menggabungkan beberapa UTXO ke dalam input, sehingga mengungkapkan properti umum dari UTXO ini karena CIOH. Jelas, metode ini tidak dapat memperhitungkan label yang ditempelkan pada UTXO, yang tetap penting untuk secara sadar memilih bagian mana yang akan diungkapkan kepada penerima transaksi. Saat ini, satu-satunya cara untuk mengoptimalkan kerahasiaan saat memilih koin adalah dengan melakukannya secara manual.

### Tutorial tentang pelabelan UTXO

Jika Anda ingin mengetahui cara menandai UTXO Anda, kami telah membuat tutorial komprehensif tentang perangkat lunak dompet Bitcoin utama yang ada di luar sana:

https://planb.network/tutorials/privacy/on-chain/utxo-labelling-d997f80f-8a96-45b5-8a4e-a3e1b7788c52

## KYC dan identifikasi kunci

<chapterId>cec6b9d9-0eed-4f85-bc4e-1e9aa59ca605</chapterId>


KYC adalah singkatan dari "Kenali Pelanggan Anda". Ini adalah prosedur regulasi yang diterapkan oleh perusahaan-perusahaan tertentu yang beroperasi di sektor Bitcoin. Tujuan dari prosedur ini adalah untuk memverifikasi dan mendaftarkan identitas pelanggan mereka, dengan tujuan untuk memerangi pencucian uang dan pendanaan terorisme.

Secara praktis, KYC melibatkan pengumpulan berbagai data pribadi dari pelanggan, yang dapat bervariasi sesuai dengan yurisdiksi, tetapi umumnya mencakup ID, foto, dan bukti alamat. Informasi ini kemudian diverifikasi dan disimpan untuk digunakan di masa mendatang.

Prosedur ini telah menjadi wajib untuk semua platform bursa yang teregulasi di sebagian besar negara Barat. Ini berarti siapa pun yang ingin menukarkan mata uang negara dengan bitcoin melalui platform ini harus mematuhi persyaratan KYC.

Prosedur ini bukannya tanpa risiko terhadap privasi dan keamanan pengguna. Pada bab ini, kami akan membahas risiko-risiko tersebut secara mendetail dan menganalisa dampak spesifik dari proses KYC dan identifikasi terhadap privasi pengguna Bitcoin.

### Memfasilitasi penelusuran onchain

Resiko pertama yang terkait dengan KYC adalah bahwa ia menawarkan sebuah titik masuk yang istimewa untuk analisis blockchain. Seperti yang telah kita lihat pada bagian sebelumnya, analis dapat mengelompokkan dan melacak aktivitas pada blockchain menggunakan pola transaksi dan heuristik. Ketika mereka berhasil mengelompokkan aktivitas pengguna di blockchain, yang perlu mereka lakukan adalah menemukan satu titik masuk di antara semua transaksi dan kunci-kuncinya untuk sepenuhnya membahayakan kerahasiaannya.

![BTC204](assets/fr/078.webp)

Ketika Anda melakukan KYC, Anda memberikan titik masuk berkualitas tinggi untuk analisis blockchain, karena Anda mengaitkan alamat penerima yang digunakan ketika menarik bitcoin Anda dari platform bursa dengan identitas lengkap dan terverifikasi. Secara teori, informasi ini hanya diketahui oleh perusahaan tempat Anda memberikannya, tetapi, seperti yang akan kita lihat di bawah, risiko kebocoran data adalah nyata. Terlebih lagi, fakta bahwa perusahaan memiliki informasi ini bisa menjadi masalah, bahkan jika mereka tidak membagikannya.

Jadi, jika Anda tidak mengambil langkah lain untuk membatasi agregasi aktivitas Anda di blockchain, siapa pun yang mengetahui titik masuk KYC ini berpotensi menghubungkan semua aktivitas Anda di Bitcoin dengan identitas Anda. Dari sudut pandang perusahaan tersebut, penggunaan Bitcoin Anda akan kehilangan semua kerahasiaannya.

![BTC204](assets/fr/079.webp)

Sebagai perbandingan, seolah-olah bankir Anda di *Bank X* tidak hanya memiliki akses ke semua transaksi Anda dengan *Bank X*, tetapi juga dapat mengamati transaksi Anda dengan *Bank Y* dan semua transaksi tunai Anda.

Ingatlah kembali bagian pertama dari kursus pelatihan ini: Model kerahasiaan Bitcoin, seperti yang dipahami oleh Satoshi Nakamoto, didasarkan pada pemisahan antara identitas pengguna dan pasangan kuncinya. Meskipun lapisan kerahasiaan ini tidak lagi memadai saat ini, namun tetaplah bijaksana untuk membatasi degradasinya sebanyak mungkin.

### Paparan terhadap pengawasan negara

Masalah utama kedua dengan KYC adalah bahwa KYC mengungkapkan kepada negara bahwa Anda pernah memiliki bitcoin pada suatu waktu. Ketika Anda membeli bitcoin melalui pihak yang teregulasi, maka negara dapat mengetahui tentang kepemilikan ini. Saat ini, hal ini mungkin terlihat sepele, tetapi penting untuk diingat bahwa masa depan politik dan ekonomi negara Anda tidak berada di tangan Anda.

Pertama, negara dapat dengan cepat mengadopsi sikap otoriter. Sejarah penuh dengan contoh-contoh di mana kebijakan berubah secara tiba-tiba. Saat ini, di Eropa, para Bitcoiners dapat menulis artikel mengenai Bitcoin, ikut serta dalam konferensi, dan mengelola dompet mereka secara mandiri. Namun, siapa yang bisa mengatakan apa yang akan terjadi di hari esok? Jika Bitcoin tiba-tiba menjadi musuh publik nomor satu, dikaitkan dengan Bitcoin di dalam arsip pemerintah bisa menjadi masalah.

Kemudian, dalam menghadapi krisis ekonomi yang parah, negara dapat mempertimbangkan untuk menyita bitcoin yang dimiliki oleh warga negara. Mungkin besok, para pengguna bitcoin akan dianggap sebagai pengambil keuntungan dari krisis, dan akan dikenakan pajak yang berlebihan untuk keuntungan modal mereka dalam menghadapi devaluasi mata uang fiat.

Anda mungkin berpikir bahwa ini bukan masalah, karena bitcoin Anda tercampur, dan karena itu tidak dapat dilacak. Namun, pelacakan bukanlah masalah di sini. Masalah yang sebenarnya adalah bahwa negara mengetahui bahwa Anda telah memiliki bitcoin. Informasi ini saja sudah cukup untuk memberatkan Anda atau meminta pertanggungjawaban Anda. Anda bisa saja mengklaim bahwa Anda telah membelanjakan bitcoin Anda, namun hal tersebut harus tercermin dalam pengembalian pajak Anda, dan Anda akan ketahuan. Anda juga bisa mengatakan bahwa Anda kehilangan kunci Anda dalam sebuah kecelakaan kapal, tetapi di luar lelucon Twitter, apakah Anda benar-benar berpikir bahwa itu akan cukup untuk membebaskan Anda?

Jadi, penting untuk memperhitungkan risiko negara mengetahui bahwa Anda telah memiliki BTC, betapapun jauhnya risiko tersebut saat ini.

Masalah lain yang ditimbulkan oleh KYC dalam hal pengawasan negara adalah pelaporan wajib oleh platform yang diatur. Meskipun saya tidak terbiasa dengan peraturan di yurisdiksi lain, di Prancis, *Prestataires de Services sur Actifs Numériques* (PSAN) diwajibkan untuk melaporkan kepada otoritas pengawas keuangan setiap pergerakan dana yang mereka anggap mencurigakan.

Di Prancis pada tahun 2023, 1.449 tindakan mencurigakan dilaporkan oleh PSAN. Untuk saat ini, sebagian besar tindakan ini terkait dengan kejahatan. Namun, pihak berwenang juga meminta platform yang teregulasi untuk melaporkan transaksi Bitcoin yang mencurigakan hanya berdasarkan strukturnya. Jika Anda melakukan transaksi kolaboratif, atau bahkan hanya transaksi dengan pola yang tidak lazim, dan transaksi ini terjadi tidak jauh dari penarikan Bitcoin Anda dari platform-platform ini, Anda bisa saja dilaporkan ke pihak berwenang. Bahkan tanpa adanya pelanggaran dan dalam pelaksanaan hak-hak Anda yang sah, pelaporan semacam itu dapat menyebabkan peningkatan pemeriksaan dan pengawasan, ketidaknyamanan yang dapat Anda hindari tanpa KYC.

### Risiko kebocoran data pribadi

Masalah lain dengan KYC adalah bahwa KYC mengharuskan semua data pribadi Anda disimpan di server perusahaan swasta.

Peristiwa baru-baru ini telah mengingatkan kita bahwa tidak ada yang kebal terhadap kegagalan keuangan atau TI. Pada tahun 2022, pelanggan Celsius menderita akibatnya. Setelah kebangkrutan perusahaan, nama-nama kreditor dan jumlah aset mereka diumumkan oleh pengadilan Amerika selama proses administratif.

Lebih dari dua tahun yang lalu, salah satu perusahaan terkemuka dalam keamanan siber mata uang kripto mengalami pencurian data pribadi pelanggannya. Meskipun kejadian ini tidak secara langsung terkait dengan pembelian bitcoin, risiko seperti itu juga tetap ada pada platform pertukaran. Oleh karena itu, ada risiko yang pasti terkait dengan data pribadi.

Memang benar bahwa kita telah mempercayakan banyak data pribadi kita kepada perusahaan swasta. Namun, risikonya ada dua, karena data ini tidak hanya mengidentifikasi Anda, tetapi juga terkait dengan aktivitas di Bitcoin. Memang, ketika seorang peretas mendapatkan akses ke data pelanggan dari sebuah platform bursa, ia dapat berasumsi bahwa pelanggan tersebut memiliki Bitcoin. Risiko ini semakin besar karena Bitcoin, seperti aset berharga lainnya, menarik perhatian para pencuri.

Jika terjadi kebocoran data, paling banter Anda bisa menjadi target upaya phishing yang ditargetkan. Dalam kasus terburuk, Anda bisa menemukan diri Anda berada di tengah-tengah ancaman fisik terhadap rumah Anda.

Selain risiko spesifik yang terkait dengan Bitcoin, ada juga bahaya yang terkait dengan pengiriman dokumen identitas. Bahkan, jika terjadi kebocoran data, ada kemungkinan untuk menjadi korban pencurian identitas. Jadi, taruhannya tidak hanya sebatas melindungi kerahasiaan transaksi, tetapi juga menyangkut keamanan pribadi setiap individu.

### Beberapa ide yang sudah ada sebelumnya tentang KYC

Penting untuk mendekonstruksi beberapa ide yang sudah ada sebelumnya mengenai KYC yang sering kita temui di Twitter atau dalam pertukaran antar pengguna bitcoin.

Pertama-tama, tidak tepat jika Anda berpikir bahwa melindungi privasi Anda untuk Bitcoin yang diperoleh melalui KYC tidak ada gunanya. Alat dan metode privasi pada Bitcoin sangat beragam dan memiliki tujuan yang berbeda-beda. Menggunakan transaksi coinjoin pada Bitcoin yang diperoleh melalui KYC, misalnya, bukanlah ide yang buruk. Tentu saja, Anda harus berhati-hati dengan platform bursa yang teregulasi untuk menghindari akun Anda dibekukan atau diblokir, tetapi dari sudut pandang teknis, praktik-praktik ini tidak bertentangan. Coinjoin memiliki efek memutus riwayat koin, sehingga membantu Anda menggagalkan risiko analisis rantai tertentu yang terkait dengan KYC. Meskipun tidak menghilangkan semua risiko, ini merupakan manfaat yang signifikan.

![BTC204](assets/fr/080.webp)

Kerahasiaan pada Bitcoin tidak boleh dilihat secara biner, sebagai pembeda antara bitcoin "anonim" dan yang tidak. Memiliki Bitcoin yang diperoleh melalui KYC tidak berarti semuanya hilang; sebaliknya, penggunaan alat kerahasiaan dapat terbukti lebih bermanfaat.

Sebaliknya, memperoleh bitcoin melalui metode non-KYC tidak menjamin kerahasiaan yang sempurna, dan juga tidak membebaskan Anda dari keharusan untuk melakukan tindakan perlindungan lainnya. Jika Anda memiliki bitcoin non-KYC namun menggunakan alamat penerima beberapa kali, transaksi Anda dapat dilacak dan dikumpulkan. Hubungan sekecil apa pun dengan dunia di luar Bitcoin dapat membahayakan satu-satunya lapisan kerahasiaan yang Anda miliki. Jadi, penting untuk mempertimbangkan semua alat dan metode peningkatan privasi pada Bitcoin sebagai pelengkap. Setiap teknik menangani risiko tertentu dan dapat menambahkan lapisan perlindungan ekstra. Jadi, memiliki Bitcoin non-KYC bukan berarti Anda tidak perlu melakukan tindakan pencegahan lainnya.

### Apakah KYC dapat dibatalkan?

Saya terkadang ditanya apakah mungkin untuk "kembali" setelah melakukan KYC, dan seperti yang bisa Anda bayangkan dari paragraf sebelumnya, jawabannya sangat beragam. Cara paling sederhana untuk menghindari risiko yang terkait dengan KYC adalah dengan tidak menggunakannya saat membeli bitcoin. Kita akan membahas topik ini secara lebih mendalam di bab selanjutnya. Akan tetapi, jika KYC sudah dilakukan dan bitcoin sudah dibeli, apakah ada cara untuk mengurangi risiko yang ada?

Ketika berbicara mengenai risiko penelusuran transaksi Anda, penggunaan coinjoin merupakan sebuah solusi. Kita akan membahas metode ini secara mendetail di kursus ini, tetapi Anda harus tahu bahwa coinjoin memungkinkan Anda untuk memutus riwayat koin dan mencegahnya dilacak dari masa lalu-sekarang dan sekarang-masa lalu. Bahkan untuk BTC yang diperoleh melalui platform yang teregulasi, teknik ini dapat mencegah keterlacakannya.

Akan tetapi, coinjoin tidak menghapus risiko kedua yang terkait dengan KYC: fakta bahwa negara dapat mengetahui kepemilikan bitcoin Anda. Memang, bahkan jika koin Anda tidak lagi dapat dilacak, Negara, tergantung pada yurisdiksinya, mungkin memiliki akses ke pernyataan transfer aset kripto Anda. Karena risiko ini tidak bersifat teknis, tetapi administratif, tidak ada solusi khusus Bitcoin untuk menghilangkannya, selain tidak mengekspos diri Anda pada KYC sejak awal. Satu-satunya pendekatan legal untuk mengurangi risiko ini adalah dengan menjual Bitcoin yang Anda peroleh melalui platform yang teregulasi, kemudian membelinya kembali melalui cara yang bebas KYC. Dengan menjual dan mendeklarasikan transfer tersebut, pihak berwenang akan melihat bahwa Anda tidak lagi memilikinya.

Mengenai risiko bocornya data pribadi dan dokumen identitas Anda, ini merupakan bahaya di luar Bitcoin, dan tidak ada solusi teknis untuk menghindarinya. Setelah data Anda terungkap, sulit untuk membatalkan operasi tersebut. Anda bisa mencoba menutup akun Anda di platform, tetapi ini tidak menjamin penghapusan data KYC Anda, terutama jika verifikasi identitas dialihdayakan. Verifikasi penghapusan lengkap informasi Anda tidak mungkin dilakukan. Oleh karena itu, tidak ada solusi untuk sepenuhnya mencegah risiko ini dan memastikan bahwa risiko ini tidak ada lagi.

### Perbedaan antara KYC dan identifikasi kunci

Terkadang, beberapa pengguna bitcoin cenderung memperluas istilah "KYC" ke setiap pertukaran BTC yang melibatkan transfer kawat atau pembayaran kartu kredit, karena cara-cara ini juga dapat mengungkapkan asal-usul pembayaran, seperti halnya KYC. Namun, KYC tidak boleh disamakan dengan identifikasi kunci. Sebagai catatan pribadi, saya harus mengakui bahwa persepsi saya mengenai hal ini telah berkembang dari waktu ke waktu.

KYC secara khusus mengacu pada prosedur regulasi yang diterapkan oleh perusahaan tertentu untuk memverifikasi dan mendaftarkan identitas pelanggan mereka. Ini adalah hal yang bersifat biner: ketika mendapatkan bitcoin, Anda melakukan KYC, atau tidak. Akan tetapi, identifikasi kunci, yang menyangkut hubungan antara aspek identitas pengguna dan aktivitas onchain, tidak bersifat biner, melainkan mewakili sebuah kontinum. Memang, dalam konteks akuisisi atau transfer bitcoin, identifikasi seperti itu selalu memungkinkan dalam berbagai tingkatan.

Sebagai contoh, jika Anda membeli bitcoin di platform teregulasi di Swiss, KYC tidak diperlukan. Akan tetapi, kunci Anda dapat diidentifikasi, karena pembelian dilakukan melalui rekening bank Anda. Di sinilah dua risiko pertama yang terkait dengan KYC - fasilitasi penelusuran onchain dan paparan terhadap pengawasan negara - juga dapat muncul dalam bursa tanpa KYC. Jika entitas Swiss melaporkan transaksi yang mencurigakan kepada pihak berwenang di negara Anda, mereka dapat dengan mudah memeriksa rekening bank yang digunakan untuk pembelian untuk menemukan identitas Anda. Jadi, membeli tanpa KYC pada platform teregulasi memiliki skala risiko yang cukup tinggi untuk identifikasi kunci.

![BTC204](assets/fr/081.webp)

Akan tetapi, menghindari platform yang teregulasi dan memilih metode akuisisi P2P tidak sepenuhnya menghilangkan risiko identifikasi kunci, tetapi hanya menguranginya. Mari kita ambil contoh pembelian di Bisq atau platform P2P lainnya. Untuk membayar rekanan Anda, Anda mungkin akan menggunakan rekening bank Anda. Jika pihak berwenang menanyai orang yang bertransaksi dengan Anda dan meminta nama Anda, kita kembali ke risiko 1 dan 2. Meskipun risiko ini jauh lebih rendah dibandingkan saat membeli di platform tanpa KYC, dan bahkan lebih rendah dibandingkan saat membeli dengan KYC, risiko ini masih ada pada tingkat yang lebih rendah.

![BTC204](assets/fr/082.webp)

Terakhir, meskipun Anda mendapatkan bitcoin melalui pertukaran fisik dengan uang tunai, Anda tidak sepenuhnya anonim. Orang yang Anda ajak bertukar telah melihat wajah Anda, yang merupakan bagian dari identitas Anda. Meskipun sangat minim dalam contoh ini, masih ada kemungkinan untuk melakukan identifikasi.

![BTC204](assets/fr/083.webp)

Kesimpulannya, ketika bitcoin ditukarkan dengan aset lain, baik itu pembelian dengan mata uang negara atau penjualan dengan barang nyata, selalu ada beberapa bentuk identifikasi kunci. Tergantung pada metode pertukaran yang dipilih, identifikasi ini dapat bervariasi dalam intensitasnya. Penting untuk tidak mengacaukan identifikasi ini dengan KYC, yang merupakan proses regulasi yang jelas. Akan tetapi, terdapat hubungan antara KYC dan spektrum identifikasi, karena KYC berada di ujung spektrum yang lebih tinggi, karena secara sistematis memfasilitasi identifikasi kunci pengguna oleh pihak berwenang.

## Metode penjualan dan akuisisi

<chapterId>756598af-95aa-4c77-ac48-243c7ad89530</chapterId>


Setelah membaca bab sebelumnya, Anda mungkin bertanya-tanya bagaimana cara membeli atau menjual bitcoin tanpa harus menjalani prosedur verifikasi identitas, untuk menghindari risiko yang terkait dengan KYC. Ada beberapa cara untuk memperdagangkan bitcoin.

### Pertukaran uang tunai P2P

Seperti yang telah kita lihat, metode terbaik dalam hal kerahasiaan tetaplah pertukaran P2P (orang-ke-orang) dengan penyelesaian tunai. Metode ini memungkinkan Anda untuk meminimalkan jejak yang ditinggalkan, dan sangat mengurangi kemungkinan identifikasi kunci, baik saat Anda membeli atau menjual.

![BTC204](assets/fr/084.webp)

Namun demikian, ada risiko terhadap keamanan pribadi. Bahaya utama terletak pada kenyataan bahwa, selama pertukaran, pihak lawan akan mengetahui bahwa Anda memegang sejumlah besar uang, baik dalam bentuk tunai maupun bitcoin. Informasi ini dapat menarik perhatian orang yang berniat jahat. Memang, secara umum disarankan untuk berhati-hati dalam menyimpan bitcoin Anda. Saran ini juga dapat diterapkan pada uang tunai. Namun, saat bertransaksi secara langsung, tidak dapat dihindari untuk mengungkapkan bahwa Anda memiliki bitcoin, dan hal ini dapat menarik perhatian yang tidak diinginkan.

![BTC204](assets/fr/085.webp)

Untuk membatasi risiko ini, saya menyarankan Anda untuk lebih memilih transaksi tunai dengan orang yang dipercaya, seperti anggota keluarga atau teman dekat. Sebagai alternatif, Anda juga dapat mempertimbangkan untuk bertransaksi di [pertemuan Bitcoin lokal] (https://btcmap.org/communities/map), setelah menghadiri beberapa kali. Hal ini akan membuat Anda lebih mengenal peserta lain dan tidak merasa sendirian saat melakukan pertukaran secara fisik. Namun, penting untuk diketahui bahwa pertukaran uang P2P secara inheren membawa risiko terhadap keamanan pribadi Anda yang tidak ada saat membeli melalui platform yang teregulasi dan rekening bank Anda.

Terlebih lagi, tergantung di mana Anda tinggal, mengangkut dan menyimpan uang dalam jumlah besar bisa jadi berisiko, entah itu bitcoin atau uang tunai.

Menukarkan uang tunai juga dapat menimbulkan risiko hukum jika terjadi pemeriksaan polisi atau pemeriksaan lainnya. Meskipun di sebagian besar negara tidak ada batasan jumlah uang tunai yang dapat Anda bawa, jumlah yang berlebihan dapat menimbulkan kecurigaan. Jadi berhati-hatilah, terutama jika Anda harus melakukan perjalanan jauh, dan hindari melakukan terlalu banyak transaksi dalam jumlah besar sekaligus, agar tidak perlu membenarkan kepemilikan uang tunai dalam jumlah besar.

Terakhir, kelemahan lain dari pembelian P2P adalah harganya yang sering kali lebih tinggi daripada platform yang teregulasi. Penjual sering kali mengenakan mark-up mulai dari 1% hingga lebih dari 10%. Ada beberapa alasan untuk perbedaan harga ini. Pertama, ini adalah praktik umum di antara penjual P2P yang telah menjadi mapan dari waktu ke waktu. Kedua, penjual memiliki biaya yang terkait dengan transaksi untuk mengirimkan dana kepada pembeli. Ada juga peningkatan risiko pencurian dalam penjualan P2P dibandingkan dengan transaksi platform, yang membenarkan kompensasi atas risiko yang diambil. Terakhir, biaya tambahan dapat dikaitkan dengan permintaan dan kualitas bursa dalam hal kerahasiaan. Sebagai pembeli, keuntungan dalam kerahasiaan memiliki harga yang tercermin dalam mark-up yang diterapkan oleh penjual. Beberapa pengguna bitcoin juga percaya bahwa harga mark-up BTC yang dibeli di P2P mencerminkan harga sebenarnya, dan berpendapat bahwa harga yang lebih rendah di platform yang diatur adalah hasil dari kompromi pada kerahasiaan data pribadi Anda.

![BTC204](assets/fr/086.webp)

### Pertukaran P2P melalui platform perjodohan

Alternatif yang lebih tidak berisiko dalam hal keamanan pribadi adalah dengan melakukan pertukaran P2P secara eksklusif secara online, melalui metode pembayaran elektronik seperti PayPal, transfer bank, atau Revolut.

![BTC204](assets/fr/087.webp)

Pendekatan ini menghindari banyak risiko yang terkait dengan transaksi tunai. Akan tetapi, risiko pihak lawan gagal bayar dalam bursa online lebih besar. Memang, dalam pertukaran fisik, jika Anda menyerahkan uang kepada penjual yang tidak mengirimi Anda bitcoin sebagai gantinya, Anda dapat segera meminta pertanggungjawaban, karena dia berdiri di depan Anda. Sebaliknya, secara online, sering kali tidak mungkin untuk melacak seseorang yang telah mencuri dari Anda.

![BTC204](assets/fr/088.webp)

Untuk mengurangi risiko ini, Anda dapat menggunakan platform khusus untuk bursa P2P. Platform-platform ini menggunakan mekanisme resolusi konflik untuk melindungi pengguna yang dirugikan. Biasanya, mereka menawarkan sistem escrow, di mana bitcoin disimpan sampai pembayaran dalam mata uang fiat dikonfirmasi oleh penjual.

![BTC204](assets/fr/089.webp)

Dalam hal keamanan pribadi, metode pembelian ini jauh lebih aman dibandingkan dengan pertukaran uang tunai secara fisik. Akan tetapi, seperti yang telah disebutkan di atas, pertukaran P2P online meninggalkan lebih banyak jejak daripada pertukaran fisik, yang dapat merugikan privasi Bitcoin. Dengan menggunakan metode pembayaran fiat online seperti bank, Anda mengekspos lebih banyak informasi yang dapat memfasilitasi identifikasi kunci.

![BTC204](assets/fr/090.webp)

Sekali lagi, saya tidak akan merekomendasikan melakukan terlalu banyak perdagangan besar dalam satu transaksi di platform ini. Dengan membagi transaksi Anda, Anda menyebarkan risiko pencurian mitra pengimbang.

Sekali lagi, kelemahan lain dari pembelian P2P adalah harganya yang sering kali lebih tinggi daripada yang teramati pada platform yang teregulasi. Penjual sering kali mengenakan mark-up mulai dari 1% hingga lebih dari 10%. Ada beberapa alasan untuk perbedaan harga ini. Pertama, ini adalah praktik umum di antara penjual P2P yang telah menjadi mapan dari waktu ke waktu. Kedua, penjual memiliki biaya yang terkait dengan transaksi untuk mengirimkan dana kepada pembeli. Ada juga peningkatan risiko pencurian dalam penjualan P2P dibandingkan dengan transaksi platform, yang membenarkan kompensasi atas risiko yang diambil. Terakhir, biaya tambahan dapat dikaitkan dengan permintaan dan kualitas bursa dalam hal kerahasiaan. Sebagai pembeli, keuntungan dalam kerahasiaan memiliki harga yang tercermin dalam mark-up yang diterapkan oleh penjual. Beberapa pengguna bitcoin juga percaya bahwa harga mark-up BTC yang dibeli di P2P mencerminkan harga sebenarnya, dan berpendapat bahwa harga yang lebih rendah di platform yang diatur adalah hasil dari kompromi pada kerahasiaan data pribadi Anda.

![BTC204](assets/fr/086.webp)

Sejauh menyangkut solusi, saya pribadi selalu menggunakan [Bisq] (https://bisq.network/) dan saya sangat senang dengannya. Sistem mereka telah dicoba dan diuji dan tampaknya dapat diandalkan. Namun, Bisq hanya tersedia pada PC dan antarmukanya mungkin terlalu rumit untuk pemula. Kekurangan lainnya adalah Bisq hanya beroperasi dengan transaksi onchain, yang dapat menjadi mahal selama periode biaya transaksi Bitcoin yang tinggi.

-> Lihat tutorial Bisq kami.

https://planb.network/tutorials/exchange/peer-to-peer/bisq-fe244bfa-dcc4-4522-8ec7-92223373ed04

Untuk opsi yang lebih sederhana, Anda bisa mencoba [Peach] (https://peachbitcoin.com/), sebuah aplikasi seluler yang menghubungkan pembeli dan penjual dengan sistem resolusi konflik bawaan. Prosesnya lebih intuitif daripada Bisq.

-> Lihat tutorial Peach kami.

https://planb.network/tutorials/exchange/peer-to-peer/peach-c6143241-d900-4047-9b73-1caba5e1f874

Pilihan online lainnya adalah [HodlHodl] (https://hodlhodl.com/), platform mapan yang menawarkan likuiditas yang baik, meskipun saya belum mengujinya secara pribadi.

-> Lihat tutorial HodlHodl kami.

https://planb.network/tutorials/exchange/peer-to-peer/hodlhodl-d7344cd5-6b18-40f5-8e78-2574a93a3879

Untuk solusi berbasis Lightning Network, cobalah [RoboSats] (https://learn.robosats.com/) dan [LNP2PBot] (https://lnp2pbot.com/). RoboSats dapat diakses melalui situs web dan relatif mudah digunakan. LNP2PBot lebih tidak lazim, karena bekerja melalui sistem pertukaran pada aplikasi perpesanan Telegram.

-> Lihat tutorial RoboSats kami.

-> Lihat tutorial LNP2PBot kami.

https://planb.network/tutorials/exchange/peer-to-peer/robosats-b60e4f7c-533a-4295-9f6d-5368152e8c06

https://planb.network/tutorials/exchange/peer-to-peer/lnp2pbot-v2-e6bcb210-610b-487d-970c-7cce85273e3c

![BTC204](assets/fr/091.webp)

### Platform teregulasi tanpa KYC

Tergantung pada negara tempat Anda tinggal, Anda mungkin memiliki akses ke platform teregulasi yang tidak memerlukan prosedur KYC untuk membeli atau menjual bitcoin. Di Swiss, misalnya, Anda bisa menggunakan platform seperti [Relai] (https://relai.app/) dan [MtPelerin] (https://www.mtpelerin.com/).

-> Lihat tutorial kami tentang Relai.

https://planb.network/tutorials/exchange/centralized/relai-v2-30a9671d-e407-459d-9203-4c3eae15b30e

Seperti yang telah kita lihat pada bab sebelumnya, jenis platform ini menyelamatkan Anda dari risiko yang terkait dengan prosedur KYC, tetapi platform ini menghadirkan tingkat risiko yang lebih tinggi untuk identifikasi kunci. Dalam hal kerahasiaan Bitcoin, platform ini menawarkan perlindungan yang lebih baik dibandingkan metode pembelian dengan KYC, tetapi tetap kurang menarik dibandingkan bursa P2P.

Namun, dalam hal keamanan pribadi, menggunakan platform ini jauh lebih kecil risikonya dibandingkan dengan bursa P2P. Platform ini juga sering kali lebih mudah digunakan daripada platform P2P.

### ATM

Pilihan lain untuk membeli atau menjual bitcoin tanpa KYC adalah ATM mata uang kripto. Secara pribadi, saya tidak pernah berkesempatan untuk menguji solusi ini, karena tidak ada di negara saya. Tetapi metode ini bisa jadi sangat menarik, tergantung di mana Anda tinggal.

![BTC204](assets/fr/092.webp)

Masalah dengan ATM adalah bahwa ATM dilarang di beberapa negara, atau diatur dengan ketat di negara lain. Jika ATM memerlukan prosedur verifikasi identitas, maka ATM memiliki risiko yang sama dengan platform yang diatur oleh KYC. Di sisi lain, jika ATM mengizinkan transaksi tanpa verifikasi identitas untuk jumlah kecil, maka penggunaannya dapat menawarkan tingkat kerahasiaan yang sebanding dengan pertukaran uang P2P, sambil menghindari sebagian besar risiko yang terkait dengan jenis pertukaran ini.

Kerugian utama ATM adalah biaya penukaran yang sering kali tinggi, mulai dari beberapa persen hingga terkadang 15% dari jumlah yang ditukarkan.

### Kartu hadiah

Terakhir, saya juga ingin memperkenalkan kepada Anda sebuah solusi yang bekerja dengan baik untuk mereka yang ingin menggunakan bitcoin mereka setiap hari untuk melakukan pembelian daripada menjualnya terhadap mata uang fiat.

Cara terbaik untuk membelanjakan BTC tentu saja dengan menggunakan Bitcoin atau Lightning Network secara langsung untuk membeli barang atau jasa. Namun, di banyak negara, jumlah pedagang yang menerima Bitcoin masih terbatas. Alternatif praktisnya adalah dengan menggunakan kartu hadiah.

Beberapa platform yang tidak memerlukan prosedur KYC menawarkan kemungkinan untuk menukar bitcoin dengan kartu hadiah yang dapat digunakan di toko-toko besar. Ini termasuk [CoinsBee] (https://www.coinsbee.com/), [The Bitcoin Company] (https://thebitcoincompany.com/) dan [Bitrefill] (https://www.bitrefill.com/). Platform-platform ini memudahkan Anda untuk menggunakan bitcoin setiap hari, memberikan Anda akses ke berbagai macam produk dan layanan tanpa harus menukarkannya dengan mata uang fiat.

https://planb.network/tutorials/exchange/centralized/bitrefill-8c588412-1bfc-465b-9bca-e647a647fbc1

![BTC204](assets/fr/093.webp)

### Metode akuisisi lainnya

Cara lain untuk mendapatkan bitcoin sekaligus melindungi privasi Anda tentu saja termasuk, menambang. Untuk mulai menambang satoshi, Anda tidak perlu mengungkapkan identitas Anda; cukup temukan bukti kerja yang valid dan kirimkan ke jaringan. Jika Anda memilih untuk menambang di pool, beberapa pool memerlukan beberapa bentuk identifikasi, seperti KYC, sementara yang lain tidak.

Metode lainnya adalah bekerja dengan imbalan bitcoin. Metode akuisisi ini bisa jadi menarik, tetapi tingkat identifikasi yang diperlukan sangat bervariasi, tergantung pada situasinya.

*Untuk menulis bab ini, saya menggunakan kursus pelatihan BTC205 yang diberikan oleh [@pivi___] (https://x.com/pivi___) di Jaringan Plan ₿ (hanya tersedia dalam bahasa Prancis untuk saat ini)

## Konsolidasi, manajemen UTXO dan CIOH

<chapterId>d0486c8f-332d-402b-ae2e-949416752b9c</chapterId>


Salah satu aspek paling rumit dalam menjalankan portofolio penyimpanan mandiri adalah konsolidasi. Haruskah Anda melakukan konsolidasi? Apa gunanya? Berapa ukuran UTXO yang harus dihormati? Apa saja kompromi dalam hal kerahasiaan? Itulah yang akan kita bahas di bagian ini.

### Apa yang dimaksud dengan konsolidasi?

Bitcoin beroperasi seperti pasar lelang, dengan para penambang yang memberikan preferensi pada transaksi yang menawarkan biaya terendah. Akan tetapi, setiap blok memiliki bobot maksimum yang membatasi jumlah transaksi yang dapat dimasukkan. Karena sebuah blok diproduksi rata-rata setiap 10 menit, ruang yang tersedia di setiap blok adalah sumber daya yang langka.

Para penambang, yang aktivitasnya menghasilkan biaya yang signifikan dalam hal listrik, aset tetap, dan pemeliharaan, secara alami berusaha memaksimalkan profitabilitas mereka. Oleh karena itu, mereka cenderung memilih transaksi yang menghasilkan biaya tertinggi dibandingkan dengan bobotnya.

Tidak semua transaksi Bitcoin memiliki bobot yang sama. Transaksi yang memiliki lebih banyak input dan output akan memiliki bobot yang lebih besar. Sebagai contoh, mari kita bayangkan 2 transaksi:


- Transaksi A terdiri dari 1 input dan 1 output. Transaksi ini mengalokasikan 1.994 sat biaya dan memiliki bobot 141 vB;
- Transaksi B, transaksi yang lebih kompleks dengan 2 input dan 2 output, mengalokasikan 2.640 sat dalam biaya untuk bobot 220 vB.

![BTC204](assets/fr/094.webp)

Dalam contoh ini, walaupun transaksi B menawarkan total biaya yang lebih tinggi, penambang akan lebih memilih transaksi A, karena transaksi A menawarkan rasio yang lebih baik antara biaya dan bobot. Berikut adalah perhitungan untuk setiap transaksi, yang dinyatakan dalam sat per virtual byte (sat/vB):

```text
TXA : 1994 / 141 = 14 sats/vB
TXB : 2640 / 220 = 12 sats / vB
```

Ini berarti bahwa untuk setiap unit berat, transaksi A menawarkan lebih banyak biaya daripada transaksi B, meskipun transaksi B menawarkan lebih banyak biaya secara absolut.

![BTC204](assets/fr/095.webp)

Oleh karena itu, akan selalu lebih menarik bagi pengguna untuk menggunakan input sesedikit mungkin dalam transaksinya. Namun, Anda perlu mengonsumsi jumlah yang cukup untuk dapat memenuhi pembayaran output. Saat mengelola portofolio Anda, Anda harus memiliki UTXO yang cukup besar.

Prinsip konsolidasi adalah memanfaatkan periode ketika biaya Bitcoin rendah untuk menggabungkan UTXO yang lebih kecil menjadi satu UTXO yang lebih besar. Dengan cara ini, ketika biaya Bitcoin naik, Anda akan dapat melakukan transaksi dengan input minimum, dan karenanya menghabiskan lebih sedikit biaya secara absolut. Tujuannya adalah untuk mengantisipasi transaksi wajib yang harus dilakukan selama periode biaya tinggi.

![BTC204](assets/fr/096.webp)

Selain menghemat biaya transaksi, konsolidasi UTXO membantu mencegah pembentukan "debu". "Debu" mengacu pada UTXO yang nilainya dalam satuan sangat rendah sehingga tidak cukup untuk menutupi biaya transaksi yang diperlukan untuk membelanjakannya. Hal ini membuat UTXO ini tidak rasional secara ekonomi untuk digunakan selama biaya transaksinya masih tinggi. Dengan mengumpulkan UTXO Anda secara proaktif, Anda mencegahnya menjadi debu, memastikan bahwa semua dana Anda tetap dapat digunakan.

### Berapa ukuran minimum untuk UTXO Anda?

Saya terkadang ditanya berapa nilai minimum yang direkomendasikan untuk UTXO. Sayangnya, tidak ada jawaban yang universal, karena tergantung pada preferensi Anda dan kondisi pasar biaya. Namun, berikut ini adalah rumus yang dapat membantu Anda menentukan ambang batas yang sesuai dengan kebutuhan Anda:

$$
\frac {P \times F}T = M
$$

Dimana:


- p$ adalah bobot transaksi;
- $F$ mewakili tingkat biaya maksimum dalam satoshi per vbyte (sats/vB) yang Anda gunakan untuk melakukan lindung nilai;
- t$ adalah persentase biaya transaksi yang bersedia Anda bayarkan sehubungan dengan nilai total UTXO;
- m$ adalah jumlah minimum dalam satoshi untuk setiap UTXO.

Anggap saja Anda berencana untuk menanggung biaya untuk transaksi SegWit standar dengan 1 input dan 2 output, dengan berat 141 vB. Jika Anda melakukan hedging hingga 800 sat/vB, dan Anda bersedia mengeluarkan biaya paling banyak 12% dari nilai UTXO, maka perhitungannya adalah:

$$
\frac{141 \times 800}{0.12} = 940\ 000
$$

Dalam contoh ini, akan lebih bijaksana jika Anda menyimpan nilai minimum 940.000 sat untuk UTXO dalam portofolio Anda.

### Konsolidasi dan CIOH

Salah satu heuristik yang paling banyak digunakan dalam analisis blockchain adalah CIOH (*Common Input Ownership Heuristic*), yang mengasumsikan bahwa semua input ke transaksi Bitcoin adalah milik entitas yang sama. Prinsip utama dari konsolidasi adalah menggunakan beberapa UTXO sebagai input dan membuat satu UTXO sebagai output. Dengan demikian, konsolidasi memungkinkan ICOH untuk diterapkan.

![BTC204](assets/fr/097.webp)

Dalam praktiknya, ini berarti bahwa pengamat luar dapat menyimpulkan bahwa semua UTXO yang terkonsolidasi mungkin milik orang yang sama, dan output unik yang dihasilkan juga miliknya. Situasi ini dapat membahayakan kerahasiaan Anda dengan mengaitkan riwayat transaksi yang berbeda. Sebagai contoh, katakanlah saya menggabungkan 3 UTXO yang diperoleh melalui P2P dengan satu UTXO yang diperoleh melalui platform yang memerlukan KYC:

![BTC204](assets/fr/098.webp)

Dengan demikian, setiap entitas yang memiliki akses ke data platform bursa, termasuk lembaga pemerintah, akan dapat mengidentifikasi bahwa saya memiliki sejumlah BTC. Sebelumnya, UTXO ini tidak terhubung langsung dengan identitas saya; sekarang sudah terhubung. Terlebih lagi, UTXO ini mengungkapkan kepada semua sumber bahwa saya memiliki sejumlah bitcoin.

Dalam hal mengelola UTXO, pertimbangan ekonomi, yang mendorong konsolidasi untuk mengurangi biaya, bertentangan dengan praktik privasi yang baik, yang akan merekomendasikan untuk tidak pernah menggabungkan UTXO. Oleh karena itu, pilihan antara ekonomi dan kerahasiaan tergantung pada prioritas masing-masing pengguna.

Jika Anda dapat menghindari konsolidasi sambil mempertahankan UTXO yang substansial, itu sangat ideal. Untuk melakukan ini, optimalkan metode akuisisi Anda. Jika Anda membeli bitcoin di DCA, cobalah untuk mengatur jarak pembelian satu kali sebanyak mungkin untuk mengkonsolidasikan nilai pada UTXO yang lebih sedikit. Akan lebih mudah untuk mengelola pembelian satu kali sebesar €1.000 setiap 2 bulan, daripada pembelian €120 setiap minggu. Hal ini akan meminimalkan jumlah UTXO yang dihasilkan dan menyederhanakan pengelolaan portofolio Anda sekaligus menjaga kerahasiaan Anda.

Jika Anda harus menggabungkan bitcoin Anda, berikan preferensi terlebih dahulu untuk menggabungkan UTXO dari sumber yang sama. Sebagai contoh, menggabungkan 10 UTXO dari satu platform akan mempengaruhi kerahasiaan Anda lebih kecil dibandingkan dengan menggabungkan 5 UTXO dari platform A dengan 5 UTXO dari platform B. Jika penggabungan berbagai sumber tidak dapat dihindari, cobalah untuk memisahkannya berdasarkan karakteristiknya. Misalnya, kelompokkan UTXO yang diperoleh melalui KYC dalam satu transaksi, dan yang diperoleh melalui P2P dalam transaksi lainnya.

Bagaimanapun, jangan lupa bahwa konsolidasi apa pun pasti akan menyebabkan hilangnya kerahasiaan. Jadi, kaji dengan cermat kebutuhan untuk operasi ini dan potensi dampaknya terhadap privasi Anda, dengan mempertimbangkan CIOH.

## Praktik terbaik lainnya

<chapterId>b5216965-7d13-4ea1-9b7c-e292966a487b</chapterId>


Mari kita lihat beberapa praktik terbaik lainnya untuk mengoptimalkan privasi Anda di Bitcoin.

### Simpul yang lengkap

Memiliki bitcoin Anda dalam penitipan sendiri memang bagus, tetapi menggunakan node lengkap milik Anda sendiri lebih baik lagi! Inilah alasan mengapa memiliki node sendiri sangat penting untuk penggunaan Bitcoin yang berdaulat penuh:


- Resistensi terhadap penyensoran**: Transaksi Anda tidak dapat diblokir oleh siapa pun;
- Independensi dari pihak ketiga**: Anda tidak lagi bergantung pada layanan eksternal apa pun untuk memverifikasi data blockchain;
- Partisipasi aktif**: Anda dapat menentukan aturan validasi Anda sendiri dan berpartisipasi langsung dalam konsensus;
- Kontribusi jaringan**: Dengan menjalankan sebuah node, Anda membantu memperkuat dan mendistribusikan jaringan Bitcoin;
- Pendidikan teknis**: Mengelola sebuah node yang lengkap adalah cara terbaik untuk memperdalam pengetahuan teknis Anda tentang Bitcoin.

Selain manfaat-manfaat tersebut, menggunakan node yang lengkap juga meningkatkan kerahasiaan Anda ketika menyiarkan transaksi Anda. Ketika Anda mengeluarkan sebuah transaksi, transaksi tersebut pertama kali dibuat dan ditandatangani melalui dompet Anda. Untuk menyiarkannya di jaringan Bitcoin, transaksi tersebut harus diketahui oleh setidaknya satu node. Dengan menggunakan node Anda sendiri, Anda memiliki kontrol langsung atas distribusi ini, sehingga memperkuat kerahasiaan Anda dan membatasi risiko kebocoran data.

![BTC204](assets/fr/099.webp)

Jika Anda tidak memiliki simpul Bitcoin Anda sendiri, Anda akan dipaksa untuk menggunakan simpul pihak ketiga, seperti yang ditawarkan oleh penyedia perangkat lunak dompet Anda. Selain menyiarkan transaksi, dompet Anda membutuhkan akses ke berbagai informasi seperti transaksi yang tertunda, saldo yang terkait dengan alamat Anda, dan jumlah konfirmasi untuk transaksi Anda. Untuk mengakses semua data ini, Anda perlu melakukan kueri pada sebuah node.

![BTC204](assets/fr/100.webp)

Risiko utama ketika Anda tidak menggunakan node Bitcoin Anda sendiri adalah operator node pihak ketiga dapat mengamati aktivitas Anda di blockchain, atau bahkan membagikan informasi ini dengan entitas lain. Untuk membatasi risiko ini, solusi perantaranya adalah dengan menggunakan perangkat lunak dompet yang menyembunyikan koneksi Anda melalui Tor. Hal ini dapat mengurangi eksposur data Anda. Akan tetapi, solusi yang optimal adalah dengan memiliki node Bitcoin Anda sendiri dan menggunakannya untuk menyiarkan transaksi Anda. Tentu saja, Anda juga harus berhati-hati agar tidak membocorkan informasi apa pun melalui node Anda, tetapi itu adalah topik lain yang akan kita bahas di bagian selanjutnya.

Selain keuntungan yang jelas untuk privasi Anda, memiliki node lengkap Anda sendiri juga menjamin kebenaran data di blockchain, melindungi Anda dari penyensoran, dan memungkinkan Anda untuk berpartisipasi secara aktif dalam tata kelola Bitcoin. Dengan menggunakan node Anda sendiri, Anda menyumbangkan bobot ekonomi Anda pada rantai pilihan Anda, yang penting selama konflik di dalam komunitas, seperti selama Perang Blocksize dari tahun 2015 hingga 2017 misalnya. Jika terjadi fork, menggunakan node pihak ketiga dapat membuat Anda mendukung rantai yang tidak Anda inginkan, karena operator node membuat pilihan untuk Anda.

Seperti yang Anda lihat, demi kepentingan kerahasiaan dan kedaulatan individu, sangat penting untuk menjalankan dan menggunakan simpul lengkap Anda sendiri!

### Heuristik analisis yang menipu

Secara lebih luas, penting untuk memahami heuristik yang kita bicarakan di bagian sebelumnya, agar dapat menghindari atau menipu mereka dengan lebih baik. Mengadopsi serangkaian praktik terbaik bisa bermanfaat, bahkan jika mereka tidak penting. Praktik-praktik tersebut menawarkan lapisan perlindungan ekstra yang dapat menjadi penting dalam menjaga kerahasiaan saat menggunakan Bitcoin.

Saran pertama yang dapat saya berikan adalah berbaur dengan orang banyak. Pada Bitcoin, ini berarti menggunakan templat skrip yang paling banyak digunakan. Sebagai contoh, skrip P2WSH, yang sering digunakan untuk konfigurasi multisig SegWit V0, sangat jarang digunakan. Skrip ini tidak memungkinkan Anda untuk bersembunyi dalam kumpulan anonimitas yang besar. Hal yang sama berlaku untuk model yang lebih tua seperti P2PKH atau P2SH. Meskipun mereka banyak terdapat dalam set UTXO, mereka semakin jarang digunakan untuk transaksi baru.

Secara umum, lebih bijaksana untuk memilih standar skrip yang paling baru, asalkan standar tersebut telah diadopsi secara memadai. Jadi, jika pada tahun 2022, saya menyarankan untuk tidak menggunakan P2TR (Taproot) karena adopsinya yang rendah, pada tahun 2024, saya akan merekomendasikan untuk memilih jenis skrip ini sebagai gantinya, atau jika tidak, untuk skrip SegWit V0, karena jumlah transaksi yang menggunakan P2TR mulai mewakili proporsi yang sangat signifikan.

![BTC204](assets/fr/101.webp)

Sumber : [txstats.com](https://txstats.com/d/000000054/utxo-set-repartition-by-output-type)

Tips lain untuk menjaga kerahasiaan Anda adalah dengan mencoba melewati heuristik transaksi internal. Sebagai contoh, ketika melakukan pembayaran, Anda dapat mencoba untuk menghindari membuat output dengan jumlah yang bulat, karena hal ini dapat menandakan bahwa output lainnya merupakan valuta asing. Jika Anda perlu mengirim 100 ribu kepada seorang teman, pertimbangkan untuk mentransfer jumlah yang sedikit lebih tinggi untuk menghindari heuristik ini. Demikian pula, cobalah untuk tidak membuat output valuta asing yang tidak proporsional dalam kaitannya dengan pembayaran yang dilakukan, karena hal ini juga dapat mengungkapkan output mana yang mewakili valuta asing.

![BTC204](assets/fr/102.webp)

Terakhir, jika Anda melakukan transaksi Bitcoin secara teratur, pastikan Anda tidak selalu menyiarkannya pada waktu yang sama. Dengan menyebarkan siaran transaksi Anda sepanjang hari dan minggu, Anda tidak memberikan kesempatan kepada pengamat luar untuk mendeteksi pola temporal berbasis zona waktu yang dapat memperkuat analisis mereka.

Selain semua praktik yang baik untuk diterapkan setiap hari, ada metode yang lebih efektif untuk memutus ketertelusuran bitcoin Anda sepenuhnya. Ini termasuk, tentu saja, transaksi coinjoin, yang akan kita bahas secara mendalam di bagian selanjutnya.

# Memahami transaksi coinjoin

<partId>6d0bbf16-3714-4db1-9897-2d45019f6bdc</partId>

## Apa yang dimaksud dengan transaksi coinjoin?

<chapterId>0862bc6b-1c48-4aa4-b76d-4f547b469008</chapterId>


Setelah mempelajari dasar-dasar perlindungan privasi, sekarang kita akan melihat teknik-teknik yang lebih canggih yang bertujuan untuk secara aktif mempertahankan kerahasiaan Anda, khususnya dengan membuka riwayat bitcoin Anda. Di bagian selanjutnya, kita akan melihat sejumlah teknik kecil, tetapi pertama-tama, saya ingin memberi tahu Anda tentang coinjoin.

Coinjoin sering dianggap sebagai metode yang paling efektif untuk melindungi privasi pengguna Bitcoin. Namun, apa sebenarnya transaksi coinjoin itu? Mari kita cari tahu.

### Prinsip-prinsip dasar coinjoin

Coinjoin adalah sebuah teknik untuk mematahkan pelacakan bitcoin pada blockchain. Teknik ini didasarkan pada transaksi kolaboratif dengan struktur spesifik dengan nama yang sama: transaksi coinjoin.

Seperti yang telah kita lihat pada bagian pertama kursus ini, transaksi Bitcoin diketahui oleh semua pengguna melalui node mereka. Oleh karena itu, mudah untuk memeriksa rantai tanda tangan elektronik dari setiap koin dan mengamati sejarahnya. Ini berarti bahwa semua pengguna dapat mencoba menganalisis transaksi pengguna lain. Akibatnya, anonimitas pada tingkat transaksi tidak mungkin dilakukan. Akan tetapi, anonimitas dipertahankan pada tingkat identifikasi individu. Tidak seperti sistem perbankan konvensional, di mana setiap akun dihubungkan dengan identitas pribadi, pada Bitcoin, dana dihubungkan dengan pasangan kunci kriptografi (atau skrip), yang menawarkan kepada para pengguna sebuah bentuk pseudonimitas di balik pengenal kriptografi.

![BTC204](assets/fr/103.webp)

Kerahasiaan Bitcoin dirusak ketika pengamat luar dapat mengasosiasikan UTXO tertentu dengan pengguna yang teridentifikasi. Setelah asosiasi ini terbentuk, maka akan memungkinkan untuk melacak transaksi mereka dan menganalisis riwayat Bitcoin mereka. Coinjoin adalah sebuah teknik yang dikembangkan untuk mematahkan ketertelusuran UTXO, untuk menawarkan kepada para pengguna Bitcoin sebuah lapisan kerahasiaan pada tingkat transaksi.

Coinjoin memperkuat kerahasiaan pengguna Bitcoin dengan membuat analisis rantai menjadi lebih kompleks untuk pengamat eksternal. Strukturnya memungkinkan beberapa koin dari pengguna yang berbeda untuk digabungkan ke dalam satu transaksi, mengaburkan garis dan menyulitkan untuk menentukan hubungan antara alamat input dan output.

Penting untuk dipahami bahwa tujuan dari transaksi coinjoin adalah untuk memutus riwayat koin. Teknik ini tidak memberikan anonimitas permanen atau memblokir pelacakan bitcoin secara definitif, berlawanan dengan apa yang mungkin Anda pikirkan. Coinjoin hanya bertujuan untuk memutus riwayat pada titik di mana transaksi coinjoin dilakukan. Akan tetapi, sebelum dan sesudah operasi ini, koin tetap memiliki risiko yang sama dalam hal kerahasiaan.

![BTC204](assets/fr/104.webp)

### Bagaimana cara kerja coinjoin?

Prinsip coinjoin didasarkan pada pendekatan kolaboratif: beberapa pengguna yang ingin menggabungkan bitcoin mereka menyetorkan jumlah yang sama sebagai input untuk transaksi yang sama. Jumlah ini kemudian didistribusikan kembali dalam bentuk output dengan nilai yang sama kepada setiap pengguna.

![BTC204](assets/fr/105.webp)

Pada akhir transaksi, menjadi tidak mungkin untuk mengasosiasikan output tertentu dengan pengguna yang dikenal sebagai input. Tidak ada hubungan langsung antara input dan output, yang memutus hubungan antara pengguna dan UTXO mereka, serta riwayat setiap bagian.

![BTC204](assets/fr/106.webp)

Mari kita ambil contoh Alice. Dia ingin mengirim sekitar 100.000 satoshi kepada saudara perempuannya, Eve, untuk ulang tahunnya. Namun, Alice tidak ingin Eve dapat melacak riwayat transaksinya, karena dia tidak ingin mengungkapkan berapa banyak bitcoin yang dia miliki atau bagaimana dia mendapatkannya. Untuk itu, Alice memutuskan untuk menghapus riwayat UTXO-nya dengan transaksi coinjoin. Dia mengatur dengan Bob, Charles, David dan Frank untuk melakukan transaksi kolaboratif:


- Alice, Bob, Charles, David, dan Frank masing-masing memberikan UTXO sebesar 105.000 sat (dengan 5.000 sat untuk biaya penambangan) sebagai input ke dalam transaksi:

![BTC204](assets/fr/107.webp)


- Sebagai imbalan untuk mengkonsumsi input ini, masing-masing menghasilkan alamat kosong untuk membuat lima output identik masing-masing 100.000 sat. Masing-masing mengambil satu keluaran:

![BTC204](assets/fr/108.webp)


- Alice mendapati dirinya memiliki UTXO sebesar 100.000 sat yang sejarahnya tercampur aduk. Dia menggunakan UTXO ini dalam transaksi baru untuk mengirim jumlah tersebut kepada Eve untuk ulang tahunnya:

![BTC204](assets/fr/109.webp)


- Jika Eve mencoba menganalisis transaksi ini untuk mengekstrak informasi, ia akan dihadapkan pada transaksi coinjoin yang melibatkan Alice, Bob, Charles, David, dan Frank. Karena tidak dapat membedakan input mana yang menjadi milik siapa karena keseragaman jumlah, Eve tidak dapat melacak riwayat UTXO Alice, atau menentukan berapa banyak bitcoin yang dimiliki saudara perempuannya atau bagaimana dia memperolehnya:

![BTC204](assets/fr/110.webp)

Dalam hal ini, Alice telah menggunakan teknik coinjoin untuk meningkatkan kerahasiaan sehubungan dengan analisis retrospektif. Pada dasarnya, Alice melindungi dirinya sendiri dari kemungkinan analisis oleh Eve, yang akan mulai dari transaksi tertentu dan bekerja mundur melalui sejarah UTXO. Perlindungan terhadap analisis dari masa sekarang ke masa lalu ini dikenal sebagai anonset retrospektif. Kita akan melihat konsep ini secara lebih rinci di bab-bab terakhir bagian ini.

Namun, coinjoin juga menawarkan kemungkinan untuk memperkuat kerahasiaan dalam menghadapi analisis dari masa lalu ke masa sekarang, yang dikenal sebagai prospective anonset. Mari kita kembali ke contoh kita di mana Alice mengirimi Eve 98.000 sats untuk ulang tahunnya, tetapi dengan perannya dibalik. Sekarang mari kita bayangkan Eve yang mengkhawatirkan privasinya. Memang, Alice mungkin tergoda untuk melacak koin yang ia kirimkan kepada Eve untuk mengekstrak informasi darinya. Eve dapat menggabungkan UTXO yang baru saja ia terima dengan semua UTXO-nya yang lain, yang dapat mengungkapkan kepada Alice jumlah bitcoin yang ia miliki di dompetnya. Untuk menghindari hal ini, Eve juga dapat menghapus riwayat koin yang baru saja ia terima:


- Eve, Grace, Mallory, Oscar, dan Victor masing-masing memasukkan UTXO sebanyak 98.000 satoshi sebagai input untuk transaksi Bitcoin:

![BTC204](assets/fr/111.webp)


- Sebagai imbalan untuk menggunakan input ini, setiap pengguna memberikan alamat kosong yang akan digunakan untuk membuat 5 output dari 97.500 sat yang sama persis. Setiap pengguna mendapatkan satu keluaran:

![BTC204](assets/fr/112.webp)


- Eve sekarang memegang UTXO sebanyak 97.500 satoshi yang sejarahnya telah dipecahkan. Dia dapat menggunakannya tanpa rasa takut untuk melakukan transaksi di masa depan. Memang, jika Alice mencoba melacak bitcoin yang telah ia kirimkan kepada Eve, ia akan dihadapkan pada transaksi coinjoin. Dia tidak akan dapat menentukan UTXO keluar mana yang menjadi milik Eve. Analisis menjadi tidak mungkin dilakukan:

![BTC204](assets/fr/113.webp)

Pada contoh pertama, kita melihat bagaimana coinjoin dapat melindungi privasi sebuah ruangan dalam kaitannya dengan masa lalunya, dan pada contoh kedua, bagaimana coinjoin juga dapat mengamankan sejarah sebuah ruangan dalam kaitannya dengan masa depannya. Itulah mengapa saya menyebutkan bahwa coinjoin harus dilihat sebagai peristiwa sekali pakai yang menyegmentasikan bagian sejarah di kedua arah:

![BTC204](assets/fr/104.webp)

### Mixer, coinjoin, mixer... Apa bedanya?

Coinjoin terkadang digambarkan sebagai "pencampur", sebuah istilah yang ditolak oleh beberapa pengguna bitcoin, karena khawatir akan dikacaukan dengan pencampur kustodian. Namun, saya percaya bahwa kekhawatiran ini tidak berdasar, karena dalam konteks matematika, coinjoin mewujudkan konsep pencampuran dengan tepat.

Dalam bidang matematika secara umum, pencampuran mengacu pada sifat sistem dinamik di mana, setelah jangka waktu tertentu, semua bagian dari ruang awal secara teoritis dapat bercampur dengan bagian lainnya. Pencampuran menyiratkan bahwa posisi partikel atau keadaan suatu sistem berevolusi sedemikian rupa sehingga distribusi masa depannya tidak bergantung pada distribusi awalnya, sehingga mencapai keadaan di mana karakteristik keadaan awal terdistribusi secara seragam di seluruh ruang sistem. Inilah yang terjadi pada coinjoin dengan bitcoin. Jadi, menurut saya, coinjoin benar-benar merupakan metode pencampuran koin.

![BTC204](assets/fr/114.webp)

Di sisi lain, penting untuk membedakan coinjoin dengan shuffler. Shuffler adalah sebuah layanan di mana pengguna mengirimkan bitcoin mereka untuk dikocok. Layanan ini sangat populer pada tahun 2010-an, tetapi penggunaannya telah menurun karena dua kelemahan utama dibandingkan dengan coinjoin:


- Mereka mengharuskan pengguna untuk melepaskan hak asuh dana mereka selama proses pencampuran, yang membuat mereka terekspos pada risiko pencurian;
- Tidak ada jaminan bahwa mixer tidak akan mencatat detail transaksi, atau bahkan menjual informasi ini ke perusahaan analisis rantai.

![BTC204](assets/fr/115.webp)

Oleh karena itu, para pengguna saat ini lebih memilih coinjoin, karena memungkinkan mereka untuk tetap memegang kendali penuh atas dana mereka selama proses berlangsung. Peserta coinjoin tidak memiliki risiko bitcoin mereka dicuri oleh pihak lain yang terlibat. Mari kita lihat bagaimana semua ini dapat dilakukan di bab selanjutnya.

## Zerolink dan coinjoins chaumian

<chapterId>326c9654-b359-4906-b23d-d6518dd5dc3e</chapterId>


Privasi yang disediakan oleh coinjoin diperoleh dari ukuran grup tempat bagian kita disembunyikan. Ini berarti menemukan sebanyak mungkin peserta. Sangat mungkin untuk membuat coinjoin secara manual, dengan pengguna yang kita temukan sendiri, tetapi ini adalah proses yang rumit, dan tidak akan memberi Anda banyak keuntungan.

Inilah sebabnya mengapa koordinator coinjoin telah berkembang di Bitcoin. Peran mereka adalah untuk menghubungkan berbagai pengguna satu sama lain dan mengirimkan informasi yang dibutuhkan untuk menyelesaikan transaksi kolaboratif.

![BTC204](assets/fr/116.webp)

Namun, bagaimana kita dapat memastikan bahwa koordinator tidak pernah memegang bitcoin pengguna, dan terlepas dari fakta bahwa dia adalah orang yang membangun transaksi coinjoin, bagaimana kita dapat memastikan bahwa dia tidak dapat menghubungkan input dan output pengguna, yang dapat menyebabkan kebocoran kerahasiaan?

### Tanda tangan buta Chaum

Implementasi coinjoin modern menggunakan tanda tangan buta David Chaum untuk menghindari kebocoran informasi. Mari kita lihat sekilas bagaimana cara kerja tanda tangan buta ini.

Tanda tangan buta Chaum adalah bentuk tanda tangan digital di mana pemberi tanda tangan tidak mengetahui isi pesan yang ditandatanganinya. Tetapi tanda tangan tersebut dapat diverifikasi terhadap pesan aslinya. Teknik ini dikembangkan oleh kriptografer David Chaum pada tahun 1983.

![BTC204](assets/fr/117.webp)

Mari kita ambil contoh sebuah perusahaan yang ingin mengautentikasi dokumen rahasia, seperti kontrak, tanpa mengungkapkan isinya. Perusahaan menerapkan proses penyembunyian yang secara kriptografis mengubah dokumen asli dengan cara yang dapat dibalik. Dokumen yang telah dimodifikasi ini dikirim ke otoritas sertifikasi, yang membubuhkan tanda tangan buta tanpa mengetahui konten yang mendasarinya. Setelah menerima dokumen yang ditandatangani, perusahaan membuka kedok tanda tangan tersebut. Hasilnya adalah dokumen asli yang diautentikasi oleh tanda tangan otoritas, tanpa otoritas pernah melihat konten aslinya.

Oleh karena itu, tanda tangan buta Chaum dapat mengesahkan keaslian dokumen tanpa mengetahui isinya, sehingga menjamin kerahasiaan data pengguna dan integritas dokumen yang ditandatangani.

### Chaumian coinjoins

Yang disebut dengan coinjoin "Chaumian" menggabungkan penggunaan Tor dan tanda tangan buta David Chaum untuk memastikan bahwa koordinator tidak dapat mengetahui output mana yang dimiliki oleh pengguna yang mana.

Proses konstruksi transaksi coinjoin melibatkan 3 tahap utama: registrasi input, registrasi output, dan tanda tangan transaksi. Mari kita lihat proses ini melalui contoh Alice, salah satu peserta coinjoin. Semua peserta lainnya mengikuti langkah yang sama seperti Alice, masing-masing dengan caranya sendiri.

**Langkah 1: Masukkan pendaftaran


- Alice mengirimkan kepada koordinator UTXO yang ingin ia gunakan sebagai input untuk transaksi, serta alamat penerima terselubung yang ingin ia gunakan sebagai output untuk menerima bitcoinnya. Oleh karena itu, koordinator tidak memiliki cara untuk mengetahui alamat Alice. Ia hanya melihat versi terselubungnya:

![BTC204](assets/fr/118.webp)


- Koordinator memeriksa keabsahan input, kemudian menandatangani alamat terselubung Alice dengan kunci pribadinya. Dia mengembalikan tanda tangan yang sudah ditandatangani kepada Alice:

![BTC204](assets/fr/119.webp)

**Langkah 2: Registrasi keluaran**


- Alice dapat membuka kedok alamatnya, yang sekarang ditandatangani oleh kunci pribadi koordinator. Dia akan membuat koneksi baru dengan identitas Tor yang berbeda. Koordinator tidak dapat mengidentifikasi bahwa Alice yang terhubung dengan identitas baru ini:

![BTC204](assets/fr/120.webp)


- Alice mengirimkan alamat dan tanda tangan yang telah dibuka kepada koordinator (yang masih belum tahu bahwa itu adalah Alice):

![BTC204](assets/fr/121.webp)

**Langkah 3: Menandatangani transaksi**


- Dengan cara yang sama, koordinator mengambil keluaran yang tidak disamarkan dari semua peserta. Berkat tanda tangan yang terkait, ia dapat memeriksa bahwa setiap output yang dikirimkan secara anonim telah ditandatangani oleh kunci pribadinya sebelumnya, sehingga menjamin keabsahannya. Dia kemudian siap untuk membuat transaksi coinjoin dan mengirimkannya kepada para peserta untuk ditandatangani:

![BTC204](assets/fr/122.webp)


- Alice, seperti peserta lainnya, memeriksa apakah input dan outputnya sudah dimasukkan dengan benar ke dalam transaksi yang dibuat oleh koordinator. Jika semuanya memuaskan, ia mengirimkan tanda tangan yang membuka skrip inputnya kepada koordinator:

![BTC204](assets/fr/123.webp)


- Setelah mengumpulkan tanda tangan dari semua peserta coinjoin, koordinator dapat menyiarkan transaksi tersebut di jaringan Bitcoin, sehingga dapat ditambahkan ke dalam blok.

Dalam sistem ini, koordinator tidak dapat menghubungkan input ke output tertentu. Terlebih lagi, dia tidak dapat menggunakan dana peserta, karena dia tidak pernah memiliki akses ke kunci pribadi yang diperlukan untuk membuka UTXO mereka. Sepanjang proses, hingga akhir langkah 3, dia juga tidak memiliki akses ke tanda tangan. Ketika Alice dan peserta lainnya menandatangani transaksi global, setelah memeriksa bahwa semuanya sudah benar, koordinator tidak dapat lagi memodifikasi transaksi, termasuk outputnya, tanpa membatalkannya. Hal ini mencegah koordinator untuk mencuri bitcoin.

Akhirnya, ketika mendaftarkan hasil transaksinya dalam transaksi, pengguna coinjoin ingin mendapatkan jaminan yang serupa dengan warga negara yang memberikan suara dalam pemilu. Terdapat dualitas antara aspek publik dan privat dari tindakan ini. Di satu sisi, ada hal yang ingin Anda jaga kerahasiaannya: untuk pemilih, dia tidak ingin surat suaranya dikaitkan dengan identitasnya; untuk pengguna coinjoin, dia tidak ingin outputnya dikaitkan dengan inputnya. Memang, jika koordinator, atau pihak lain, berhasil membuat hubungan antara input dan output, coinjoin kehilangan semua kepentingannya. Seperti yang telah dijelaskan di atas, coinjoin harus berfungsi sebagai jeda dalam sejarah koin. Perhentian ini terjadi karena ketidakmungkinan untuk menghubungkan input tertentu dengan output tertentu dalam transaksi coinjoin (prospective anonset) dan sebaliknya (retrospective anonset).

Di sisi lain, ada aspek publik: pemilih ingin memastikan bahwa surat suaranya dimasukkan ke dalam kotak suara; demikian pula, pengguna coinjoin ingin memastikan bahwa outputnya dimasukkan ke dalam transaksi coinjoin. Memang, peserta coinjoin benar-benar harus dapat memverifikasi keberadaan output mereka sebelum menandatangani transaksi, jika tidak, koordinator dapat mencuri dana.

Kedua aspek publik dan privat ini, yang dimungkinkan oleh penggunaan tanda tangan buta David Chaum, yang menjamin para peserta dalam coinjoin Chaumian bahwa bitcoin mereka tidak akan dicuri, dan dana mereka tidak dapat dilacak.

### Siapa yang menemukan konsep coinjoin?

Sulit untuk mengatakan dengan pasti siapa yang pertama kali memperkenalkan ide coinjoin ke Bitcoin, dan siapa yang memunculkan ide untuk menggunakan tanda tangan buta David Chaum dalam konteks ini. Sering kali dianggap bahwa Gregory Maxwell yang pertama kali menyebutkannya dalam [pesan di BitcoinTalk pada tahun 2013] (https://bitcointalk.org/index.php?topic=279249.0):

> *"Menggunakan tanda tangan buta Chaum: Pengguna masuk dan memberikan input (dan bertukar alamat) serta versi kriptografi yang dibutakan dari alamat yang ingin mereka kirimkan; server menandatangani token dan mengirimkannya kembali. Pengguna terhubung kembali secara anonim, membuka kedok alamat keluaran mereka dan mengirimkannya kembali ke server. Server dapat melihat bahwa semua output telah ditandatangani olehnya dan, akibatnya, semua output berasal dari peserta yang valid. Kemudian, orang-orang terhubung kembali dan masuk
Maxwell, G. (2013, Agustus 22). *CoinJoin: Privasi Bitcoin untuk dunia nyata*. Forum BitcoinTalk. https://bitcointalk.org/index.php?topic=279249.0

![BTC204](assets/fr/124.webp)

Akan tetapi, ada penyebutan lain yang lebih awal, baik untuk tanda tangan Chaum sebagai bagian dari pencampuran, tetapi juga untuk coinjoin. [Pada bulan Juni 2011, Duncan Townsend mempresentasikan di BitcoinTalk](https://bitcointalk.org/index.php?topic=12751.0) sebuah mixer yang menggunakan tanda tangan Chaum dengan cara yang sangat mirip dengan coinjoin Chaumian modern.

Dalam thread yang sama, kita dapat menemukan [pesan dari hashcoin sebagai tanggapan terhadap Duncan Townsend] (https://bitcointalk.org/index.php?topic=12751.msg315793#msg315793) untuk meningkatkan mixernya. Proses yang dijelaskan dalam pesan ini adalah persis seperti apa yang dimaksud dengan coinjoin. Penyebutan sistem yang serupa juga dapat ditemukan di [pesan dari Alex Mizrahi pada tahun 2012] (https://gist.github.com/killerstorm/6f843e1d3ffc38191aebca67d483bd88#file-laundry), ketika dia menasihati para pencipta Tenebrix, salah satu altcoin pertama yang menjadi dasar pembuatan Litecoin. Bahkan istilah "coinjoin" sendiri dikatakan tidak diciptakan oleh Greg Maxwell, tetapi berasal dari ide Peter Todd.

![BTC204](assets/fr/125.webp)

### Zerolink

Zerolink adalah sebuah protokol pencampuran yang komprehensif yang menggabungkan coinjoins Chaumian dan berbagai strategi untuk melindungi anonimitas pengguna dari beberapa bentuk analisis rantai, khususnya dengan meminimalisir kesalahan yang berhubungan dengan manajemen portofolio. Protokol ini [diperkenalkan oleh nopara73 dan TDevD pada tahun 2017] (https://github.com/nopara73/ZeroLink/blob/master/README.md).

![BTC204](assets/fr/126.webp)

Seperti namanya, prinsip di balik Zerolink adalah menciptakan transaksi coinjoin yang memastikan bahwa hubungan antara input dan output tidak dapat dilacak. Hal ini dicapai dengan memastikan bahwa semua output memiliki jumlah yang identik.

![BTC204](assets/fr/127.webp)

Langkah pencegahan penting yang diambil oleh Zerolink adalah menjaga agar UTXO yang belum tercampur benar-benar terpisah dari UTXO yang sudah tercampur dengan menggunakan set kunci kriptografi yang terpisah, atau bahkan portofolio yang terpisah. Hal ini membedakan dompet "*pre-mix*", yang ditujukan untuk komponen sebelum pencampuran, dari dompet "*post-mix*", yang diperuntukkan bagi komponen yang telah dicampur.

![BTC204](assets/fr/128.webp)

Pemisahan UTXO yang ketat ini berfungsi terutama untuk mencegah hubungan yang tidak disengaja antara UTXO campuran dan UTXO yang tidak tercampur. Memang, jika hubungan seperti itu terjadi, efektivitas coinjoin pada UTXO campuran dibatalkan tanpa disadari oleh pengguna, sehingga membahayakan kerahasiaan UTXO yang sejarahnya dikiranya telah rusak. Tautan ini dapat terjadi baik melalui penggunaan ulang alamat pada pengamanan UTXO campuran dengan yang tidak tercampur, atau melalui penerapan CIOH (_Common-Input-Ownership Heuristic_), jika pengguna menggunakan UTXO campuran dan yang tidak tercampur sebagai input untuk transaksi yang sama. Dengan memisahkan portofolio pra-campuran dan pasca-campuran, kami menghindari asosiasi yang tidak disengaja dan melindungi pengguna dari kesalahan yang tidak disengaja.

![BTC204](assets/fr/129.webp)

Pemisahan ini juga menawarkan kemungkinan penerapan aturan yang berbeda antara portofolio pra-campuran dan pasca-pencampuran pada tingkat perangkat lunak portofolio. Misalnya, dalam portofolio pasca-pencampuran, perangkat lunak dapat melarang penggabungan UTXO ke dalam input untuk mencegah penerapan CIOH, yang akan membahayakan anonset pengguna. Hal ini juga memungkinkan untuk menstandarkan penggunaan skrip dan opsi transaksi (seperti pelaporan RBF, misalnya) untuk mencegah identifikasi dengan sidik jari dompet.

Saat ini, Whirlpool merupakan satu-satunya implementasi coinjoin yang menerapkan protokol Zerolink secara ketat. Di bab selanjutnya, kita akan melihat berbagai implementasi coinjoin yang ada, serta kelebihan dan kekurangan masing-masing.

## Implementasi Coinjoin

<chapterId>e37ed073-9498-4e4f-820b-30951e829596</chapterId>


*Pada tahun 2024, kita akan menyaksikan perubahan besar pada alat yang tersedia untuk pengguna yang ingin membuat coinjoin di Bitcoin. Saat ini kita sedang berada di titik balik, dan pasar coinjoin sedang mengalami restrukturisasi besar-besaran. Bab ini pasti akan diperbarui seiring berjalannya waktu

Untuk saat ini, ada 3 implementasi coinjoin yang berbeda pada Bitcoin:


- Pusaran air;
- Wabisabi;
- JoinMarket.

Setiap implementasi ini bertujuan untuk memecahkan sejarah UTXO melalui transaksi coinjoin. Akan tetapi, mekanismenya sangat bervariasi. Oleh karena itu, penting untuk memahami cara kerja masing-masing, sehingga Anda dapat memilih opsi yang paling sesuai dengan kebutuhan Anda.

### JoinMarket

JoinMarket, yang didirikan pada tahun 2015 oleh Adam Gibson dan Chris Belcher, terlihat jelas berbeda dari implementasi coinjoin lainnya berkat modelnya yang unik dalam menghubungkan para pengguna. Sistem ini didasarkan pada pasar pertukaran P2P di mana beberapa pengguna, "pembuat", membuat bitcoin mereka tersedia untuk pencampuran, sementara yang lain, "pengambil", menggunakan uang tunai ini untuk membuat coinjoin dengan imbalan biaya.

![BTC204](assets/fr/130.webp)

Dalam model ini, "pembuat" menyediakan bitcoin mereka untuk "pengambil" dan menerima bayaran untuk layanan mereka. Pengambil, pada gilirannya, membayar untuk menggunakan bitcoin pembuat untuk melakukan transaksi koin bersama mereka sendiri. Biaya layanan bervariasi sesuai dengan peran yang diambil: "pembuat" mengumpulkan biaya untuk menawarkan likuiditas, sementara "pengambil" membayar biaya. Pasar beroperasi secara bebas, tanpa syarat penggunaan.

Salah satu kelemahan utama JoinMarket adalah kerumitan penggunaannya, yang membutuhkan tingkat kenyamanan tertentu dengan terminal untuk mengoperasikannya secara efektif. Meskipun kerumitan ini tidak menjadi hambatan bagi pengguna berpengalaman, namun mungkin membatasi akses ke masyarakat umum. Namun demikian, pengenalan antarmuka web yang disebut JAM baru-baru ini, telah membuatnya sedikit lebih mudah digunakan.

![BTC204](assets/fr/131.webp)

Sumber : [JAM] (https://github.com/joinmarket-webui/jam/blob/devel/docs/assets/screenshot-dark.webp)

Namun, hambatan teknis tetap menjadi kendala utama. Dalam ekosistem coinjoin, di mana kerahasiaan diperkuat oleh jumlah partisipan, batasan apa pun yang mengurangi aksesibilitas secara langsung memengaruhi likuiditas yang tersedia, yang merupakan faktor penting dalam efisiensi campuran. Bitcoin, yang sudah menjadi ceruk dalam transaksi keuangan, melihat penggunaan coinjoin sebagai sub-ceruk, dan JoinMarket mewakili bagian yang lebih khusus lagi, yang oleh karena itu membatasi potensinya untuk meningkatkan anonset penggunanya.

Terlepas dari model penghubung P2P yang inovatif untuk coinjoiners, JoinMarket memiliki beberapa kelemahan yang signifikan, terutama dalam hal struktur transaksional. Tidak seperti implementasi lain seperti Whirlpool, JoinMarket tidak menjamin kesetaraan yang sempurna antara output, dan memungkinkan untuk melacak hubungan deterministik antara input dan output. Selain itu, ia tidak memiliki alat untuk mencegah bagian-bagian yang sudah tercampur agar tidak tercampur lagi, yang dapat membahayakan kerahasiaan yang diinginkan oleh pengguna.

Akhirnya, meskipun konsep JoinMarket menarik, terutama bagi mereka yang tertarik dengan pasar likuiditas yang dinamis, kelemahan struktural dan kerumitan teknisnya membuatnya, menurut pendapat saya, kurang menarik bagi para pemula dan ahli yang mencari implementasi coinjoin.

### Wabisabi

Wabisabi adalah implementasi coinjoin lainnya, dengan pendekatan yang memusatkan koordinasi transaksi. Model ini digagas oleh Ádám Ficsór (nopara73), Yuval Kogman, Lucas Ontivero, dan István András Seres pada tahun 2021, dan diintegrasikan ke dalam perangkat lunak Wasabi 2.0 pada tahun berikutnya. Wabisabi merupakan evolusi dari model coinjoin perangkat lunak Wasabi yang diluncurkan pada tahun 2018.

![BTC204](assets/fr/132.webp)

Menjelang akhir tahun 2010, Wasabi mengadopsi struktur transaksi coinjoin yang sangat berbeda dengan Whirlpool. Wasabi menggunakan transaksi coinjoin yang sangat besar yang melibatkan lusinan partisipan untuk meningkatkan anonset para pesertanya. Sebaliknya, Whirlpool memilih beberapa transaksi kecil, memungkinkan anonset tumbuh secara eksponensial dengan setiap siklus.

Metode manajemen bursa juga membedakan kedua implementasi tersebut. Dengan Whirlpool, valuta asing dikecualikan dan diisolasi dari UTXO sebelum siklus coinjoin berkat TX0, sebuah konsep yang akan saya jelaskan lebih lanjut di bab berikutnya. Dengan Wasabi, di sisi lain, valuta asing membentuk salah satu output dari transaksi coinjoin, mempertahankan hubungan deterministik antara input dan output tertentu.

![BTC204](assets/fr/133.webp)

Dengan Wabisabi, Wasabi versi 2.0 telah mengadaptasi pendekatannya terhadap coinjoin agar sesuai dengan Whirlpool. Meskipun transaksi coinjoin masih sangat besar, sekarang dimungkinkan untuk melakukan beberapa siklus yang berurutan, mengikuti model Whirlpool. Perhatian khusus juga diberikan pada manajemen nilai tukar: tidak seperti Wasabi 1.0, di mana nilai tukar secara langsung terkait dengan input pengguna, Wabisabi berusaha untuk membagi nilai tukar menjadi beberapa jumlah kecil, dibagi ke dalam denominasi yang sama untuk semua peserta.

Mari kita ilustrasikan hal ini dengan contoh sederhana yang hanya melibatkan 2 pengguna: Alice ingin menggabungkan 115.000 satoshi dan Bob, 210.000 satoshi. Dengan mengabaikan biaya, dengan Wasabi 1.0, transaksi coinjoin akan menghasilkan 3 output 100.000 satoshi, ditambah 1 pertukaran 15.000 satoshi untuk Alice dan 1 pertukaran 10.000 satoshi untuk Bob. Output dari pertukaran masih akan terhubung dengan input:

![BTC204](assets/fr/134.webp)

Di bawah Wabisabi, transaksi yang sama akan menghasilkan 3 output 100.000 sat dan 5 output 5.000 sat, sehingga menyebarkan pertukaran sehingga tidak dapat secara langsung dikaitkan dengan input tertentu:

![BTC204](assets/fr/135.webp)

Secara pribadi, saya menemukan bahwa manajemen valuta asing Wabisabi memiliki beberapa risiko yang dapat mengganggu keefektifannya dalam hal kerahasiaan:


- Ketika seorang pengguna menyumbangkan UTXO yang secara signifikan lebih besar daripada peserta lain, dia pasti akan mendapatkan jumlah pertukaran yang akan ditautkan ke inputnya. Hal ini bertentangan dengan tujuan awal protokol ini, yaitu untuk menghilangkan semua pertukaran yang dapat diidentifikasi;
- Penggandaan denominasi dengan tujuan memecah-mecah pertukaran secara paradoks dapat merugikan efisiensi pencampuran. Proses ini dapat menyebabkan berkurangnya anonset untuk keluaran tertentu, karena keluaran tersebut menjadi lebih mudah diidentifikasi;
- Metode ini juga menghasilkan UTXO bernilai rendah yang menimbulkan masalah manajemen bagi pengguna. UTXO kecil ini, jika terlalu mahal untuk dibelanjakan dalam kaitannya dengan nilainya, dapat menjadi "debu". Fenomena ini membuat pengguna menggabungkan beberapa UTXO menjadi input untuk transaksi di masa mendatang, atau mengkonsolidasikannya. Dalam kedua kasus tersebut, karena adanya CIOH, hal ini dapat mengurangi anonset yang diperoleh, atau sepenuhnya membatalkan manfaat kerahasiaan yang diperoleh dari koin awal.

Tidak seperti Whirlpool, yang mengimplementasikan protokol ZeroLink yang memastikan pemisahan yang ketat antara UTXO pra-campuran dan pasca-campuran, Wabisabi tidak mempertahankan pemisahan yang ketat ini. Ada juga masalah penggunaan ulang alamat oleh beberapa pelanggan Wasabi, yang jelas sangat merugikan pengguna.

Di Wasabi versi 2.0, kebijakan biaya coinjoin yang baru telah diterapkan. Mulai sekarang, biaya koordinator ditetapkan sebesar 0,3% untuk UTXO di atas 0,01 bitcoin, sedangkan untuk UTXO yang lebih kecil, biaya ini ditawarkan secara penuh. Selain itu, remix untuk UTXO yang lebih kecil ini tidak dikenai biaya, meskipun biaya penambangan tetap dibayarkan oleh pengguna untuk semua transaksi, termasuk remix.

Hal ini berbeda dengan kebijakan Whirlpool, di mana biaya tetap, terlepas dari ukuran anonset yang diperoleh. Dengan Wasabi 2.0, meskipun biaya koordinator dibebaskan untuk UTXO kecil, pengguna masih harus membayar biaya penambangan untuk semua transaksi, termasuk remix.

Saat saya menulis kalimat-kalimat ini, penggunaan Wabisabi telah menjadi jauh lebih kompleks sebagai akibat dari kejadian-kejadian yang terjadi baru-baru ini. Menyusul penangkapan para pendiri Samourai Wallet, zkSNACKs, perusahaan yang mendanai dan mengelola pengembangan Wasabi, mengumumkan bahwa layanan koordinator coinjoin akan dihentikan pada 1 Juni 2024. Koordinator ini, yang diatur secara default di Wasabi, bertanggung jawab atas sebagian besar likuiditas.

Dengan penghentian koordinator utama ini, pengguna sekarang harus terhubung ke koordinator baru yang independen. Perubahan ini menimbulkan sejumlah kekhawatiran: di satu sisi, koordinator baru mungkin tidak memiliki likuiditas yang cukup, sehingga mengurangi keefektifan coinjoin dalam hal kerahasiaan. Di sisi lain, ada risiko bertemu dengan koordinator yang jahat. Situasi ini menambah risiko baru yang signifikan bagi mereka yang ingin menggunakan Wabisabi.

Di luar masalah teknis, keputusan zkSNACKs, perusahaan di balik Wasabi, untuk menggunakan layanan perusahaan analisis string untuk menyaring peserta coinjoin menimbulkan pertanyaan etis dan strategis yang serius. Ide awalnya adalah untuk mencegah penggunaan coinjoin di Wasabi oleh para penjahat, sebuah langkah yang mungkin terlihat sah. Akan tetapi, hal ini menimbulkan sebuah paradoks: membayar biaya kepada koordinator yang misi utamanya adalah memperkuat kerahasiaan pengguna, hanya untuk mendanai sebuah perusahaan yang bertujuan untuk mengkompromikan kerahasiaan tersebut.

Yang lebih mengkhawatirkan lagi adalah prinsip penyaringan, yang sangat kontras dengan filosofi Bitcoin yang menawarkan sistem keuangan yang terbuka dan tidak disensor. Meskipun mungkin terlihat dibenarkan untuk mengecualikan aktivitas kriminal, penyaringan ini juga dapat mempengaruhi individu yang tindakannya, meskipun diklasifikasikan sebagai ilegal dalam konteks tertentu, dapat dibenarkan secara moral atau bermanfaat secara sosial. Contoh Edward Snowden dengan sempurna menggambarkan dikotomi ini: dianggap sebagai penjahat oleh beberapa pemerintah karena pengungkapannya, dia dilihat oleh pemerintah lain sebagai whistleblower yang bertindak untuk kepentingan publik. Kerumitan ini menggarisbawahi potensi bahaya penyaringan yang, meskipun bertujuan baik, pada akhirnya dapat merusak hak dan keamanan pengguna yang sah. Saya juga bisa saja menyebutkan aktivis dan jurnalis yang dianiaya di bawah rezim otoriter tertentu.

Seperti yang sudah Anda ketahui sekarang, preferensi saya adalah model Whirlpool untuk coinjoin di Bitcoin. Sistem ini menonjol karena ketelitiannya dan menawarkan jaminan kerahasiaan yang unggul. Sistem ini juga merupakan satu-satunya yang menawarkan campuran yang dianggap sempurna dalam konteks matematika. Menurut saya, model ini mewakili masa depan coinjoin di Bitcoin. Saya mengundang Anda untuk menjelajahi model ini secara lebih mendalam di bab selanjutnya.

## Cara kerja Whirlpool

<chapterId>bdbd7109-e36d-4b4f-a3c6-928df4e9bfda</chapterId>


Yang membedakan Whirlpool dengan metode coinjoin lainnya adalah penggunaan transaksi "_ZeroLink_", yang memastikan bahwa tidak ada hubungan teknis yang mungkin terjadi antara semua input dan output. Perpaduan sempurna ini dicapai melalui struktur di mana setiap peserta memberikan jumlah input yang sama (dengan pengecualian biaya penambangan), menghasilkan output dengan jumlah yang sama persis.

Pendekatan yang ketat terhadap input ini memberikan fitur unik pada transaksi coinjoin Whirlpool: tidak adanya hubungan deterministik antara input dan output. Dengan kata lain, setiap output memiliki probabilitas yang sama untuk dikaitkan dengan peserta mana pun, relatif terhadap semua output lain dalam transaksi.

![BTC204](assets/fr/136.webp)

### Cara kerja Whirlpool

Awalnya, jumlah peserta di setiap coinjoin Whirlpool dibatasi hingga 5 orang, dengan 2 pendatang baru dan 3 remixer (kami akan menjelaskan konsep ini nanti). Namun, peningkatan biaya transaksi on-chain yang diamati pada tahun 2023 mendorong tim Samourai untuk memikirkan kembali model mereka untuk meningkatkan kerahasiaan sekaligus mengurangi biaya. Dengan demikian, dengan mempertimbangkan situasi pasar biaya dan jumlah peserta, koordinator sekarang dapat mengatur coinjoin yang terdiri dari 6, 7, atau 8 peserta. Sesi yang disempurnakan ini dikenal sebagai "Surge Cycles". Penting untuk dicatat bahwa, apa pun konfigurasinya, selalu hanya ada 2 peserta baru di coinjoin Whirlpool.

Dengan demikian, transaksi Whirlpool dicirikan oleh jumlah input dan output yang identik, yang dapat berupa :


- 5 input dan 5 output;

![BTC204](assets/fr/137.webp)


- 6 input dan 6 output;

![BTC204](assets/fr/138.webp)


- 7 input dan 7 output;

![BTC204](assets/fr/139.webp)


- 8 input dan 8 output.

![BTC204](assets/fr/140.webp)

Model Whirlpool didasarkan pada transaksi coinjoin kecil. Tidak seperti Wabisabi dan JoinMarket, di mana ketahanan anonset didasarkan pada volume partisipan dalam satu siklus (atau beberapa siklus), Whirlpool bergantung pada urutan beberapa siklus kecil.

Dalam model ini, pengguna membayar biaya hanya ketika mereka pertama kali bergabung dengan pool, sehingga mereka dapat berpartisipasi dalam banyak remix tanpa biaya tambahan. Pendatang baru membayar biaya penambangan untuk remixer.

Dengan setiap tambahan coinjoin di mana sebuah karya berpartisipasi, serta rekan-rekannya yang ditemui di masa lalu, anonset akan tumbuh secara eksponensial. Tujuannya adalah untuk mengambil keuntungan dari remix gratis ini, yang, setiap kali terjadi, berkontribusi untuk memperkuat kepadatan anonset yang terkait dengan setiap bagian yang dicampur.

![BTC204](assets/fr/141.webp)

Whirlpool telah dirancang dengan mempertimbangkan dua persyaratan penting:


- Aksesibilitas implementasi pada perangkat seluler, mengingat bahwa Samourai Wallet adalah aplikasi ponsel pintar yang pertama dan terutama;
- Siklus remix yang cepat untuk mendorong peningkatan anonset yang signifikan.

Keharusan ini memandu pilihan yang dibuat oleh pengembang Samourai Wallet dalam mendesain Whirlpool, membuat mereka membatasi peserta dalam jumlah yang terbatas per siklus. Terlalu sedikit akan mengganggu efisiensi coinjoin, secara drastis mengurangi anonset yang dihasilkan per siklus, sementara terlalu banyak akan menimbulkan masalah manajemen pada aplikasi seluler dan menghambat aliran siklus.

Terakhir, tidak perlu memiliki jumlah peserta yang banyak per coinjoin di Whirlpool, karena anonset dibuat berdasarkan akumulasi beberapa siklus coinjoin. Prinsip yang paling penting di sini adalah homogenitas UTXO dari semua peserta, karena hal ini memastikan pencampuran yang sempurna, dan oleh karena itu mendapatkan manfaat penuh dari siklus pencampuran dan remix.

### Kumpulan dan biaya koin bersama

Agar beberapa siklus ini dapat meningkatkan anonset dari bagian campuran, diperlukan kerangka kerja tertentu untuk membatasi jumlah UTXO yang digunakan. Pusaran air mendefinisikan kolam yang berbeda.

Sebuah pool mewakili sekelompok pengguna yang ingin bergabung bersama, yang menyepakati jumlah UTXO yang akan digunakan untuk mengoptimalkan proses penggabungan sambil mempertahankan homogenitas bagian yang sempurna. Setiap pool menetapkan jumlah UTXO tetap, yang harus dipatuhi oleh pengguna untuk dapat berpartisipasi. Jadi, untuk membuat coinjoin dengan Whirlpool, Anda perlu memilih pool. Berikut ini adalah pool yang tersedia saat ini:


- 0.5 bitcoin ;
- 0.05 bitcoin ;
- 0.01 bitcoin ;
- 0.001 bitcoin (= 100.000 satoshi).

Ketika Anda memasuki sebuah pool dengan bitcoin Anda, bitcoin tersebut akan dibagi untuk menghasilkan UTXO yang benar-benar homogen dengan peserta lain dalam pool tersebut. Setiap pool memiliki batas maksimum, jadi untuk jumlah yang melebihi batas ini, Anda harus membuat dua entri terpisah ke dalam pool yang sama, atau pindah ke pool lain dengan jumlah yang lebih tinggi:

| Pool (bitcoin) | Jumlah maksimum per entri (bitcoin)

|----------------|--------------------------------------|

| 0,5 | 35 |

| 0,05 | 3,5 |

| 0,01 | 0,7 |

| 0,001 | 0,025 |

Sebuah UTXO dianggap sebagai bagian dari pool ketika sudah siap untuk diintegrasikan ke dalam koin bersama. Namun, ini tidak berarti bahwa pengguna kehilangan kepemilikannya. Seperti yang telah kita lihat pada bab-bab pertama di bagian ini, melalui berbagai siklus pencampuran, Anda tetap memegang kendali penuh atas kunci Anda dan, akibatnya, atas bitcoin Anda. Inilah yang membedakan teknik coinjoin dengan teknik pencampuran terpusat lainnya.

Untuk bergabung dengan pool coinjoin, Anda perlu membayar biaya layanan dan biaya penambangan. Biaya layanan ditetapkan untuk setiap pool dan dimaksudkan untuk membayar tim yang bertanggung jawab atas pengembangan dan pemeliharaan Whirlpool.

Biaya layanan untuk penggunaan Whirlpool hanya dibayarkan satu kali saat Anda bergabung dengan kolam renang. Setelah bergabung, Anda dapat berpartisipasi dalam jumlah remix yang tidak terbatas tanpa biaya tambahan. Berikut ini adalah biaya tetap saat ini untuk setiap kolam renang:

| Pool (bitcoin) | Biaya masuk (bitcoin) |

|----------------|---------------------------------|

| 0,5 | 0,0175 |

| 0,05 | 0,00175 |

| 0,01 | 0,0005 (50.000 sat) | 0,01

| 0,001 | 0,00005 (5.000 sat) | 0,00005 (5.000 sat)

Biaya ini pada dasarnya berfungsi sebagai tiket masuk ke pool yang dipilih, berapa pun jumlah yang Anda masukkan ke dalam koin. Jadi, apakah Anda masuk ke pool 0.01 dengan 0.01 BTC atau 0.5 BTC, biayanya akan tetap sama secara absolut.

Sebelum melanjutkan dengan coinjoin Whirlpool, pengguna dapat memilih di antara 2 strategi:


- Pilihlah pool yang lebih kecil untuk meminimalkan biaya layanan, dengan mengetahui bahwa dia akan mendapatkan beberapa UTXO yang lebih kecil sebagai imbalannya;
- Atau pilihlah kumpulan yang lebih besar, bersedia membayar biaya yang lebih tinggi, hanya untuk mendapatkan sejumlah kecil UTXO yang bernilai lebih tinggi.

Umumnya tidak disarankan untuk menggabungkan beberapa UTXO campuran setelah siklus coinjoin, karena hal ini dapat membahayakan kerahasiaan yang diperoleh, terutama karena heuristik kepemilikan input yang umum (CIOH: *Common-Input-Ownership-Heuristic). Oleh karena itu, mungkin masuk akal untuk memilih pool yang lebih besar, bahkan jika ini berarti membayar lebih banyak, untuk menghindari terlalu banyak UTXO bernilai kecil dalam output. Pengguna harus mengevaluasi pertukaran ini untuk memilih pool yang dia sukai.

Selain biaya layanan, biaya penambangan khusus untuk setiap transaksi Bitcoin juga harus diperhitungkan. Sebagai pengguna Whirlpool, Anda akan diminta untuk membayar biaya penambangan untuk transaksi persiapan (`Tx0`) dan juga untuk coinjoin pertama. Semua remix berikutnya akan gratis, berkat model Whirlpool yang didasarkan pada pembayaran pendatang baru.

Faktanya, di setiap coinjoin Whirlpool, 2 pengguna di antara masukannya adalah pendatang baru. Input lainnya berasal dari remixer. Akibatnya, biaya penambangan untuk semua peserta dalam transaksi ditanggung oleh 2 pendatang baru ini, yang kemudian juga dapat memperoleh manfaat dari remix gratis:

![BTC204](assets/fr/142.webp)

Berkat sistem biaya ini, Whirlpool benar-benar menonjol dari implementasi coinjoin lainnya, karena anonset UTXO tidak sebanding dengan harga yang dibayarkan oleh pengguna. Sebagai hasilnya, dimungkinkan untuk mencapai tingkat anonimitas yang jauh lebih tinggi dengan hanya membayar biaya masuk pool dan biaya penambangan untuk 2 transaksi (`Tx0` dan campuran awal).

Penting untuk diperhatikan bahwa pengguna juga harus membayar biaya penambangan untuk menarik UTXO-nya dari pool setelah menyelesaikan beberapa coinjoin, kecuali jika dia telah memilih opsi `mix to`, yang menyediakan alamat eksternal yang akan menerima dana langsung dari coinjoin, tanpa transaksi tambahan.

### Akun portofolio HD

Untuk membuat coinjoin melalui Whirlpool, wallet harus membuat beberapa akun terpisah. Ini adalah prinsip di balik protokol ZeroLink. Sebuah akun, dalam konteks portofolio HD (*Hierarchical Deterministic*), merupakan sebuah bagian yang sepenuhnya terisolasi dari yang lain, pemisahan ini terjadi pada tingkat kedalaman ketiga dari hirarki portofolio, yaitu pada tingkat `xpub`.

![BTC204](assets/fr/143.webp)

Sebuah dompet HD secara teoritis dapat menghasilkan hingga `2^(31)` akun yang berbeda. Akun awal, yang digunakan secara default pada semua dompet Bitcoin, berhubungan dengan indeks `0`.

Untuk portofolio yang disesuaikan dengan Whirlpool, 4 akun digunakan untuk memenuhi kebutuhan proses ZeroLink:


- Akun **deposito**, diidentifikasi dengan indeks `0'`;
- Rekening **bad bank** (atau "perubahan doxxic"), yang diidentifikasi dengan indeks `2.147.483.644'`;
- Akun **premix**, diidentifikasi dengan indeks `2 147 483 645'`;
- Akun **postmix**, diidentifikasi dengan indeks `2 147 483 646'`.

Masing-masing akun ini memenuhi fungsi tertentu dalam proses coinjoin, yang akan kita bahas di bagian berikut.

Semua akun ini ditautkan ke satu seed, yang memungkinkan pengguna untuk memulihkan akses ke semua bitcoinnya menggunakan frasa pemulihan dan, jika memungkinkan, kata sandinya. Namun, selama operasi pemulihan, perangkat lunak harus diberitahu tentang berbagai indeks akun yang digunakan.

Mari kita lihat berbagai tahapan coinjoin Whirlpool dalam akun-akun ini.

### TX0

Titik awal dari setiap coinjoin Whirlpool adalah akun **deposit**. Ini adalah akun yang secara otomatis Anda gunakan ketika Anda membuat dompet Bitcoin baru. Akun ini harus diisi dengan bitcoin yang ingin Anda gabungkan.

Tx0" adalah langkah pertama dalam proses pencampuran Whirlpool. Tujuannya adalah untuk menyiapkan dan menyamakan UTXO untuk coinjoin, membaginya menjadi unit-unit yang sesuai dengan jumlah kolam yang dipilih, untuk memastikan pencampuran yang homogen. UTXO yang telah disamakan kemudian dikirim ke akun **premix**. Sedangkan untuk selisih yang tidak dapat masuk ke dalam pool, dipisahkan ke dalam akun tertentu: **bad bank** (atau "doxxic change").

Transaksi awal `Tx0` ini juga digunakan untuk membayar biaya layanan kepada koordinator coinjoin. Tidak seperti langkah-langkah selanjutnya, transaksi ini tidak bersifat kolaboratif, sehingga pengguna harus menanggung seluruh biaya penambangan:

![BTC204](assets/fr/144.webp)

Dalam contoh transaksi `Tx0` ini, input sebesar `372.000 sats` dari akun **deposit** kami dibagi menjadi beberapa output UTXO, yang dirinci sebagai berikut:


- Sejumlah `5.000 sats` untuk koordinator untuk biaya layanan, sesuai dengan entri kolam sebesar `100.000 sats`;
- 3 UTXO yang disiapkan untuk pencampuran, dialihkan ke akun **premix** kami dan didaftarkan ke koordinator. UTXO ini disetarakan dengan harga `108.000 sats` masing-masing, untuk menutupi biaya penambangan untuk campuran awal di masa mendatang;
- Surplus yang tidak dapat masuk ke dalam pool karena terlalu kecil, dianggap sebagai valuta asing beracun. Ini dikirim ke rekening khusus. Di sini, pertukaran ini berjumlah `40.000 sats`;
- Akhirnya, tersisa `3.000 satelite`, yang bukan merupakan output, tetapi merupakan biaya penambangan yang diperlukan untuk mengonfirmasi `Tx0`.

Sebagai contoh, berikut ini adalah Whirlpool Tx0 yang asli (bukan milik saya): [edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46](https://mempool.space/fr/tx/edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46)

![BTC204](assets/fr/145.webp)

### Perubahan yang sangat besar

Surplus yang tidak dapat diintegrasikan ke dalam pool, di sini setara dengan `40.000 sats`, dialihkan ke akun **bad bank**, yang juga dikenal sebagai "doxxic exchange", untuk memastikan pemisahan yang ketat dari UTXO lain dalam portofolio.

UTXO ini berbahaya bagi kerahasiaan pengguna, karena tidak hanya masih melekat pada masa lalunya, dan oleh karena itu mungkin pada identitas pemiliknya, tetapi juga dicatat sebagai milik pengguna yang telah melakukan coinjoin.

![BTC204](assets/fr/146.webp)

Jika UTXO ini digabungkan dengan output campuran, yang terakhir akan kehilangan semua kerahasiaan yang diperoleh selama siklus coinjoin, terutama karena CIOH (*Common-Input-Ownership-Heuristic*). Jika digabungkan dengan perubahan doxxic lainnya, pengguna berisiko kehilangan kerahasiaan, karena akan menghubungkan berbagai entri siklus coinjoin. Oleh karena itu harus diperlakukan dengan hati-hati. Kita akan membahas lebih detail tentang pengelolaan doxxic UTXO ini di bagian terakhir bab ini.

### Campuran awal

Setelah `Tx0`, UTXO yang telah disamakan dikirim ke akun **premix** portofolio kami, siap untuk dimasukkan ke dalam siklus penggabungan pertama, yang juga dikenal sebagai "campuran awal". Jika, seperti dalam contoh kita, `Tx0` menghasilkan beberapa UTXO untuk pencampuran, masing-masing akan diintegrasikan ke dalam campuran awal yang terpisah.

Pada akhir campuran pertama ini, akun **premix** akan kosong, sementara koin kita, setelah membayar biaya penambangan untuk koin pertama ini, akan disesuaikan dengan jumlah yang ditentukan oleh pool yang dipilih. Dalam contoh kita, UTXO awal kita sebesar `108.000 satoshi` akan dikurangi menjadi tepat `100.000 satoshi`.

![BTC204](assets/fr/147.webp)

### Remixes

Setelah pencampuran awal, UTXO ditransfer ke akun **postmix**. Akun ini mengumpulkan UTXO yang sudah dicampur dan yang sedang menunggu remix. Ketika pelanggan Whirlpool aktif, UTXO yang berada di akun **postmix** secara otomatis tersedia untuk di-remix dan akan dipilih secara acak untuk berpartisipasi dalam siklus baru ini.

Sebagai pengingat, remix 100% gratis: tidak ada biaya layanan tambahan atau biaya penambangan yang diperlukan. Oleh karena itu, menyimpan UTXO di akun **postmix** akan menjaga nilainya tetap utuh, dan pada saat yang sama meningkatkan anonsetnya. Itulah mengapa penting untuk mengizinkan koin-koin ini untuk berpartisipasi dalam beberapa siklus koin. Anda tidak akan dikenakan biaya sama sekali, dan meningkatkan tingkat anonimitasnya.

Ketika Anda memutuskan untuk membelanjakan UTXO campuran, Anda dapat melakukannya langsung dari akun **postmix** ini. Kami menyarankan Anda untuk menyimpan UTXO campuran di akun ini untuk mendapatkan keuntungan dari remix gratis dan untuk mencegahnya keluar dari sirkuit Whirlpool, yang dapat mengurangi kerahasiaannya.

### Bagaimana Anda mengelola postmix Anda?

Setelah menjalankan siklus coinjoin, strategi terbaik adalah menyimpan UTXO Anda di akun **postmix**, menunggu penggunaan di masa mendatang. Bahkan disarankan untuk membiarkannya melakukan remix tanpa batas waktu hingga Anda perlu membelanjakannya.

Beberapa pengguna mungkin mempertimbangkan untuk mentransfer bitcoin campuran mereka ke dompet yang diamankan oleh dompet perangkat keras. Hal ini memungkinkan, tetapi penting untuk mengikuti rekomendasi Samourai Wallet dengan cermat agar tidak membahayakan kerahasiaan yang diperoleh.

Menggabungkan UTXO adalah kesalahan yang paling umum. Untuk menghindari CIOH (*Common-Input-Ownership-Heuristic*), Anda harus menghindari penggabungan UTXO campuran dengan UTXO yang tidak tercampur dalam transaksi yang sama. Hal ini membutuhkan manajemen yang cermat terhadap UTXO dalam portofolio Anda, terutama dalam hal pelabelan.

![BTC204](assets/fr/148.webp)

Kehati-hatian juga harus dilakukan ketika mengkonsolidasikan UTXO campuran. Konsolidasi moderat dimungkinkan jika UTXO campuran Anda memiliki anonset yang signifikan, tetapi hal ini pasti akan mengurangi kerahasiaan bagian Anda. Pastikan konsolidasi tidak terlalu ekstensif, atau dilakukan setelah jumlah penggabungan yang tidak mencukupi, dengan risiko membangun hubungan yang dapat disimpulkan antara UTXO Anda sebelum dan sesudah siklus penggabungan. Jika Anda ragu dengan manipulasi ini, praktik terbaiknya adalah tidak menggabungkan UTXO postmix, tetapi mentransfernya satu per satu ke dompet perangkat keras Anda, menghasilkan alamat kosong baru setiap kali. Sekali lagi, ingatlah untuk memberi label pada setiap UTXO yang Anda terima.

Juga tidak disarankan untuk mentransfer UTXO postmix Anda ke dompet menggunakan skrip yang tidak banyak digunakan. Sebagai contoh, jika Anda masuk ke Whirlpool dari dompet multisig menggunakan skrip `P2WSH`, kemungkinan besar Anda akan tercampur dengan pengguna lain yang memiliki jenis dompet yang sama. Jika Anda mencampurkan kembali postmix Anda ke dompet multisig yang sama, tingkat kerahasiaan bitcoin campuran Anda akan sangat berkurang. Selain script, ada banyak sidik jari dompet lain yang dapat mempermainkan Anda.

Seperti halnya transaksi Bitcoin lainnya, penting juga untuk tidak menggunakan kembali alamat penerima. Setiap transaksi baru harus diterima di alamat baru yang kosong.

Solusi paling sederhana dan paling aman adalah dengan membiarkan UTXO campuran Anda tetap berada di akun **postmix** mereka, membiarkannya bercampur dan hanya menyentuhnya untuk dibelanjakan. Dompet Samurai dan Sparrow memiliki fitur perlindungan tambahan terhadap semua risiko analisis rantai ini. Perlindungan ini membantu Anda menghindari kesalahan.

### Bagaimana cara Anda mengelola bursa beracun?

Selanjutnya, Anda harus berhati-hati dalam mengelola doxxic exchange, yaitu exchange yang tidak berhasil masuk ke dalam pool coinjoin. UTXO beracun ini, yang dihasilkan dari penggunaan Whirlpool, menimbulkan risiko terhadap privasi Anda, karena mereka membuat hubungan antara Anda dan pengguna coinjoin. Oleh karena itu, sangat penting untuk mengelolanya dengan hati-hati dan tidak menggabungkannya dengan UTXO lain, terutama UTXO campuran.

Berikut adalah beberapa strategi untuk menggunakannya:


- Campurkan ke dalam kolam yang lebih kecil:** Jika UTXO beracun Anda cukup besar untuk dimasukkan ke dalam kolam yang lebih kecil sendirian, pertimbangkan untuk mencampurkannya. Ini sering kali merupakan pilihan terbaik. Namun, tidak disarankan untuk menggabungkan beberapa UTXO beracun untuk mengakses sebuah pool, karena hal ini dapat menautkan entri yang berbeda;
- Tandai sebagai "tidak dapat dibelanjakan":** Pendekatan lain adalah berhenti menggunakannya, tandai sebagai "tidak dapat dibelanjakan" di akun khusus, dan hodl. Hal ini memastikan bahwa Anda tidak akan membelanjakannya secara tidak sengaja. Jika nilai bitcoin naik, pool baru yang lebih cocok untuk UTXO beracun Anda mungkin akan muncul;
- Berikan donasi:** Pertimbangkan untuk memberikan donasi, betapapun kecilnya, kepada para pengembang yang mengerjakan Bitcoin dan perangkat lunak terkait. Anda juga dapat menyumbang ke asosiasi yang menerima BTC. Jika mengelola UTXO beracun Anda tampak terlalu rumit, Anda bisa langsung menyingkirkannya dan memberikan donasi;
- Beli kartu hadiah:** Platform seperti [Bitrefill] (https://www.bitrefill.com/) memungkinkan Anda untuk menukar bitcoin dengan kartu hadiah yang dapat digunakan di berbagai pedagang. Ini bisa menjadi cara untuk berpisah dengan UTXO beracun Anda tanpa kehilangan nilai yang terkait;
- Gabungkan mereka di Monero:** Dompet Samourai menawarkan layanan pertukaran atom antara BTC dan XMR. Ini sangat ideal untuk mengelola UTXO beracun dengan mengkonsolidasikannya di Monero, tanpa mengorbankan kerahasiaan Anda melalui CIOH, sebelum mengirimnya kembali ke Bitcoin. Namun, opsi ini bisa jadi mahal dalam hal biaya penambangan dan premium karena kendala likuiditas;
- Kirim ke Lightning Network:** Mentransfer UTXO ini ke Lightning Network untuk mendapatkan keuntungan dari pengurangan biaya transaksi dapat menjadi opsi yang menarik. Namun, metode ini dapat mengungkapkan informasi tertentu tergantung pada cara Anda menggunakan Lightning, dan oleh karena itu harus digunakan dengan hati-hati.

### Bagaimana cara menggunakan Whirlpool?

Setelah penangkapan pendiri Samourai Wallet dan penyitaan server mereka pada tanggal 24 April 2024, alat Whirlpool tidak lagi berfungsi, bahkan bagi mereka yang memiliki Dojo sendiri. Sebelumnya, alat ini tersedia di Samourai Wallet dan Sparrow Wallet.

![BTC204](assets/fr/149.webp)

Namun, masih ada kemungkinan bahwa alat ini akan diaktifkan kembali dalam beberapa minggu mendatang, tergantung pada hasil uji coba, atau diluncurkan kembali dengan cara yang berbeda. Bagaimanapun, saya rasa pasar coinjoin Bitcoin tidak akan kekurangan pasokan untuk waktu yang lama, karena permintaan tetap ada. Terlebih lagi, karena model Whirlpool adalah yang paling canggih dalam hal kerahasiaan, model ini pasti akan menjadi model pilihan untuk implementasi lain di masa depan.

Kami terus memantau kasus ini dan perkembangan alat yang terkait. Yakinlah bahwa kami akan memperbarui kursus pelatihan ini saat informasi baru tersedia.

Di bab berikutnya, kita akan mengetahui apa itu "anonset", bagaimana indikator ini dihitung, dan bagaimana indikator ini dapat membantu kita memperkirakan efisiensi siklus coinjoin.

https://planb.network/tutorials/privacy/on-chain/coinjoin-sparrow-wallet-84def86d-faf5-4589-807a-83be60720c8b

https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef

https://planb.network/tutorials/privacy/on-chain/coinjoin-dojo-c4b20263-5b30-4c74-ae59-dc8d0f8715c2

## Set anonimitas

<chapterId>be1093dc-1a74-40e5-9545-2b97a7d7d431</chapterId>


Setelah mempelajari cara kerja coinjoining dan masalah yang terlibat dalam pencampuran yang efektif, sekarang kita akan mengetahui cara mengukur efektivitasnya. Bagaimana kita dapat menentukan apakah proses penggabungan bersama sudah efektif, dan tingkat anonimitas apa yang diperoleh suatu bagian? Itulah yang akan kita cari tahu dalam bab ini dengan set anonimitas atau "anonset".

### Pengingat akan kegunaan coinjoin

Kegunaan coinjoin terletak pada kemampuannya untuk menghasilkan penyangkalan yang masuk akal, dengan menyematkan bagian Anda dalam sekelompok bagian yang tidak dapat dibedakan. Tujuan dari tindakan ini adalah untuk memutus hubungan penelusuran, baik dari masa lalu ke masa kini dan dari masa kini ke masa lalu.

Dengan kata lain, seorang analis yang mengetahui transaksi awal Anda (`Tx0`) pada saat masuknya siklus coinjoin tidak dapat mengidentifikasi dengan pasti UTXO Anda pada saat keluarnya siklus remix (analisis siklus masuk ke siklus keluar).

![BTC204](assets/fr/150.webp)

Sebaliknya, seorang analis yang mengetahui UTXO Anda pada saat keluar dari siklus coinjoin harus tidak dapat menentukan transaksi asli pada saat masuknya siklus (analisis siklus keluar ke siklus masuk).

![BTC204](assets/fr/151.webp)

Untuk menilai seberapa sulit bagi seorang analis untuk menghubungkan masa lalu dengan masa kini dan sebaliknya, kita perlu mengukur ukuran kelompok bagian yang homogen di mana bagian Anda tersembunyi. Ukuran ini memberi tahu kita berapa banyak analisis yang memiliki probabilitas yang sama. Jadi, jika analisis yang benar tenggelam di antara 3 analisis lain yang memiliki probabilitas yang sama, tingkat penyembunyian Anda sangat rendah. Di sisi lain, jika analisis yang benar ditemukan dalam sekumpulan 20.000 analisis dengan probabilitas yang sama, maka bagian Anda tersembunyi dengan sangat baik. Ukuran kelompok-kelompok ini mewakili indikator yang dikenal sebagai "anonset".

### Memahami anonset

Anonset digunakan sebagai indikator untuk menilai tingkat kerahasiaan UTXO tertentu. Lebih khusus lagi, mereka mengukur jumlah UTXO yang tidak dapat dibedakan dalam set yang mencakup bagian yang diteliti. Persyaratan untuk satu set UTXO yang homogen berarti bahwa anonset biasanya dihitung pada siklus coinjoin. Penggunaan indikator ini sangat relevan untuk coinjoint Whirlpool, karena keseragamannya.

Jika perlu, anonset dapat digunakan untuk menilai kualitas koin bersama. Anonset yang besar berarti tingkat anonimitas yang tinggi, karena menjadi sulit untuk membedakan UTXO tertentu dalam set yang homogen.

ada 2 jenis anonset:


- Calon anonset;;** Calon
- Anonset retrospektif.**

### Calon anonset

Anonset berwawasan ke depan menunjukkan ukuran kelompok di mana UTXO yang dipelajari pada akhir siklus disembunyikan, mengingat UTXO di awal, yaitu jumlah bagian yang tidak dapat dibedakan yang ada di dalam kelompok ini. Nama indikator ini adalah "metrik berwawasan ke depan".

Indikator ini mengukur ketahanan kerahasiaan ruangan terhadap analisis masa lalu-ke-sekarang (input-ke-output).

![BTC204](assets/fr/152.webp)

Metrik ini digunakan untuk memperkirakan sejauh mana UTXO Anda terlindungi dari upaya merekonstruksi riwayatnya dari titik masuk hingga titik keluar dalam proses coinjoin.

Sebagai contoh, jika transaksi Anda telah berpartisipasi dalam siklus coinjoin pertama dan dua siklus turun lebih lanjut telah selesai, maka calon anonset koin Anda adalah `13`:

![BTC204](assets/fr/153.webp)

Sebagai contoh, bayangkan koin kita pada awal siklus coinjoin memiliki anonset prospektif sebesar `86.871`. Dalam istilah praktis, ini berarti bahwa anonset tersebut tersembunyi di antara `86.871` bagian yang tidak dapat dibedakan. Untuk pengamat luar yang mengetahui koin ini pada awal siklus coinjoin dan mencoba melacak jalan keluarnya, dia akan dihadapkan dengan `86,871` kemungkinan UTXO, masing-masing dengan probabilitas yang sama dengan koin yang dia cari.

![BTC204](assets/fr/154.webp)

### Anonset retrospektif

Anonset retrospektif menunjukkan jumlah sumber yang mungkin untuk komponen tertentu, dengan mengetahui UTXO pada akhir siklus. Indikator ini mengukur resistensi kerahasiaan komponen terhadap analisis sekarang-ke-masa lalu (output-ke-input), yaitu seberapa sulit bagi analis untuk melacak komponen Anda kembali ke asalnya, sebelum siklus coinjoin. Nama indikator ini adalah "backward anonset", atau "metrik yang melihat ke belakang".

![BTC204](assets/fr/155.webp)

Dengan mengetahui UTXO Anda pada saat keluar dari siklus, anonset retrospektif menentukan jumlah potensi transaksi Tx0 yang dapat menjadi entri Anda ke dalam siklus coinjoin. Pada diagram di bawah ini, ini sesuai dengan jumlah semua gelembung oranye.

![BTC204](assets/fr/156.webp)

Sebagai contoh, mari kita bayangkan bahwa bagian coinjoin kita memiliki anonset retrospektif sebesar `42.185`. Secara praktis, ini berarti ada `42.185` sumber potensial untuk UTXO ini. Jika seorang pengamat eksternal mengidentifikasi koin ini pada akhir siklus dan berusaha melacak asalnya, dia akan dihadapkan pada `42.185` sumber yang mungkin, semuanya dengan probabilitas yang sama untuk menjadi sumber yang dicari.

![BTC204](assets/fr/157.webp)

### Bagaimana cara menghitung anonset?

Anda dapat menghitung anonset secara manual menggunakan block explorer untuk ansambel kecil. Namun, untuk anonset yang lebih besar, penggunaan alat khusus menjadi sangat penting. Sejauh yang saya tahu, satu-satunya perangkat lunak yang mampu melakukan tugas ini adalah *Whirlpool Stats Tool*, sebuah alat Python yang dikembangkan oleh tim Samourai dan OXT. Sayangnya, alat ini saat ini tidak berfungsi setelah penangkapan para pendiri Samourai dan gangguan pada OXT, yang digunakan untuk mengekstrak data dari blockchain.

![BTC204](assets/fr/158.webp)

Seperti yang telah kita lihat pada bab ini, anonset hanya dapat dihitung jika ada homogenitas tertentu dalam struktur coinjoin. Pada bab selanjutnya, kita akan mengetahui bagaimana cara menghitung homogenitas ini pada sebuah transaksi Bitcoin, baik itu coinjoin maupun transaksi yang lebih tradisional.

https://planb.network/tutorials/privacy/analysis/wst-anonsets-0354b793-c301-48af-af75-f87569756375

## Entropi

<chapterId>e4fe289d-618b-49a2-84c9-68c562e708b4</chapterId>


Seperti yang telah kita lihat pada bagian ini mengenai coinjoin, homogenitas UTXO dalam input dan output memainkan peran penting dalam meningkatkan kerahasiaan transaksi Bitcoin. Parameter ini menciptakan penyangkalan yang masuk akal dalam menghadapi analisis blockchain. Beberapa metode dapat digunakan untuk mengukur homogenitas ini, tetapi salah satu yang paling efektif, menurut pendapat saya, adalah penggunaan indikator yang disediakan oleh alat *Boltzmann*, yang dikembangkan oleh tim OXT dan Dompet Samourai, dan khususnya entropi transaksi. Inilah yang akan kita bahas secara rinci dalam bab ini.

Tidak seperti anonset, yang dihitung berdasarkan sekumpulan transaksi, indikator yang disajikan di sini berfokus pada satu transaksi, baik itu coinjoin atau transaksi yang lebih tradisional.

### Jumlah interpretasi

Indikator pertama yang dapat diamati pada transaksi Bitcoin adalah jumlah total interpretasi yang mungkin dihadapkan pada analisis dari pengamat luar. Dengan mempertimbangkan nilai UTXO yang terlibat dalam transaksi, indikator ini menunjukkan jumlah cara di mana input dapat dikaitkan dengan output. Dengan kata lain, indikator ini menentukan jumlah kemungkinan interpretasi yang dapat ditimbulkan oleh sebuah transaksi dalam arus bitcoin dari sudut pandang pengamat luar yang menganalisisnya.

Sebagai contoh, sebuah transaksi pembayaran sederhana dengan 1 input dan 2 output hanya memiliki satu interpretasi, yaitu input #0 membiayai output #0 dan output #1. Tidak ada interpretasi lain yang memungkinkan:

![BTC204](assets/fr/159.webp)

Di sisi lain, sudut Whirlpool 5x5 memiliki kemungkinan kombinasi senilai $ 1.496.000:

![BTC204](assets/fr/160.webp)

Sebuah Whirlpool Surge Cycle 8x8 coinjoin memiliki kemungkinan interpretasi sebesar $9\,934\,563$:

![BTC204](assets/fr/161.webp)

### Entropi

Dari jumlah interpretasi sebuah transaksi Bitcoin, kita dapat menghitung entropinya.

Dalam konteks umum kriptografi dan informasi, entropi adalah ukuran kuantitatif dari ketidakpastian atau ketidakpastian yang terkait dengan sumber data atau proses acak. Dengan kata lain, entropi adalah sebuah cara untuk mengukur seberapa sulitnya sebuah informasi untuk diprediksi atau ditebak.

Dalam konteks khusus analisis blockchain, entropi juga merupakan nama sebuah indikator, yang berasal dari entropi Shannon dan [ditemukan oleh LaurentMT] (https://gist.github.com/LaurentMT/e758767ca4038ac40aaf), yang dapat dihitung dalam sebuah transaksi Bitcoin.

Ketika sebuah transaksi menyajikan sejumlah besar kemungkinan interpretasi, sering kali lebih relevan untuk merujuk pada entropinya. Indikator ini mengukur kurangnya pengetahuan para analis mengenai konfigurasi yang tepat dari transaksi. Dengan kata lain, semakin tinggi entropi, semakin sulit bagi para analis untuk mengidentifikasi aliran bitcoin antara input dan output.

Dalam praktiknya, entropi menunjukkan apakah, dari sudut pandang pengamat eksternal, sebuah transaksi menyajikan beberapa kemungkinan interpretasi, hanya berdasarkan jumlah input dan output, tanpa memperhitungkan pola dan heuristik eksternal atau internal lainnya. Oleh karena itu, entropi yang tinggi identik dengan kerahasiaan yang lebih besar untuk transaksi tersebut.

Entropi didefinisikan sebagai logaritma biner dari jumlah kombinasi yang mungkin. Berikut adalah rumus yang digunakan dengan $E $ entropi transaksi dan $C $ jumlah interpretasi yang mungkin:

$$
E = \log_2(C)
$$

Dalam matematika, logaritma biner (logaritma basis-2) adalah operasi kebalikan dari eksponensial 2. Dengan kata lain, logaritma biner dari $x$ adalah eksponen yang harus dinaikkan $2$ untuk mendapatkan $x$. Oleh karena itu, indikator ini dinyatakan dalam bit.

Mari kita ambil contoh perhitungan entropi untuk transaksi coinjoin yang terstruktur menurut model Whirlpool 5x5, yang, seperti yang telah disebutkan di bagian sebelumnya, memiliki beberapa kemungkinan interpretasi terhadap $1\,496$:

$$
\begin{align*}
C &= 1\,496 \\
E &= \log_2(1\,496) \\
E &= 10.5469 \text{ bits}
\end{align*}
$$

Dengan demikian, transaksi coinjoin ini memiliki entropi sebesar $10,5469$ bit, yang dianggap sangat memuaskan. Semakin tinggi nilai ini, semakin banyak interpretasi yang berbeda yang dapat diterima oleh transaksi tersebut, sehingga memperkuat tingkat kerahasiaannya.

Untuk transaksi coinjoin 8x8 dengan interpretasi $9\,934\,563$, entropinya adalah :

$$
\begin{align*}
C &= 9\,934\,563 \\
E &= \log_2(9\,934\,563) \\
E &= 23.244 \text{ bits}
\end{align*}
$$

Mari kita ambil contoh lain dengan transaksi pembayaran klasik, dengan 1 input dan 2 output: [1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce](https://mempool.space/tx/1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce)

![BTC204](assets/fr/162.webp)

Dalam kasus transaksi ini, satu-satunya interpretasi yang mungkin adalah: `(In.0) > (Out.0 ; Out.1)`. Akibatnya, entropinya adalah $0$:

$$
\begin{align*}
C &= 1 \\
E &= \log_2(1) \\
E &= 0 \text{ bits}
\end{align*}
$$

### Efisiensi

Berdasarkan entropi transaksi, kita juga dapat menghitung efisiensinya dalam hal kerahasiaan. Indikator ini mengevaluasi efisiensi transaksi dengan membandingkannya dengan transaksi optimal yang dapat dibayangkan dalam konfigurasi yang sama.

Hal ini membawa kita pada konsep entropi maksimum, yang berhubungan dengan entropi tertinggi yang secara teoritis dapat dicapai oleh struktur transaksi tertentu. Efisiensi transaksi kemudian dihitung dengan membandingkan entropi maksimum ini dengan entropi aktual dari transaksi yang dianalisis.

Rumus yang digunakan adalah sebagai berikut dengan :


- e_R$: entropi aktual dari transaksi yang dinyatakan dalam bit;
- e_M$: entropi maksimum yang mungkin terjadi pada sebuah struktur transaksi, juga dinyatakan dalam bit;
- $Ef$: efisiensi transaksi dalam satuan bit:

$$
Ef = E_R - E_M
$$

Sebagai contoh, untuk struktur coinjoin Whirlpool 5x5, entropi maksimumnya adalah $10,5469$:

$$
\begin{align*}
E_R &= 10.5469 \\
E_M &= 10.5469 \\
Ef &= E_R - E_M \\
Ef &= 10.5469 - 10.5469 \\
Ef &= 0 \text{ bits}
\end{align*}
$$

Indikator ini juga dinyatakan dalam bentuk persentase. Rumus yang digunakan adalah sebagai berikut: :


- c_R$ : jumlah interpretasi nyata yang mungkin terjadi;
- c_M$: jumlah maksimum interpretasi yang mungkin dari struktur yang sama;
- $Ef$: efisiensi yang dinyatakan dalam bentuk persentase:

$$
\begin{align*}
E_f &= \frac{C_R}{C_M} \\
E_f &= \frac{1\,496}{1\,496} \\
E_f &= 100 \%
\end{align*}
$$

Efisiensi sebesar $100 mengindikasikan bahwa transaksi tersebut memanfaatkan potensi kerahasiaannya secara maksimal, tergantung pada strukturnya.

### Kepadatan entropi

Entropi adalah indikator yang baik untuk mengukur kerahasiaan suatu transaksi, tetapi sebagian tergantung pada jumlah input dan output dalam transaksi. Untuk membandingkan entropi dari 2 transaksi yang berbeda dengan jumlah input dan output yang berbeda, kita dapat menghitung densitas entropi. Indikator ini memberikan perspektif tentang entropi relatif terhadap setiap input atau output transaksi. Densitas berguna untuk mengevaluasi dan membandingkan efisiensi transaksi dengan ukuran yang berbeda.

Untuk menghitungnya, kita cukup membagi total entropi transaksi dengan jumlah total input dan output yang terlibat dalam transaksi:


- e_D$: densitas entropi yang dinyatakan dalam bit;
- e$: entropi transaksi yang dinyatakan dalam bit;
- t$: jumlah total input dan output dalam transaksi:

$$
E_D = \frac{E}{T}
$$

Mari kita ambil contoh coinjoin Whirlpool 5x5:

$$
\begin{align*}
T &= 5 + 5 = 10 \\
E &= 10.5469 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{10.5469}{10} \\
E_D &= 1.054 \text{ bits}
\end{align*}
$$

Mari kita juga menghitung kepadatan entropi dari coinjoin Whirlpool 8x8:

$$
\begin{align*}
T &= 8 + 8 = 16 \\
E &= 23.244 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{23.244}{16} \\
E_D &= 1.453 \text{ bits}
\end{align*}
$$

Dengan menganalisis kepadatan entropi dari kedua jenis coinjoin ini, menjadi jelas bahwa, bahkan ketika menormalkan entropi dengan jumlah elemen, coinjoin "Surge Cycle 8x8" menghasilkan lebih banyak ketidakpastian untuk analisis.

### Skor Boltzmann

Informasi lain yang dianalisis dalam transaksi adalah skor Boltzmann dari setiap elemen relatif terhadap elemen lainnya. Ini adalah tabel probabilitas pencocokan antara input dan output. Tabel ini menunjukkan, melalui skor Boltzmann, probabilitas bersyarat bahwa input tertentu terkait dengan output yang diberikan. Oleh karena itu, ini adalah ukuran kuantitatif dari probabilitas bersyarat bahwa hubungan antara input dan output dalam suatu transaksi akan terjadi, berdasarkan rasio jumlah kejadian yang menguntungkan dari peristiwa ini dengan jumlah total kemungkinan kejadian, dalam satu set interpretasi.

Dengan menggunakan contoh coinjoin Whirlpool, tabel probabilitas bersyarat akan menyoroti peluang hubungan antara setiap input dan output, yang menawarkan ukuran kuantitatif dari ambiguitas asosiasi dalam transaksi:

| % | Keluaran 0 | Keluaran 1 | Keluaran 2 | Keluaran 3 | Keluaran 4

| ------- | -------- | -------- | -------- | -------- | -------- |

| Masukan 0 | 34% | 34% | 34% | 34% | 34% | 34% |

| Masukan 1 | 34% | 34% | 34% | 34% | 34% | 34% | Masukan 1

| Masukan 2 | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34

| Masukan 3 | 34% | 34% | 34% | 34% | 34% | 34% | Masukan 3

| Masukan 4 | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34

Jelas, setiap input memiliki peluang yang sama untuk dikaitkan dengan output apa pun, yang memperkuat kerahasiaan transaksi.

Skor Boltzmann dihitung dengan membagi jumlah interpretasi di mana peristiwa tertentu terjadi dengan jumlah total interpretasi yang tersedia. Dengan demikian, untuk menentukan skor yang mengaitkan input #0 dengan output #3 (peristiwa yang ada dalam interpretasi $512), kita lanjutkan sebagai berikut:

$$
\begin{align*}
\text{Interpretations (IN.0 > OUT.3)} &= 512 \\
\text{Interpretations totales} &= 1496 \\
\text{Score} &= \frac{512}{1496} \\
\text{Score} &= 34 \%
\end{align*}
$$

Jika kita mengambil contoh coinjoin Whirlpool 8x8 Surge Cycle, tabel Boltzmann akan terlihat seperti ini:

| OUT.0 | OUT.1 | OUT.2 | OUT.3 | OUT.4 | OUT.5 | OUT.6 | OUT.7 |

|-------|-------|-------|-------|-------|-------|-------|-------|-------|

| IN.0 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.1 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.2 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.3 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

iN.4 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

iN.5 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

iN.6 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

iN.7 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

Namun, dalam kasus transaksi sederhana dengan satu input dan 2 output, situasinya berbeda:

| Keluaran 0 | Keluaran 1

|---------|----------|----------|

| Masukan 0 | 100% | 100% |

Di sini, kita melihat bahwa probabilitas setiap output yang berasal dari input #0 adalah 100%. Probabilitas yang lebih rendah dengan demikian mencerminkan kerahasiaan yang lebih besar, menipiskan hubungan langsung antara input dan output.

### Tautan deterministik

Kita juga dapat menghitung jumlah hubungan deterministik dalam sebuah transaksi. Indikator ini menunjukkan berapa banyak hubungan antara input dan output dalam transaksi yang dianalisis yang tidak perlu dipertanyakan lagi, dengan probabilitas 100%. Indikator ini kemudian dapat dilengkapi dengan menghitung rasio hubungan deterministik. Rasio ini memberikan perspektif tentang bobot hubungan deterministik ini dalam total hubungan transaksi.

Sebagai contoh, transaksi coinjoin Whirlpool tidak memiliki tautan deterministik antara input dan output, dan oleh karena itu menampilkan indikator 0 tautan dan rasio 0%. Sebaliknya, pada transaksi pembayaran sederhana kedua yang kami periksa (dengan satu input dan 2 output), indikator menunjukkan bahwa ada 2 tautan deterministik, dan rasionya mencapai 100%. Dengan kata lain, indikator nol menunjukkan kerahasiaan yang sangat baik, berkat tidak adanya hubungan langsung dan tak terbantahkan antara input dan output.

### Bagaimana Anda menghitung indikator-indikator ini?

Menghitung indikator-indikator ini secara manual dengan menggunakan persamaan yang saya berikan relatif mudah. Kesulitannya terutama terletak pada penentuan jumlah interpretasi yang mungkin dari sebuah transaksi. Untuk transaksi klasik, perhitungan ini dapat dilakukan dengan tangan. Namun, untuk coinjoin, tugasnya jauh lebih kompleks.

Sebelumnya, ada alat Python yang disebut _Boltzmann Calculator_, yang dikembangkan oleh tim OXT dan Samourai, yang secara otomatis menghitung semua indikator ini untuk transaksi Bitcoin:

![BTC204](assets/fr/163.webp)

Anda juga dapat menggunakan situs web KYCP.org untuk melakukan analisis ini:

![BTC204](assets/fr/164.webp)

Sayangnya, setelah para pendiri Samourai ditangkap, alat-alat ini tidak lagi beroperasi.

Setelah kita membahas coinjoins secara mendetail, kita akan melihat teknik privasi lain yang tersedia di Bitcoin di bagian akhir kursus ini. Kita akan melihat payjoin, jenis transaksi pseudo-coinjoin tertentu, protokol alamat statis, serta langkah-langkah untuk memperkuat kerahasiaan tidak pada tingkat transaksi itu sendiri, tetapi pada tingkat jaringan node.

https://planb.network/tutorials/privacy/analysis/boltzmann-entropy-738e45af-18a6-4ce6-af1a-1bf58e15f1fe

# Memahami tantangan teknik kerahasiaan tingkat lanjut lainnya

<partId>19989ae6-d608-4acf-b698-2cf1e7e5e6ae</partId>

## Transaksi Payjoin

<chapterId>c1e90b95-f709-4574-837b-2ec26b11286f</chapterId>


Coinjoin saat ini merupakan metode yang paling efektif untuk memasukkan ketidakpastian ke dalam penelusuran komponen dalam analisis rantai. Seperti yang telah kita lihat pada bab-bab sebelumnya, untuk mendapatkan campuran berkinerja tinggi, input dan output harus sehomogen mungkin. Selain itu, penting agar bagian-bagian diintegrasikan ke dalam kelompok sebesar mungkin untuk memaksimalkan anonset. Jadi, agar coinjoin menjadi efektif, mereka harus melibatkan sejumlah besar bagian yang seragam. Banyaknya persyaratan ini berarti bahwa transaksi coinjoin memiliki struktur yang sangat kaku: jumlahnya ditentukan sebelumnya, dan semua peserta harus mematuhinya untuk menjamin keseragaman proses. Selain itu, coinjoin membutuhkan sinkronisasi antara semua peserta dan koordinator selama konstruksi transaksi.

Persyaratan ini membuat coinjoin tidak cocok untuk pembayaran langsung. Sebagai contoh, jika Anda memiliki koin 1 juta sats dalam pool coinjoin, menggunakannya secara langsung sebagai pembayaran akan menjadi rumit. Diperlukan sinkronisasi dengan peserta lain dan koordinator untuk membangun transaksi kolaboratif tepat pada saat Anda perlu melakukan pembayaran, dan jumlah pembelian harus sesuai dengan nilai koin Anda, yang sebenarnya tidak memungkinkan. Oleh karena itu, transaksi coinjoin pada dasarnya adalah transaksi sapuan kolaboratif, yaitu biasanya pemilik yang sama dari input yang kita temukan dalam output.

Namun, akan sangat menarik untuk memiliki struktur transaksi yang memungkinkan pembayaran dilakukan dengan cara yang praktis, dan pada saat yang sama memasukkan keraguan ke dalam analisis rantai. Inilah yang akan kita bahas dalam bab ini dan bab selanjutnya.

### Apa yang dimaksud dengan transaksi payjoin?

Payjoin adalah struktur transaksi Bitcoin khusus yang meningkatkan privasi pengguna saat melakukan pembelanjaan dengan berkolaborasi dengan penerima pembayaran.

Pada tahun 2015, LaurentMT pertama kali menyebutkan metode ini dengan sebutan "*steganographic transactions*", sebagaimana dijelaskan dalam dokumen yang tersedia [di sini](https://gist.githubusercontent.com/LaurentMT/e758767ca4038ac40aaf/raw/c8125f6a3c3d0e90246dc96d3b603690ab6f1dcc/gistfile1.txt). Teknik ini kemudian diadopsi oleh dompet Samourai Wallet, yang pada tahun 2018 menjadi klien pertama yang mengimplementasikannya melalui alat Stowaway. Konsep payjoin juga ditemukan dalam [BIP79](https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki), [BIP78](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki), dan [BIP77](https://payjoin.org/docs/how-it-works/payjoin-v2-bip-77/). Beberapa istilah digunakan untuk menyebut payjoin:

- Payjoin ;
- Penumpang gelap;
- P2EP (*Bayar-ke-Titik-Akhir*);
- Transaksi steganografi.

Fitur khusus dari payjoin terletak pada kemampuannya untuk menghasilkan sebuah transaksi yang terlihat biasa saja pada pandangan pertama, tetapi sebenarnya merupakan sebuah Coinjoin mini antara dua orang. Untuk mencapai hal ini, struktur transaksi melibatkan penerima pembayaran dalam input di samping pengirim yang sebenarnya. Dengan demikian, penerima menyertakan pembayaran untuk dirinya sendiri di tengah-tengah transaksi yang memungkinkannya untuk dibayar.

Mari kita ambil sebuah contoh untuk lebih memahami proses ini. Alice membeli baguette seharga 4.000 sat menggunakan UTXO 10.000 sat dan memilih pembayaran dengan sistem payjoin. Tukang rotinya, Bob, menambahkan UTXO sebanyak 15.000 sat miliknya sebagai input, yang ia dapatkan kembali secara penuh sebagai output, di samping 4.000 sat milik Alice.

![BTC204](assets/fr/165.webp)

Dalam contoh ini, Bob si pembuat roti memasukkan 15.000 sat sebagai masukan dan keluar dengan 19.000 sat, selisihnya tepat 4.000 sat, yaitu harga roti. Di sisi Alice, ia memasukkan 10.000 sat dan berakhir dengan 6.000 sat sebagai output, yang mewakili keseimbangan -4.000 sat, yaitu harga baguette. Untuk menyederhanakan contoh ini, saya sengaja menghilangkan biaya penambangan dalam transaksi ini.

### Untuk apa payjoin itu?

Transaksi payjoin memenuhi dua tujuan, memungkinkan pengguna untuk meningkatkan kerahasiaan pembayaran mereka.

Pertama, payjoin bertujuan untuk menyesatkan pengamat luar dengan menciptakan iming-iming dalam analisis rantai. Hal ini dimungkinkan oleh heuristik CIOH (*Common Input Ownership Heuristic*). Seperti yang telah kita lihat pada bagian 3, biasanya, ketika sebuah transaksi pada blockchain memiliki beberapa input, diasumsikan bahwa semua input tersebut adalah milik entitas atau pengguna yang sama.

Jadi, ketika seorang analis memeriksa sebuah transaksi payjoin, dia akan percaya bahwa semua input berasal dari orang yang sama. Namun, persepsi ini salah, karena penerima pembayaran juga berkontribusi pada input di samping pembayar yang sebenarnya. Oleh karena itu, analisis rantai dialihkan ke interpretasi yang ternyata salah.

Mari kita ambil contoh transaksi payjoin untuk pembayaran baguette:

![BTC204](assets/fr/166.webp)

Melihat transaksi ini di blockchain, pengamat luar yang mengikuti heuristik analisis blockchain yang biasa akan membuat interpretasi sebagai berikut: "*Alice menggabungkan 2 UTXO sebagai input untuk transaksi untuk membayar 19.000 sat kepada Bob*".

![BTC204](assets/fr/167.webp)

Interpretasi ini jelas tidak benar, karena seperti yang sudah Anda ketahui, dua UTXO dalam input tidak dimiliki oleh orang yang sama. Yang satu berasal dari Alice, pembeli baguette, dan yang lainnya dari Bob, pembuat roti.

![BTC204](assets/fr/168.webp)

Dengan cara ini, analisis pengamat eksternal diarahkan pada kesimpulan yang keliru, sehingga kerahasiaan para pemangku kepentingan tetap terjaga.

### Transaksi steganografi

Tujuan kedua dari payjoin adalah untuk menyesatkan pengamat luar tentang jumlah pembayaran yang sebenarnya telah dilakukan. Dengan memeriksa struktur transaksi, analis mungkin percaya bahwa pembayaran tersebut setara dengan jumlah salah satu output.

Jika kita kembali ke contoh pembelian baguette, analis akan berpikir bahwa jumlah pembayaran sesuai dengan UTXO 6.000 sat, atau UTXO 19.000 sat. Dalam kasus ini, analis akan lebih suka berpikir bahwa jumlah pembayaran adalah 19.000 sat, karena ada 2 UTXO dalam output, setidaknya salah satu dari mereka lebih besar dari 6.000 sat (tidak ada alasan logis untuk menggunakan 2 UTXO untuk membayar 6.000 sat ketika satu UTXO akan cukup untuk memenuhi pembayaran ini).

![BTC204](assets/fr/169.webp)

Namun pada kenyataannya, analisis ini cacat. Jumlah pembayaran tidak sesuai dengan output mana pun. Ini sebenarnya adalah perbedaan antara UTXO penerima dalam output dan UTXO penerima dalam input.

![BTC204](assets/fr/170.webp)

Dalam hal ini, transaksi payjoin masuk ke dalam ranah steganografi. Hal ini memungkinkan jumlah transaksi yang sebenarnya untuk disembunyikan di dalam transaksi palsu yang bertindak sebagai umpan.

Steganografi adalah sebuah teknik untuk menyembunyikan informasi di dalam data atau objek lain, sehingga keberadaan informasi yang disembunyikan tidak terlihat. Sebagai contoh, sebuah pesan rahasia dapat disembunyikan di dalam sebuah titik di dalam teks yang tidak berhubungan, sehingga tidak terdeteksi oleh mata telanjang (ini adalah teknik [microdot] (https://fr.wikipedia.org/wiki/Micropoint)).

Tidak seperti enkripsi, yang membuat informasi tidak dapat dimengerti tanpa kunci dekripsi, steganografi tidak mengubah informasi. Informasi tetap ditampilkan dalam teks yang jelas. Sebaliknya, tujuannya adalah untuk menyembunyikan keberadaan pesan rahasia, sedangkan enkripsi dengan jelas mengungkapkan keberadaan informasi tersembunyi, meskipun tidak dapat diakses tanpa kunci. Inilah sebabnya mengapa nama asli dari payjoin adalah "transaksi steganografi".

Sebuah analogi dapat ditarik antara kriptografi dan coinjoin, dan antara steganografi dan payjoin. Coinjoin memiliki atribut yang mirip dengan enkripsi: metodenya dapat dikenali, tetapi informasinya tidak dapat diuraikan. Sebaliknya, payjoin mirip dengan steganografi: informasinya secara teori dapat diakses, tetapi karena metode penyembunyiannya tidak dapat dikenali, maka informasi tersebut tidak dapat diakses.

### Bagaimana cara menggunakan payjoin?

Program perangkat lunak terkenal yang mendukung payjoin termasuk Sparrow Wallet, Wasabi Wallet, Mutiny, BitMask, BlueWallet dan JoinMarket, serta pemroses pembayaran BTCPay.

![BTC204](assets/fr/171.webp)

Implementasi payjoin yang paling canggih hanyalah Stowaway di Samourai Wallet. Namun, sejak penangkapan para pendiri perangkat lunak ini, alat ini sekarang hanya berfungsi sebagian. Keuntungan dari Stowaway adalah protokolnya yang komprehensif dan mudah digunakan, yang mendukung penerimaan dan pengiriman payjoin. Transaksi yang ditandatangani sebagian dapat ditukar secara manual dengan memindai beberapa kode QR, atau secara otomatis dengan Tor melalui Soroban. Opsi komunikasi yang terakhir saat ini tidak tersedia.

![BTC204](assets/fr/172.webp)

Kesulitan dalam menggunakan payjoin terletak pada ketergantungannya pada partisipasi pedagang. Sebagai pelanggan, Anda tidak bisa menggunakan payjoin jika merchant tidak mendukungnya. Hal ini menambah kesulitan lebih lanjut pada proses pembelian: tidak hanya sulit untuk menemukan merchant yang menerima bitcoin, tetapi jika Anda juga mencari merchant yang mendukung payjoin, maka prosesnya menjadi lebih rumit.

Salah satu solusinya adalah dengan menggunakan struktur transaksi yang memperkenalkan ambiguitas ke dalam analisis rantai tanpa memerlukan kerja sama dari penerima. Hal ini akan memungkinkan kita untuk meningkatkan kerahasiaan pembayaran tanpa bergantung pada partisipasi aktif dari pedagang. Inilah yang akan kita bahas pada bab selanjutnya.

https://planb.network/tutorials/privacy/on-chain/payjoin-sparrow-wallet-087a0e49-61cd-41f5-8440-ac7b157bdd62

https://planb.network/tutorials/privacy/on-chain/payjoin-samourai-wallet-48a5c711-ee3d-44db-b812-c55913080eab

## Pembayaran dengan koin mini

<chapterId>300777ee-30ae-43d7-ab00-479dac3522c1</chapterId>


Ketika Anda ingin melakukan transaksi pembayaran dengan tetap menjaga tingkat kerahasiaan tertentu, payjoin adalah pilihan yang baik. Tetapi seperti yang baru saja kita lihat, payjoin membutuhkan keterlibatan penerima. Jadi, apa yang Anda lakukan jika penerima menolak untuk berpartisipasi dalam payjoin, atau jika Anda lebih memilih untuk tidak melibatkan mereka? Salah satu alternatifnya adalah dengan menggunakan transaksi Stonewall atau Stonewall x2. Mari kita lihat lebih dekat kedua jenis transaksi ini.

### Transaksi Stonewall

Stonewall adalah sebuah bentuk transaksi Bitcoin khusus yang didesain untuk meningkatkan kerahasiaan pengguna ketika melakukan pembelanjaan dengan meniru koin semu antara dua orang, tanpa benar-benar menjadi koin. Pada kenyataannya, transaksi ini tidak bersifat kolaboratif. Seorang pengguna dapat membuatnya sendiri, dengan hanya menggunakan UTXO yang dimilikinya sebagai input. Jadi, Anda dapat membuat transaksi Stonewall untuk setiap kesempatan, tanpa perlu melakukan sinkronisasi dengan pengguna lain atau penerima.

Transaksi Stonewall bekerja sebagai berikut: sebagai input untuk transaksi, penerbit menggunakan 2 UTXO yang menjadi miliknya. Sebagai output, transaksi menghasilkan 4 UTXO, 2 di antaranya memiliki jumlah yang sama persis. Dua UTXO lainnya akan menjadi valuta asing. Dari 2 output dengan jumlah yang sama, hanya satu yang akan benar-benar masuk ke penerima pembayaran.

Jadi hanya ada 2 peran dalam transaksi Stonewall:


- Penerbit, yang melakukan pembayaran ;
- Penerima, yang mungkin tidak menyadari sifat spesifik dari transaksi dan hanya mengharapkan pembayaran dari pengirim.

Mari kita ambil sebuah contoh untuk memahami struktur transaksi ini. Alice pergi ke Bob si penjual roti untuk membeli baguette seharga 4.000 sat. Ia ingin membayar dengan bitcoin, namun tetap menjaga kerahasiaan pembayarannya. Jadi, dia memutuskan untuk membuat transaksi Stonewall untuk pembayarannya.

![BTC204](assets/fr/173.webp)

Dengan menganalisis transaksi ini, kita dapat melihat bahwa Bob si pembuat roti sebenarnya menerima 4.000 sat sebagai pembayaran untuk baguette tersebut. Alice menggunakan 2 UTXO sebagai input: satu untuk 10.000 sat dan satu lagi untuk 15.000 sat. Sebagai output, dia telah mendapatkan 3 UTXO: satu untuk 4.000 sat, satu untuk 6.000 sat, dan satu untuk 11.000 sat. Oleh karena itu, Alice memiliki saldo bersih -4.000 sat pada transaksi ini, yang sesuai dengan harga baguette.

Dalam contoh ini, saya sengaja mengabaikan biaya penambangan agar lebih mudah dipahami. Pada kenyataannya, biaya transaksi ditanggung sepenuhnya oleh penerbit.

### Apa saja tujuan dari transaksi Stonewall?

Struktur Stonewall menambahkan sejumlah besar entropi ke dalam transaksi, mengaburkan garis analisis rantai. Dilihat dari luar, transaksi seperti itu dapat ditafsirkan sebagai koin mini antara dua orang. Namun pada kenyataannya, ini adalah sebuah pembayaran. Oleh karena itu, metode ini menciptakan ketidakpastian dalam analisis rantai, atau bahkan menyebabkan petunjuk yang salah.

Mari kita ambil contoh Alice di toko roti Bob. Transaksi pada blockchain akan terlihat seperti ini:

![BTC204](assets/fr/174.webp)

Seorang pengamat luar yang mengandalkan heuristik analisis rantai yang umum dapat secara keliru menyimpulkan bahwa "*dua orang telah membuat sebuah coinjoin kecil, dengan masing-masing satu UTXO sebagai input dan dua UTXO sebagai output*". Menganalisis transaksi ini dari luar tidak akan mengarah pada penerapan CIOH, karena adanya dua output dengan jumlah yang sama menunjukkan pola coinjoin. Dari sudut pandang eksternal, CIOH tidak dapat diterapkan dalam kasus khusus ini.

![BTC204](assets/fr/175.webp)

Interpretasi ini tidak akurat, karena, seperti yang Anda ketahui, satu UTXO dikirim ke Bob si tukang roti, 2 input UTXO berasal dari Alice, dan dia memulihkan 3 output pertukaran.

![BTC204](assets/fr/176.webp)

Dan yang sangat menarik dari struktur transaksi Stonewall adalah, dari sudut pandang pengamat luar, struktur ini menyerupai transaksi Stonewall x2 dalam segala hal.

### Transaksi Stonewall x2

Stonewall x2 adalah sebuah bentuk transaksi Bitcoin spesifik lainnya yang juga bertujuan untuk meningkatkan kerahasiaan pengguna ketika melakukan pembelanjaan, namun kali ini dengan berkolaborasi dengan orang ketiga yang tidak terlibat dalam pembelanjaan tersebut. Metode ini bekerja seperti pseudo-coinjoin antara dua partisipan, sekaligus melakukan pembayaran kepada orang ketiga.

Pengoperasian transaksi Stonewall x2 relatif sederhana: kita menggunakan UTXO yang kita miliki untuk melakukan pembayaran, dan meminta bantuan pihak ketiga yang juga berkontribusi dengan UTXO miliknya. Transaksi ini berakhir dengan empat keluaran: dua di antaranya dalam jumlah yang sama, satu ditujukan ke alamat penerima pembayaran, yang lainnya ke alamat milik kolaborator. UTXO ketiga dikembalikan ke alamat lain milik kolaborator, yang memungkinkannya untuk mendapatkan kembali jumlah awal (tindakan netral baginya, dikurangi biaya penambangan), dan UTXO terakhir dikembalikan ke alamat milik kami, yang merupakan pertukaran pembayaran.

Dengan demikian, ada tiga peran yang berbeda dalam transaksi Stonewall x2:


- Penerbit, yang melakukan pembayaran aktual;
- Penerima, yang mungkin tidak menyadari sifat spesifik dari transaksi dan hanya mengharapkan pembayaran dari pengirim;
- Kolaborator, yang menyediakan bitcoin untuk menimbulkan keraguan pada analisis transaksi, sambil memulihkan dananya secara penuh pada akhirnya (tindakan netral baginya, dikurangi biaya penambangan).

Mari kita kembali ke contoh kita dengan Alice, yang berada di toko roti Bob untuk membeli roti baguette seharga 4.000 sat. Alice ingin membayar dengan bitcoin, dengan tetap menjaga kerahasiaan pembayarannya. Jadi dia memanggil temannya Charles, yang akan membantunya dalam proses ini.

![BTC204](assets/fr/177.webp)

Dengan menganalisis transaksi ini, kita dapat melihat bahwa Bob si pembuat roti sebenarnya menerima 4.000 sat sebagai pembayaran untuk baguette tersebut. Alice menggunakan 10.000 sat sebagai input dan menerima 6.000 sat sebagai output, yaitu saldo bersih sebesar -4.000 sat, yang sesuai dengan harga baguette. Sedangkan untuk Charles, ia memberikan 15.000 sat sebagai input dan menerima dua output: satu sebesar 4.000 sat dan yang lainnya sebesar 11.000 sat, memberikan saldo 0.

Dalam contoh ini, saya sengaja tidak mencantumkan biaya untuk membuatnya lebih mudah dipahami. Pada kenyataannya, biaya penambangan umumnya dibagi rata antara penerbit pembayaran dan kontributor.

### Apa saja tujuan dari transaksi Stonewall x2?

Seperti struktur Stonewall, struktur Stonewall x2 menambahkan banyak entropi pada transaksi dan membingungkan analisis rantai. Dilihat dari luar, transaksi seperti ini dapat diartikan sebagai sebuah koin kecil antara dua orang. Namun pada kenyataannya, ini adalah pembayaran. Oleh karena itu, metode ini menciptakan ketidakpastian dalam analisis rantai, atau bahkan menyebabkan petunjuk yang salah.

Mari kita ambil contoh Alice, Bob the Baker, dan Charles. Transaksi pada blockchain akan terlihat seperti ini:

![BTC204](assets/fr/178.webp)

Seorang pengamat luar yang mengandalkan heuristik analisis rantai yang umum mungkin akan salah menyimpulkan bahwa "*Alice dan Charles telah melakukan sebuah coinjoin kecil, dengan masing-masing satu UTXO sebagai input dan dua UTXO sebagai output*". Sekali lagi, menganalisis transaksi ini dari luar tidak mengarah pada penerapan ICOH, karena adanya dua output dengan jumlah yang sama menunjukkan pola coinjoin. Dari sudut pandang eksternal, CIOH tidak dapat diterapkan dalam kasus khusus ini.

![BTC204](assets/fr/179.webp)

Interpretasi ini salah, karena, seperti yang Anda ketahui, satu UTXO telah dikirim ke Bob si tukang roti, Alice hanya memiliki satu output pertukaran, dan Charles memiliki dua.

![BTC204](assets/fr/180.webp)

Dan sekali lagi, apa yang sangat menarik tentang struktur transaksi Stonewall x2 adalah bahwa, dari sudut pandang pengamat luar, strukturnya menyerupai transaksi Stonewall dalam segala hal.

### Apa perbedaan antara Stonewall dan Stonewall x2?

Transaksi StonewallX2 bekerja sama persis seperti transaksi Stonewall, kecuali yang pertama bersifat kolaboratif, sedangkan yang kedua tidak. Seperti yang telah kita lihat, transaksi StonewallX2 melibatkan partisipasi pihak ketiga (Charles), yang berada di luar pembayaran, dan yang akan menyediakan bitcoin-nya untuk meningkatkan kerahasiaan transaksi. Dalam transaksi Stonewall klasik, peran kolaborator diambil oleh pengirim.

![BTC204](assets/fr/181.webp)

Dari sudut pandang eksternal, pola transaksinya persis sama.

![BTC204](assets/fr/182.webp)

Fakta bahwa kedua struktur transaksi ini memiliki pola yang sama persis berarti bahwa meskipun pengamat luar berhasil mengidentifikasi pola "Stonewall (x2)", dia tidak akan memiliki semua informasi. Dia tidak akan dapat menentukan mana dari dua UTXO dengan jumlah yang sama yang sesuai dengan pembayaran. Selain itu, ia tidak akan dapat menentukan apakah dua UTXO dengan input berasal dari dua orang yang berbeda (Stonewall x2) atau apakah keduanya milik satu orang yang telah menggabungkannya (Stonewall).

Poin terakhir ini disebabkan oleh fakta bahwa transaksi Stonewall x2 mengikuti pola yang sama persis dengan transaksi Stonewall. Dilihat dari luar, dan tanpa informasi kontekstual tambahan, tidak mungkin untuk membedakan transaksi Stonewall dengan transaksi Stonewall x2. Yang pertama bukanlah transaksi kolaboratif, sedangkan yang kedua adalah transaksi kolaboratif. Hal ini menambah keraguan pada analisis salah satu transaksi ini.

### Kapan sebaiknya transaksi Stonewall dan Stonewall x2 digunakan?

Logikanya harus seperti berikut ketika Anda ingin menggunakan alat kerahasiaan untuk suatu pengeluaran:


- Sebagai prioritas, kita bisa memilih untuk membuat payjoin;
- Jika merchant tidak mendukung payjoin, transaksi kolaboratif dapat dilakukan dengan orang lain di luar pembayaran menggunakan struktur Stonewall x2;
- Jika Anda tidak dapat menemukan siapa pun untuk melakukan transaksi Stonewall x2, Anda dapat melakukan transaksi Stonewall saja, yang akan meniru perilaku transaksi Stonewall x2.

### Bagaimana cara menggunakan transaksi Stonewall dan Stonewall x2?

Transaksi Stonewall dan Stonewall x2 tersedia di aplikasi Samourai Wallet dan perangkat lunak Sparrow Wallet.

![BTC204](assets/fr/183.webp)

Namun, seperti halnya payjoin, setelah penangkapan para pendiri Samourai, transaksi Stonewall x2 sekarang hanya berfungsi dengan menukarkan PSBT secara manual antara pihak-pihak yang bersangkutan. Sayangnya, pertukaran otomatis melalui Soroban tidak lagi tersedia.

Anda juga dapat melakukan jenis transaksi ini secara manual dari perangkat lunak dompet Bitcoin apa pun.

Dalam bab berikutnya, kita akan melihat teknik kerahasiaan lain yang relatif tidak dikenal, tetapi sangat berguna sebagai pelengkap dari apa yang telah kita pelajari.

https://planb.network/tutorials/privacy/on-chain/stonewall-033daa45-d42c-40e1-9511-cea89751c3d4

https://planb.network/tutorials/privacy/on-chain/stonewall-x2-05120280-f6f9-4e14-9fb8-c9e603f73e5b

## Memantul

<chapterId>db9a20ac-a149-443d-884b-ea6c03f28499</chapterId>


Penggunaan struktur transaksi Bitcoin yang menambahkan ambiguitas pada analisis rantai, seperti coinjoin, sangat bermanfaat untuk perlindungan privasi. Akan tetapi, seperti yang telah kita bahas pada bab mengenai payjoin, transaksi coinjoin secara alami dapat diidentifikasi pada rantai. Ingat analogi yang kita buat antara enkripsi dan coinjoin: ketika sebuah file dienkripsi, pihak ketiga yang menemukan file yang dienkripsi tidak dapat mengakses isinya, akan tetapi dapat dengan jelas mengidentifikasi bahwa file tersebut telah dimodifikasi untuk menyembunyikan isinya. Hal yang sama berlaku untuk coinjoin: ketika seorang analis memeriksa sebuah transaksi coinjoin, walaupun dia tidak dapat membuat hubungan langsung antara input dan output (dan sebaliknya), dia tetap dapat mengenali bahwa transaksi yang diamati adalah sebuah coinjoin.

Bergantung pada bagaimana Anda berniat menggunakan bagian Anda setelah siklus coinjoin, fakta bahwa koin tersebut telah mengalami proses ini dapat menjadi masalah. Misalnya, jika Anda berencana untuk menjual koin Anda di platform bursa yang teregulasi, tetapi koin tersebut baru saja mengalami coinjoin, alat analisis rantai platform akan mendeteksi fakta ini. Platform kemudian dapat menolak untuk menerima UTXO Anda yang mengalami coinjoin, atau bahkan meminta penjelasan dari Anda, dengan risiko akun Anda ditangguhkan atau dana Anda dibekukan. Dalam beberapa kasus, platform juga dapat melaporkan perilaku Anda kepada otoritas negara (misalnya, yang diwajibkan oleh TRACFIN terhadap PSAN di Prancis).

![BTC204](assets/fr/184.webp)

Yang perlu kita hindari adalah alat yang mampu mengaburkan jejak masa lalu koin Bitcoin, untuk mengembalikan beberapa bentuk kesepadanan. Inilah tujuan dari ricochet.

![BTC204](assets/fr/185.webp)

### Apa yang dimaksud dengan ricochet?

Ricochet adalah sebuah teknik yang terdiri dari melakukan beberapa transaksi fiktif terhadap diri sendiri (sweep) untuk mensimulasikan transfer kepemilikan bitcoin. Alat ini berbeda dengan struktur transaksi lain yang telah kita bahas, karena alat ini tidak mendapatkan anonimitas prospektif, melainkan sebuah bentuk anonimitas retrospektif. Pada dasarnya, ricochet mengaburkan kekhususan yang dapat mengganggu kesetaraan koin Bitcoin karena masa lalunya.

Untuk memuluskan jejak yang ditinggalkan oleh peristiwa masa lalu pada koin, seperti siklus coinjoin, ricochet mengeksekusi empat transaksi berurutan di mana pengguna mentransfer dana ke dirinya sendiri di alamat yang berbeda.

![BTC204](assets/fr/186.webp)

Setelah rangkaian transaksi ini, alat ricochet akhirnya merutekan bitcoin ke tujuan akhirnya, seperti platform bursa.

![BTC204](assets/fr/187.webp)

Tujuannya adalah untuk menciptakan jarak yang mempengaruhi kesetaraan koin, seperti transaksi koin bersama, dan tindakan akhir pengeluaran, yang dapat menolak koin ini karena masa lalunya. Dengan demikian, alat analisis rantai dapat menyimpulkan bahwa kemungkinan ada perubahan kepemilikan setelah kejadian tersebut, dan menganggap koin ini dapat dipertukarkan. Dalam kasus coinjoin, alat analisis blockchain dapat mengasumsikan bahwa bukan orang yang sama yang mengirimkan bitcoin dan melakukan coinjoin, dan oleh karena itu tidak ada gunanya untuk mengambil tindakan terhadap pengirimnya.

![BTC204](assets/fr/188.webp)

### Mengapa ini berhasil?

Dihadapkan dengan metode pantulan ini, orang mungkin membayangkan bahwa perangkat lunak analisis rantai akan memperdalam pemeriksaannya melampaui empat pantulan. Akan tetapi, platform-platform ini menghadapi dilema dalam mengoptimalkan ambang batas pendeteksian. Mereka harus menetapkan batas jumlah lompatan setelah itu mereka menerima bahwa perubahan properti mungkin telah terjadi, dan bahwa hubungan dengan peristiwa sebelumnya (seperti coinjoin) harus diabaikan.

![BTC204](assets/fr/189.webp)

Namun, menetapkan ambang batas ini berisiko: setiap penambahan jumlah lompatan yang diamati secara eksponensial meningkatkan volume positif palsu, yaitu individu yang secara keliru ditandai sebagai peserta dalam suatu peristiwa, padahal sebenarnya operasi tersebut dilakukan oleh orang lain. Skenario ini menimbulkan risiko besar bagi perusahaan-perusahaan ini, karena positif palsu menyebabkan ketidakpuasan, yang dapat mendorong pelanggan yang terkena dampak ke kompetisi. Dalam jangka panjang, ambang batas deteksi yang terlalu tinggi menyebabkan platform kehilangan lebih banyak pelanggan daripada pesaingnya, yang dapat mengancam kelangsungan hidupnya. Oleh karena itu, sulit bagi platform ini untuk meningkatkan jumlah pantulan yang diamati, dan 4 sering kali merupakan angka yang cukup untuk melawan analisis mereka.

Fenomena yang diamati di sini agak mirip dengan teori enam derajat pemisahan.

Teori enam derajat pemisahan menunjukkan bahwa setiap orang di Bumi terhubung dengan orang lain melalui rantai hubungan yang terdiri dari paling banyak enam perantara. Oleh karena itu, cukup dengan melewati serangkaian enam orang, yang masing-masing secara pribadi mengenal orang berikutnya, untuk menjangkau individu mana pun di dunia.

Dalam kasus transaksi Bitcoin, kami menemukan fenomena yang sama. Dengan menelusuri sejumlah transaksi Bitcoin, kita pasti akan menemukan koin bersama. Metode ricochet mengambil keuntungan dari prinsip ini dengan menggunakan jumlah lompatan yang lebih banyak daripada yang dapat dilacak oleh platform bursa. Jika platform memutuskan untuk melacak lebih banyak transaksi, maka dapat dengan mudah menambahkan lompatan ekstra untuk menghindari langkah ini.

### Kapan dan bagaimana cara menggunakan ricochet?

Kasus penggunaan yang paling umum untuk ricochet terjadi ketika diperlukan untuk menyembunyikan partisipasi sebelumnya dalam coinjoin pada UTXO yang Anda miliki. Idealnya, sebaiknya hindari mentransfer bitcoin yang telah mengalami coinjoin ke entitas yang diatur. Namun demikian, jika Anda tidak memiliki pilihan lain, terutama dalam kebutuhan mendesak untuk melikuidasi bitcoin dalam mata uang negara, ricochet menawarkan solusi yang efektif.

Metode ini efektif tidak hanya untuk coinjoin, tetapi juga untuk tanda lain yang dapat mengganggu kompatibilitas bagian.

Ide untuk metode ricochet ini awalnya berasal dari tim Samourai Wallet, yang mengintegrasikannya ke dalam aplikasi mereka untuk mengotomatiskan prosesnya. Layanan ini tidak gratis di Samourai, karena ricochet melibatkan biaya layanan sebesar 100.000 sat, ditambah biaya penambangan. Oleh karena itu, penggunaannya direkomendasikan untuk transfer dalam jumlah yang signifikan.

![BTC204](assets/fr/190.webp)

Aplikasi Samurai menawarkan dua varian pantulan:


- Diperkuat memantul, atau "pengiriman terhuyung-huyung", yang menawarkan keuntungan menyebarkan biaya layanan Samurai ke dalam lima transaksi yang berurutan. Opsi ini juga memastikan bahwa setiap transaksi disiarkan pada waktu yang berbeda dan dicatat dalam blok yang berbeda, meniru semirip mungkin perilaku perubahan pemilik. Meskipun lebih lambat, metode ini lebih disukai bagi mereka yang tidak terburu-buru, karena memaksimalkan efisiensi ricochet dengan memperkuat ketahanannya terhadap analisis rantai;

![BTC204](assets/fr/191.webp)


- Ricochet klasik, yang dirancang untuk menjalankan operasi dengan cepat, menyiarkan semua transaksi dalam interval waktu yang lebih singkat. Oleh karena itu, metode ini menawarkan lebih sedikit kerahasiaan dan lebih sedikit resistensi terhadap analisis daripada metode yang diperkuat. Metode ini hanya boleh digunakan untuk pengiriman yang mendesak.

![BTC204](assets/fr/192.webp)

Memantulkan berarti mengirimkan bitcoin ke diri Anda sendiri. Sangat mungkin untuk memantulkan bitcoin secara manual pada perangkat lunak dompet apa pun, tanpa menggunakan alat khusus. Yang harus Anda lakukan adalah mentransfer koin yang sama ke diri Anda sendiri secara berturut-turut, menggunakan alamat baru yang kosong setiap kali.

Pada bab berikutnya, kita akan melihat berbagai teknik untuk transfer kepemilikan secara rahasia. Metode-metode ini berbeda secara radikal dari yang telah kita bahas sejauh ini, baik dari segi operasi maupun hasil.

https://planb.network/tutorials/privacy/on-chain/ricochet-e0bb1afe-becd-44a6-a940-88a463756589

## Pengalihan kepemilikan secara rahasia

<chapterId>a2067036-849c-4d6b-87d2-44235cfae7a1</chapterId>


Teknik kerahasiaan Bitcoin lainnya adalah transfer kepemilikan secara rahasia. Metode ini bertujuan untuk memindahkan kepemilikan Bitcoin dari satu orang ke orang lain, dan sebaliknya, tanpa transaksi secara eksplisit terlihat di blockchain. Mari kita lihat berbagai teknik yang tersedia, beserta kelebihan dan kekurangannya.

### Penukaran koin

Coinwap didasarkan pada konsep yang relatif sederhana: ia menggunakan kontrak pintar untuk memfasilitasi transfer kepemilikan bitcoin antara dua pengguna, tanpa perlu kepercayaan dan tanpa transfer ini terlihat secara eksplisit di blockchain.

![BTC204](assets/fr/193.webp)

Mari kita bayangkan sebuah contoh naif dengan Alice dan Bob. Alice memiliki 1 BTC yang diamankan dengan private key $A$, dan Bob juga memiliki 1 BTC yang diamankan dengan private key $B$. Secara teoritis, mereka dapat menukarkan private key mereka melalui saluran komunikasi eksternal untuk melakukan transfer rahasia.

![BTC204](assets/fr/194.webp)

Akan tetapi, metode yang naif ini memiliki risiko yang tinggi dalam hal kepercayaan. Tidak ada yang dapat menghentikan Alice untuk menyimpan salinan private key $A$ setelah pertukaran dan menggunakannya nanti untuk mencuri bitcoin, setelah kunci tersebut berada di tangan Bob.

![BTC204](assets/fr/195.webp)

Selain itu, tidak ada jaminan bahwa Alice tidak akan menerima private key $B$ milik Bob dan tidak akan pernah memberikan private key $A$ miliknya sebagai gantinya. Oleh karena itu, pertukaran ini bergantung pada kepercayaan yang berlebihan di antara kedua belah pihak, dan tidak efektif untuk memastikan transfer kepemilikan yang aman dan rahasia.

![BTC204](assets/fr/196.webp)

Untuk mengatasi masalah ini dan memungkinkan pertukaran antara pihak-pihak yang tidak saling percaya, kita akan menggunakan sistem kontrak pintar. Kontrak pintar adalah sebuah program yang dijalankan secara otomatis ketika kondisi yang telah ditentukan terpenuhi. Dalam kasus kami, ini memastikan bahwa pertukaran properti terjadi secara otomatis, tanpa perlu saling percaya.

Hal ini dapat dicapai dengan menggunakan HTLC (*Hash Time-Locked Contracts*) atau PTLC (*Point Time-Locked Contracts*). Kedua protokol ini beroperasi dengan cara yang sama, menggunakan sistem penguncian waktu yang memastikan bahwa pertukaran diselesaikan dengan sukses atau dibatalkan sepenuhnya, sehingga melindungi integritas dana kedua belah pihak. Perbedaan utama antara HTLC dan PTLC adalah bahwa HTLC menggunakan hash dan preimage untuk mengamankan transaksi, sedangkan PTLC menggunakan Tanda Tangan Adaptor.

Dalam skenario pertukaran koin menggunakan HTLC atau PTLC antara Alice dan Bob, pertukaran berlangsung dengan aman: berhasil dan masing-masing menerima BTC satu sama lain, atau gagal dan masing-masing menyimpan BTC-nya sendiri. Hal ini membuat salah satu pihak tidak mungkin menipu atau mencuri BTC pihak lain.

> *HTLC juga merupakan mekanisme yang digunakan untuk merutekan pembayaran dengan aman melalui saluran dua arah Lightning Network*
Penggunaan Tanda Tangan Adaptor sangat menarik dalam konteks ini, karena memungkinkan untuk membuang skrip tradisional (mekanisme yang kadang-kadang disebut sebagai "skrip tanpa skrip"). Fitur ini mengurangi biaya yang terkait dengan pertukaran. Keuntungan utama lain dari Tanda Tangan Adaptor adalah bahwa mereka tidak memerlukan penggunaan hash yang sama untuk kedua belah pihak yang melakukan transaksi, sehingga menghindari kebutuhan untuk mengungkapkan hubungan langsung di antara mereka dalam beberapa jenis pertukaran.

### Tanda Tangan Adaptor

Tanda Tangan Adaptor adalah metode kriptografi yang mengintegrasikan tanda tangan yang valid dengan tanda tangan tambahan, yang disebut "_tanda tangan adaptor_", untuk mengungkapkan data rahasia. Mekanisme ini dirancang sedemikian rupa sehingga pengetahuan tentang 2 dari 3 elemen berikut: tanda tangan yang sah, tanda tangan adaptor dan rahasia, memungkinkan kita untuk menyimpulkan elemen ketiga yang hilang. Sebuah properti yang menarik dari metode ini adalah, jika kita mengetahui tanda tangan adaptor rekan kita dan titik spesifik pada kurva elips yang terkait dengan rahasia yang digunakan untuk menghitung tanda tangan adaptor tersebut, kita dapat memperoleh tanda tangan adaptor kita sendiri yang akan kompatibel dengan rahasia yang sama, tanpa harus memiliki akses langsung ke rahasia itu sendiri.

Dalam sebuah coinswap, penggunaan Tanda Tangan Adaptor memungkinkan pengungkapan dua informasi sensitif secara bersamaan di antara para partisipan, sehingga tidak perlu lagi adanya rasa saling percaya. Mari kita ambil contoh untuk mengilustrasikan proses ini dengan Alice dan Bob, yang ingin menukarkan kepemilikan masing-masing 1 BTC, tetapi tidak saling percaya. Mereka menggunakan Tanda Tangan Adaptor untuk menghilangkan kebutuhan untuk saling percaya dalam pertukaran ini. Berikut cara mereka melakukannya:


- Alice memulai pertukaran dengan membuat transaksi $m_A$ yang mengirimkan 1 BTC ke Bob. Dia membuat tanda tangan $s_A$, yang memvalidasi transaksi ini, dengan menggunakan kunci pribadinya $p_A$ ($P_A = p_A \cdot G$), sebuah nonce $n_A$ ($N_A = n_A \cdot G$), dan sebuah rahasia $t$ ($T = t \cdot G$):

$$s_A = n_A + t + H(N_A + T \paralel P_A \paralel m_A) \cdot p_A$$


- Alice menghitung tanda tangan adaptor $s_A'$ dengan mengurangkan rahasia $t$ dari tanda tangan sebenarnya $s_A$ :

$$s_A' = s_A - t$$


- Alice mengirimkan kepada Bob adaptor tanda tangannya $s'_A$, transaksi yang belum ditandatangani $m_A$, titik yang berhubungan dengan rahasia ($T$), dan titik yang berhubungan dengan nonce ($N_A$). Elemen-elemen ini membentuk apa yang dikenal sebagai "adaptor". Penting untuk diperhatikan bahwa, hanya dengan informasi ini, Bob tidak dapat memulihkan BTC milik Alice.
- Akan tetapi, Bob dapat mengecek bahwa Alice tidak mencoba untuk mencuri darinya. Untuk melakukan hal ini, ia memeriksa apakah tanda tangan adaptor Alice $s_A'$ benar-benar sesuai dengan transaksi yang diusulkan $m_A$. Jika persamaan berikut ini benar, maka ia dapat yakin bahwa tanda tangan adaptor Alice adalah valid:

$$s_A' \cdot G = N_A + H(N_A + T \paralel P_A \paralel m_A) \cdot P_A$$


- Verifikasi ini memberikan jaminan yang cukup bagi Bob bahwa ia dapat melanjutkan pertukaran dengan penuh keyakinan. Dia kemudian membuat transaksi sendiri $m_B$, yang ditujukan untuk mengirim 1 BTC ke Alice, dan menghasilkan tanda tangan adaptornya $s_B'$, yang juga akan ditautkan ke rahasia yang sama $t$. Pada tahap ini, hanya Alice yang mengetahui nilai $t$; Bob hanya mengetahui titik $T$ yang dikirimkan Alice kepadanya:

$$s_B' = n_B + H(N_B + T \paralel P_B \paralel m_B) \cdot p_B$$


- Bob mengirimkan kepada Alice tanda tangan adaptornya $s_B'$, transaksi yang belum ditandatangani $m_B$, serta titik yang berhubungan dengan rahasia ($T$) dan titik yang berhubungan dengan nonce ($N_B$). Alice, yang mengetahui rahasia $t$, sekarang dapat menggabungkan tanda tangan adaptor Bob $s_B'$ dengan rahasia ini untuk menghasilkan tanda tangan yang valid $s_B$ untuk transaksi $m_B$ yang akan mentransfer BTC Bob kepadanya:

$$s_B = s_B' + t$$

$$(s_B' + t) \cdot G = N_B + T + H(N_B + T \paralel P_B \paralel m_B) \cdot P_B$$


- Alice menyiarkan transaksi $m_B$ yang telah ditandatangani ini pada blockchain Bitcoin untuk mengambil BTC yang dijanjikan oleh Bob. Ketika Bob melihat transaksi ini di blockchain, ia dapat mengekstrak tanda tangan $s_B = s_B' + t$. Dengan informasi ini, Bob kemudian dapat mengisolasi rahasia $t$ yang ia butuhkan:

$$t = (s_B' + t) - s_B' = s_B - s_B'$$


- Dan $t$ rahasia ini adalah satu-satunya elemen yang hilang bagi Bob untuk menghasilkan tanda tangan yang valid $s_A$ dari tanda tangan adaptor Alice, yaitu $s_A'$. Tanda tangan ini memvalidasi transaksi $m_A$, yang mengirimkan BTC dari Alice ke Bob. Bob kemudian menghitung $s_A$ dan menyiarkan transaksi $m_A$ di blockchain:

$$s_A = s_A' + t$$

$$(s_A' + t) \cdot G = N_A + T + H(N_A + T \paralel P_A \paralel m_A) \cdot P_A$$

Mari kita rangkum bagaimana cara kerja Tanda Tangan Adaptor dalam coinswap. Pada awalnya, Alice mengirimkan sebuah transaksi yang belum ditandatangani kepada Bob disertai dengan adaptor, yang memungkinkan Bob untuk memverifikasi bahwa rahasia yang diungkapkan nanti akan memberinya akses ke bitcoin. Sebagai gantinya, Bob mengirim Alice transaksi dan adaptor yang belum ditandatangani miliknya. Alice kemudian dapat menyelesaikan transaksi Bob dan mengambil bitcoin dengan menyiarkan transaksi yang valid berkat rahasia tersebut. Ketika transaksi ini dipublikasikan di blockchain, Bob memiliki kemampuan untuk mengekstrak rahasia tersebut dan dengan demikian membuka kunci transaksi Alice. Akibatnya, jika Alice memulai transfer bitcoin Bob, Bob dapat, pada gilirannya, mengakses bitcoin Alice tanpa perlu saling percaya.

Perlu diketahui bahwa coinswap pertama kali diusulkan oleh [Gregory Maxwell pada bulan Oktober 2013 di BitcoinTalk](https://bitcointalk.org/index.php?topic=321228.0).

### Pertukaran atom

Dengan cara yang mirip dengan coinswap, dan menggunakan jenis kontrak pintar yang sama, juga memungkinkan untuk melakukan atomic swap. Atomic swap memungkinkan pertukaran langsung mata uang kripto yang berbeda, seperti BTC dan XMR, antara dua pengguna tanpa memerlukan kepercayaan atau intervensi perantara. Pertukaran ini disebut "atomic" karena hanya ada dua kemungkinan hasil yang mungkin terjadi: pertukaran berhasil dan kedua belah pihak merasa puas, atau gagal dan masing-masing tetap memiliki mata uang kripto aslinya, sehingga tidak perlu mempercayai pihak lain.

![BTC204](assets/fr/197.webp)

Atomic swap dan coinswap memiliki metode operasi yang sama dan menawarkan keuntungan dan kerugian yang sama dalam hal kerahasiaan. Memang, dari sudut pandang Bitcoin, atomic swap sebanding dengan coinswap yang dilakukan dalam dua tahap. Pertama, kita menukarkan BTC kita dengan mata uang kripto lain, kemudian mata uang kripto ini dapat ditukarkan dengan BTC lainnya. Pada akhirnya, kita mendapatkan kembali BTC milik pengguna lain. Inilah mengapa, dalam analisis masalah kerahasiaan, saya mengelompokkan kedua protokol ini di bawah kategori pertukaran rahasia.

![BTC204](assets/fr/198.webp)

Namun, berhati-hatilah, karena tidak seperti coinswap, atomic swap dapat menyebabkan ketidakseimbangan dalam hal likuiditas yang tersedia, terutama di bursa BTC/XMR. Pada umumnya lebih mudah untuk menukar bitcoin dengan altcoin, karena ada permintaan yang kuat untuk bitcoin, yang membuat harga premium tetap rendah untuk arah konversi ini. Namun, menukar altcoin dengan BTC bisa menjadi lebih rumit karena permintaan yang lebih rendah, dan sering kali menghasilkan premi yang sangat tinggi.

Terakhir, ketika atomic swap melibatkan bitcoin onchain dan bitcoin di jaringan Lightning, kita berbicara tentang "submarine swap".

### Apakah ini benar-benar berguna?

Transfer kepemilikan secara rahasia, seperti coinswap dan atomic swap, memiliki keuntungan untuk mengelabui heuristik analisis rantai. Metode-metode ini dapat menunjukkan bahwa transaksi melibatkan pengguna yang sama, padahal kepemilikan yang sebenarnya telah berpindah tangan. Akan tetapi, kelemahan utama dari metode-metode ini adalah bahwa metode-metode ini sangat beresiko tanpa menggunakan teknik tambahan untuk mematahkan riwayat koin.

Memang, ketika Alice melakukan coinswap atau atomic swap dengan Bob, dia menukar kepemilikan bitcoinnya dengan milik Bob. Dalam kasus pertukaran atom, pertukaran tersebut menyertakan altcoin, tetapi prinsipnya tetap sama. Dengan demikian, Alice berakhir dengan koin $B dan Bob dengan koin $A. Hal ini menambah keraguan pada analisis rantai, tetapi sejarah koin tetap dapat dilacak. Jika seorang analis memeriksa bagian $A$, dia dapat melacak aktivitas Alice sebelumnya, dan sebaliknya untuk bagian $B$.

![BTC204](assets/fr/199.webp)

Dari sudut pandang Alice, risikonya adalah riwayat koin $B$ dapat dianggap mencurigakan oleh entitas tertentu. Jika, misalnya, Bob mendapatkan koin $B$ melalui tindakan kriminal seperti peretasan, maka koin tersebut akan tetap terkait dengan aktivitas ilegal yang dilakukannya. Alice kemudian dapat menemukan dirinya memiliki koin yang tidak dapat ia transfer ke platform bursa yang teregulasi tanpa mengambil risiko dananya dibekukan, atau bahkan dituduh melakukan kejahatan Bob, meskipun ia tidak ada hubungannya dengan kejahatan tersebut.

![BTC204](assets/fr/200.webp)

Tak pelak lagi, metode kerahasiaan seperti coinswap atau atomic swap disukai oleh para penjahat yang dananya diawasi oleh pihak berwenang. Protokol ini memungkinkan mereka untuk membuang bitcoin mereka yang berada di bawah pengawasan untuk ditukar dengan bitcoin yang dapat dipertukarkan secara sempurna. Hal ini juga memungkinkan mereka untuk membuat pengalihan, dengan mengarahkan pihak berwenang ke pengguna lain. Jadi, ada tujuan ganda bagi orang-orang ini.

Dengan coinjoin, meskipun koin Anda tercampur dengan bitcoin yang dipantau, riwayat koin tersebut akan rusak, memberikan sebuah bentuk penyangkalan yang masuk akal yang tidak ada pada protokol transfer kepemilikan rahasia seperti coinswap atau atomic swap.

![BTC204](assets/fr/201.webp)

Jika Alice ingin menghindari risiko, ia harus menggunakan metode untuk memecahkan riwayat koin $B$, seperti mengirimkannya melalui coinjoin. Hal ini menimbulkan pertanyaan mengenai kegunaan dari menggabungkan transfer kepemilikan secara rahasia dan coinjoin. Coinjoin, dengan merusak sejarah koin, sudah menawarkan tingkat kerahasiaan yang cukup untuk Alice. Dengan demikian, pendapat saya adalah jika Alice ingin melindungi privasinya, akan lebih bijaksana untuk langsung melakukan coinjoin daripada melakukan coinswap yang diikuti dengan coinjoin.

Agar metode transfer kepemilikan secara rahasia dapat benar-benar efektif, dan menghindari resiko menghubungkan riwayat pengguna $A dengan pengguna $B, maka secara paradoksnya metode ini harus diketahui secara luas. Jika coinswap digunakan secara masif dan pihak berwenang mengetahui praktik umum ini, maka bentuk penolakan yang masuk akal dapat dilakukan. Akan tetapi, selama penggunaan transfer ini masih sangat kecil, saya rasa metode ini akan tetap terlalu beresiko untuk para pengguna.

Sampai saat ini, kita telah mempelajari metode kerahasiaan pada tingkat transaksi itu sendiri. Di bab berikutnya, kita akan melihat masalah di tingkat jaringan dan penyebaran transaksi.

## Privasi di jaringan P2P

<chapterId>04a2467b-db84-4076-a9ff-919be5135106</chapterId>


Pada Bagian 4, kita telah membahas pentingnya menggunakan sebuah node yang lengkap untuk melindungi kerahasiaan transaksi Anda. Akan tetapi, penting untuk memahami bahwa node Anda sendiri dapat menjadi sasaran serangan yang berusaha mengekstrak informasi mengenai aktivitas Anda. Oleh karena itu, pada bab ini, kita akan melihat berbagai langkah yang dapat Anda lakukan untuk melindungi privasi Anda, bukan pada tingkat transaksi itu sendiri atau aliran bitcoin, tetapi pada tingkat jaringan.

### Dandelion

Salah satu cara untuk menghindari berbagai serangan de-anonimisasi adalah dengan menggunakan proposal Dandelion. Protokol broadcast ini diformalkan dalam BIP156, tetapi belum pernah diimplementasikan pada Bitcoin.

Ide di balik Dandelion adalah untuk meningkatkan kerahasiaan perutean transaksi dalam jaringan Bitcoin untuk melawan berbagai bentuk serangan. Tujuan utamanya adalah untuk menyembunyikan node sumber yang pada awalnya menyiarkan sebuah transaksi di jaringan. Pengungkapan node ini dapat memungkinkan untuk menghubungkan transaksi Bitcoin ke alamat IP tertentu (jika node tersebut beroperasi di clearnet), yang dapat memberikan titik masuk untuk analisis rantai.

Hubungan antara aktivitas di Bitcoin dan alamat IP merupakan sebuah risiko yang cukup besar untuk kerahasiaan pengguna. Memang, banyak entitas yang dapat dengan mudah menghubungkan alamat IP dengan identitas pribadi. Ini termasuk pemerintah dan penyedia layanan Internet. Terlebih lagi, informasi ini dapat diakses oleh publik, misalnya, jika alamat IP dan data pribadi Anda bocor ketika database situs web diretas.

Dalam operasi Bitcoin klasik, transaksi yang dibuat oleh pengguna pada perangkat lunak dompetnya dikirimkan ke node pribadinya. Node ini akan segera menyiarkan transaksi baru tersebut ke semua peer yang terhubung dengannya.

![BTC204](assets/fr/202.webp)

Rekan-rekan ini kemudian memeriksa transaksi untuk memastikan bahwa transaksi tersebut sesuai dengan konsensus dan aturan standardisasi lokal. Setelah divalidasi, setiap rekan pada gilirannya meneruskan transaksi ke rekan-rekannya, dan seterusnya.

![BTC204](assets/fr/203.webp)

Distribusi transaksi yang menunggu integrasi ke dalam sebuah blok cukup seimbang dan dapat diprediksi secara statistik. Kelemahan ini dapat dieksploitasi oleh node mata-mata yang terlibat, yang berkolaborasi untuk memonitor dan menganalisa jaringan, untuk mengidentifikasi node pertama yang menyiarkan sebuah transaksi. Jika seorang pengamat berhasil menemukan node sumber, dia dapat mengasumsikan bahwa transaksi tersebut berasal dari operator node tersebut. Jenis pengamatan ini dapat digunakan untuk menghubungkan transaksi yang biasanya anonim ke alamat IP tertentu.

![BTC204](assets/fr/204.webp)

Tujuan dari BIP156 adalah untuk mengatasi masalah ini. Untuk melakukan ini, ia memperkenalkan fase tambahan dalam penyebaran transaksi baru untuk menjaga anonimitas sebelum disebarkan ke publik secara luas. Dandelion pertama kali menggunakan fase "stem" di mana transaksi dikirim melalui jalur node secara acak.

![BTC204](assets/fr/205.webp)

Transaksi kemudian disiarkan ke seluruh jaringan dalam fase "Fluff".

![BTC204](assets/fr/206.webp)

Batang dan fase "Fluff" merujuk pada perilaku penyebaran transaksi melalui jaringan, yang menyerupai bentuk dan perkembangan bunga dandelion ("Dandelion" dalam bahasa Inggris).

Dengan demikian, node mata-mata dapat secara potensial melacak transaksi kembali ke node yang memulai fase "Fluff" (penyiaran massal), namun node tersebut bukanlah yang pertama kali menyiarkan transaksi tersebut, karena ia menerimanya dari node terakhir pada batang. Jika node mata-mata tidak dapat melacak batang tersebut, maka mereka juga tidak dapat mengidentifikasi node sumber.

![BTC204](assets/fr/207.webp)

Bahkan dengan adanya spy node selama fase batang, keraguan selalu ada, karena begitu mereka menemukan node yang jujur dalam grafik difusi, mata-mata tidak dapat menentukan apakah node ini adalah sumber asli atau hanya perantara.

![BTC204](assets/fr/208.webp)

Metode perutean ini mengaburkan jejak yang mengarah kembali ke node sumber, sehingga sulit untuk melacak transaksi kembali melalui jaringan ke asalnya. Dengan demikian, Dandelion meningkatkan kerahasiaan dengan membatasi kemampuan lawan untuk menganonimkan jaringan. Metode ini menjadi lebih efektif ketika, selama fase "stemming", transaksi melewati sebuah node yang mengenkripsi komunikasi jaringannya, seperti pada Tor atau P2P Transport V2.

BIP156 belum diintegrasikan ke dalam Bitcoin Core dan saat ini diklasifikasikan sebagai "ditolak". Salah satu masalah utama dengan protokol ini adalah bahwa, selama fase batang, transaksi harus diteruskan melalui node perantara sebelum diverifikasi. Seperti yang telah kita lihat, pada model Bitcoin normal, setiap node memverifikasi transaksi terlebih dahulu sebelum menyiarkannya ke rekan-rekannya. Jika sebuah transaksi tidak sesuai dengan aturan konsensus node atau aturan standarisasi lokal, maka node tersebut akan mengabaikannya dan tidak mendistribusikannya. Proses ini penting untuk melawan serangan DoS, karena hanya transaksi yang valid yang disiarkan ke seluruh jaringan. Transaksi yang tidak valid, yang berpotensi dibuat secara massal untuk membebani jaringan, akan dihentikan di node pertama yang ditemui dan tidak disebarkan. Resiko utama dari Dandelion adalah protokol baru ini dapat memperkenalkan vektor baru untuk serangan DoS dengan mengijinkan transaksi yang tidak valid untuk disiarkan ke seluruh bagian jaringan.

### Transportasi P2P V2

P2P transport V2 adalah protokol jaringan lain yang dihadirkan dalam BIP324. Ini adalah versi baru dari protokol transport P2P Bitcoin yang menggabungkan enkripsi oportunistik untuk meningkatkan kerahasiaan dan keamanan komunikasi antar node.

Peningkatan ini dirancang untuk memecahkan beberapa masalah dengan versi dasar protokol P2P. Di satu sisi, ini membuat data yang dipertukarkan tidak dapat dibedakan dari jenis data lain yang beredar di Internet untuk pengamat pasif. Tujuan utamanya adalah untuk mencegah pemerintah, ISP, dan penyedia VPN untuk memonitor pengguna Bitcoin secara besar-besaran. Hal ini juga membuat entitas-entitas tersebut lebih sulit untuk menentukan apakah seorang pengguna Internet juga merupakan seorang pengguna Bitcoin, yaitu apakah dia mengoperasikan sebuah node yang lengkap.

P2P V2 juga membantu mengurangi risiko penyensoran dan serangan dengan mendeteksi pola-pola tertentu dalam paket data. Hal ini memperumit dan membuat eksekusi berbagai jenis serangan Sybil menjadi lebih mahal di tingkat jaringan. Serangan Sybil terjadi ketika seorang pelaku membuat beberapa identitas palsu untuk mendapatkan keuntungan yang tidak adil. Dalam konteks jaringan Bitcoin, hal ini sering kali muncul sebagai sebuah aktor yang mengendalikan sejumlah besar node lengkap dan secara agresif menggunakannya untuk memperbanyak koneksi. Serangan Sybil dapat bersifat pasif, untuk mengumpulkan informasi dan membahayakan kerahasiaan pengguna, atau aktif, dalam bentuk serangan Eclipse. Serangan yang terakhir ini mengisolasi sebuah node tertentu dari seluruh jaringan, baik menyensor pengguna atau mengubah data yang diterimanya. Terakhir, P2P V2 juga membuat serangan *Man-In-The-Middle* (MITM) menjadi lebih mahal dan lebih mudah dideteksi.

Enkripsi yang diimplementasikan oleh P2P V2 tidak termasuk autentikasi, sehingga tidak menambah kerumitan yang tidak perlu, atau mengkompromikan fakta bahwa koneksi ke jaringan tetap tanpa izin. Namun demikian, protokol transport P2P yang baru ini menawarkan keamanan yang lebih baik terhadap serangan pasif, dan membuat serangan aktif menjadi jauh lebih mahal dan dapat dideteksi. Pengenalan aliran data acak semu dalam pesan jaringan membuatnya lebih sulit bagi penyerang untuk menyensor atau memanipulasi komunikasi.

Transportasi P2P V2 disertakan sebagai opsi (dinonaktifkan secara default) dalam Bitcoin Core versi 26.0, yang digunakan pada bulan Desember 2023. Kemudian diaktifkan secara default di versi 27.0 pada April 2024. Ini dapat dimodifikasi dengan opsi `v2transport=` dalam file konfigurasi.

### Tor

Solusi sederhana lain untuk menghindari risiko hilangnya kerahasiaan untuk simpul jaringan adalah menjalankannya sepenuhnya di bawah Tor.

Tor adalah sebuah jaringan server relai (node) yang menganonimkan asal koneksi TCP di Internet. Tor bekerja dengan mengenkapsulasi data dalam beberapa lapisan enkripsi. Setiap simpul relai menghilangkan satu lapisan untuk mengungkapkan alamat simpul berikutnya, sampai tujuan akhir tercapai. Jaringan Tor memastikan anonimitas dengan mencegah simpul perantara mengetahui asal dan tujuan data, sehingga sangat sulit bagi pengamat untuk melacak aktivitas pengguna.

![BTC204](assets/fr/209.webp)

Tor tidak hanya mengenkripsi data, tetapi juga menyamarkan asal dan tujuan komunikasi. Dengan menggunakan Tor untuk komunikasi dari node pribadi Anda, Anda memperkuat kerahasiaan transaksi Anda: ISP Anda tidak dapat mendekripsi komunikasi, dan node lain dalam jaringan Bitcoin tidak dapat mengidentifikasi alamat IP node sumber. Terlebih lagi, Tor juga menyembunyikan penggunaan Bitcoin Anda dari ISP Anda.

Resiko utama dari metode ini adalah Tor merupakan sebuah protokol yang tidak bergantung pada Bitcoin. Jika Anda memiliki sebuah node Bitcoin yang berjalan di bawah Tor dan Tor berhenti bekerja, maka node Bitcoin Anda tidak akan lagi dapat berkomunikasi.

Selain itu, penting untuk dicatat bahwa komunikasi pada Tor lebih lambat. Latensi ini sangat mengganggu selama peluncuran awal sebuah node, karena IBD (*Initial Block Download*) membutuhkan banyak komunikasi. Akibatnya, sinkronisasi awal Anda dengan jaringan Bitcoin dapat memakan waktu lebih lama dengan menggunakan Tor. Anda juga dapat melakukan IBD di clearnet, kemudian mengaktifkan Tor sebagai langkah kedua. Meskipun metode ini mengungkapkan keberadaan node Bitcoin Anda ke ISP Anda, metode ini melindungi informasi transaksi pribadi Anda setelah Anda beralih ke Tor.

Setelah menjelajahi berbagai metode kerahasiaan pada tingkat jaringan, dalam beberapa bab berikutnya saya juga ingin memperkenalkan Anda pada dua solusi elegan untuk menghindari penggunaan ulang alamat: BIP47 dan Pembayaran Senyap.

## BIP47 dan kode pembayaran yang dapat digunakan kembali

<chapterId>ad88e076-a04b-4aec-b3b2-7b4760175504</chapterId>


Seperti yang telah kita lihat pada bagian 3, penggunaan ulang alamat merupakan sebuah hambatan serius untuk kerahasiaan pengguna pada protokol Bitcoin. Untuk mengurangi risiko ini, sangat disarankan untuk membuat alamat penerima kosong untuk setiap pembayaran baru yang diterima di dompet. Walaupun pembuatan alamat baru saat ini telah disederhanakan dengan penggunaan perangkat lunak modern dan dompet hirarkis deterministik, praktik ini mungkin terlihat berlawanan dengan intuisi.

![BTC204](assets/fr/210.webp)

Dalam sistem perbankan tradisional, misalnya, kita terbiasa membagikan IBAN kita, yang selalu sama. Setelah kita memberikannya kepada seseorang, mereka dapat mengirimi kita banyak pembayaran tanpa harus berinteraksi dengan kita lagi. Neo-bank juga menawarkan kemungkinan yang lebih modern, seperti penggunaan alamat email unik di PayPal atau RevTags di Revolut. Bahkan di luar bidang keuangan, pengenal kita sehari-hari seperti alamat pos, nomor telepon, dan alamat email juga unik dan permanen. Kita tidak perlu memperbaruinya untuk setiap interaksi baru.

![BTC204](assets/fr/211.webp)

Akan tetapi, Bitcoin bekerja dengan cara yang berbeda: sebuah alamat penerima baru harus dibuat untuk setiap transaksi yang masuk. Kompromi antara kemudahan penggunaan dan kerahasiaan ini sudah ada sejak awal mula White Paper Bitcoin. Pada awal publikasi versi pertama dokumennya di akhir tahun 2008, Satoshi Nakamoto telah memperingatkan kita akan risiko ini:

**Sebagai firewall tambahan, pasangan kunci baru dapat digunakan untuk setiap transaksi agar tidak terhubung dengan pemilik yang sama

Ada banyak cara untuk menerima banyak pembayaran dengan satu pengenal tanpa harus menggunakan ulang sebuah alamat. Masing-masing memiliki kelebihan dan kekurangannya sendiri. Di antara metode-metode ini adalah BIP47, sebuah proposal yang dikembangkan oleh Justus Ranvier dan diterbitkan pada tahun 2015. Proposal ini bertujuan untuk membuat kode pembayaran yang dapat digunakan kembali yang memungkinkan beberapa transaksi dilakukan terhadap orang yang sama, sambil menghindari penggunaan ulang alamat. Singkatnya, BIP47 bertujuan untuk menawarkan sebuah sistem pembayaran yang intuitif seperti sebuah pengenal unik, dengan tetap menjaga kerahasiaan transaksi.

![BTC204](assets/fr/212.webp)

BIP47 tidak secara langsung meningkatkan kerahasiaan pengguna, karena pembayaran BIP47 menawarkan tingkat kerahasiaan yang sama dengan transaksi Bitcoin klasik yang menggunakan alamat kosong. Namun, BIP47 membuat penggunaan Bitcoin menjadi lebih nyaman dan intuitif, sebuah kemudahan yang biasanya akan membahayakan kerahasiaan. Berkat BIP47, kemudahan penggunaan ini mencapai tingkat kerahasiaan yang sama dengan transaksi klasik. Itulah mengapa BIP47 merupakan alat yang sangat berharga untuk menjaga privasi.

Pada awalnya, BIP47 diusulkan untuk diintegrasikan ke dalam Bitcoin Core, tetapi tidak pernah benar-benar diimplementasikan. Akan tetapi, beberapa aplikasi perangkat lunak memilih untuk mengimplementasikannya sendiri. Sebagai contoh, tim Samourai Wallet telah mengembangkan implementasi BIP47 mereka sendiri yang disebut "PayNym".

### Prinsip umum BIP47 dan PayNym

Tujuan dari BIP47 adalah untuk memungkinkan menerima pembayaran dalam jumlah besar tanpa menggunakan alamat yang sama. Hal ini didasarkan pada penggunaan kode pembayaran yang dapat digunakan kembali, yang memungkinkan penerbit yang berbeda untuk mengirim beberapa pembayaran ke satu kode milik pengguna lain. Sebagai hasilnya, penerima tidak perlu memberikan alamat baru yang kosong untuk setiap transaksi, yang sangat memudahkan pertukaran sekaligus menjaga kerahasiaan.

![BTC204](assets/fr/213.webp)

Oleh karena itu, seorang pengguna dapat membagikan kode pembayarannya dengan bebas, baik di jejaring sosial atau di situs webnya, tanpa risiko kehilangan kerahasiaan, tidak seperti dengan alamat penerima konvensional atau kunci publik.

Untuk melakukan transaksi, kedua belah pihak membutuhkan dompet Bitcoin dengan implementasi BIP47, seperti PayNym di Samurai Wallet atau Sparrow Wallet. Penggunaan bersama kode pembayaran mereka menciptakan saluran rahasia di antara mereka. Untuk membuat saluran ini secara efektif, penerbit harus melakukan transaksi tertentu pada blockchain Bitcoin, yang dikenal sebagai "transaksi notifikasi" (lebih lanjut tentang ini nanti).

Penggabungan kode pembayaran dari dua pengguna menghasilkan rahasia bersama, yang pada gilirannya akan menghasilkan sejumlah besar alamat penerima Bitcoin yang unik (tepatnya 2^32, atau sekitar 4 miliar). Dengan cara ini, pembayaran yang dilakukan melalui BIP47 tidak benar-benar ditujukan kepada kode pembayaran itu sendiri, melainkan kepada alamat penerimaan klasik yang berasal dari kode pembayaran para pengguna yang terlibat.

Kode pembayaran berfungsi sebagai pengenal virtual yang berasal dari seed portofolio. Dalam struktur derivasi hirarkis portofolio, kode pembayaran diposisikan pada level 3, yaitu pada level akun.

![BTC204](assets/fr/214.webp)

Target derivasi untuk BIP47 diidentifikasi dengan indeks `47'` (`x8000002F`), yang mengacu pada BIP47. Contoh jalur derivasi untuk kode pembayaran yang dapat digunakan kembali adalah sebagai berikut:

```plaintext
m/47'/0'/0'/
```

Untuk memberi Anda gambaran seperti apa kode pembayaran itu, berikut ini milik saya:

```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

Kode ini juga dapat dikodekan sebagai kode QR, untuk memudahkan komunikasi, seperti halnya alamat penerimaan konvensional.

Sedangkan untuk PayNym Bots, robot yang kadang-kadang terlihat di Twitter, ini adalah representasi visual dari kode pembayaran, yang dibuat oleh Samourai Wallet. Mereka dibuat menggunakan fungsi hash, sehingga hampir tidak ada keunikannya. Bentuknya berupa serangkaian karakter kecil yang dimulai dengan `+`:

```plaintext
+throbbingpond8B1
+twilightresonance487
+billowingfire340
```

Avatar ini juga dapat direpresentasikan sebagai gambar:

![BTC204](assets/fr/215.webp)

Meskipun robot ini tidak memiliki fungsionalitas teknis khusus dalam kerangka kerja BIP47, namun robot ini berperan dalam memfasilitasi interaksi pengguna dengan menawarkan identitas visual yang mudah dikenali.

---
*Pada bagian selanjutnya dari bab ini yang didedikasikan untuk BIP47, kita akan melihat secara mendetail bagaimana cara kerjanya, dengan penekanan khusus pada metode kriptografi yang digunakan. Untuk memahami penjelasan yang agak teknis ini, sangat penting untuk terlebih dahulu memahami struktur dompet HD, prosedur penurunan kunci dan dasar-dasar kriptografi kurva eliptik. Jika Anda ingin mempelajari konsep-konsep ini lebih dalam, kursus pelatihan gratis lainnya tersedia di Plan ₿ Network :*

https://planb.network/courses/46b0ced2-9028-4a61-8fbc-3b005ee8d70f

*Saya tetap menyarankan Anda untuk mengikutinya, karena memahami operasi teknis BIP47 akan membuat Anda lebih mudah memahami proposal lain yang serupa, yang akan kita bahas di bab-bab berikutnya*

---
### Kode pembayaran yang dapat digunakan kembali

Seperti yang telah disebutkan sebelumnya, kode pembayaran yang dapat digunakan kembali terletak di kedalaman 3 dompet HD, membuatnya sebanding dengan `xpub`, baik dari segi posisinya dalam struktur dompet maupun perannya.

Kode pembayaran 80-byte tersebut dirinci sebagai berikut:


- Byte `0`: Versi **. Untuk versi pertama BIP47, byte ini diatur ke `0x01`;
- Byte `1`: Bidang bit**. Ruang ini disediakan untuk mengintegrasikan indikasi tambahan untuk penggunaan tertentu. Untuk penggunaan PayNym klasik, byte ini diatur ke `x00`;
- Byte `2`: Paritas dari `y`**. Byte ini adalah `0x02` atau `0x03`, yang menunjukkan apakah ordinat kunci publik genap atau ganjil, karena kunci publik yang digunakan adalah kunci publik yang dikompresi;
- Dari byte `3` hingga byte `34`: Nilai dari `x`**. Byte ini mewakili absis dari kunci publik. Gabungan dari `x` dan paritas dari `y` membentuk kunci publik terkompresi yang lengkap;
- Dari byte `35` hingga byte `66`: Kode string**. Ruang ini berisi kode string yang terkait dengan kunci publik;
- Dari byte `67` hingga byte `79`: Padding**. Ruang ini dimaksudkan untuk kemungkinan evolusi di masa mendatang. Untuk versi saat ini, kami hanya menempatkan nol di sini untuk mencapai ukuran 80 byte yang diperlukan untuk output `OP_RETURN`.

Berikut adalah representasi heksadesimal dari kode pembayaran yang dapat digunakan kembali yang telah disajikan di bagian sebelumnya:

```plaintext
0x010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

![BTC204](assets/fr/216.webp)

Selanjutnya, byte awalan `P` harus ditambahkan di awal untuk menunjukkan dengan jelas bahwa ini adalah kode pembayaran. Byte ini diwakili oleh `x47`:

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

Terakhir, untuk memastikan integritas kode pembayaran, perhitungan checksum dilakukan dengan menggunakan `HASH256`, yang terdiri dari hash ganda menggunakan fungsi `SHA256`. Empat byte pertama dari hash ini kemudian digabungkan di akhir kode pembayaran:

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4
```

![BTC204](assets/fr/217.webp)

Setelah langkah-langkah ini selesai, kode pembayaran sudah siap. Yang tersisa hanyalah mengonversinya ke base 58 untuk mendapatkan versi final:

```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

Dalam proses pembuatan kode pembayaran, kami menggunakan kunci publik terkompresi dan kode string. Keduanya diturunkan secara deterministik dan hirarkis dari seed wallet. Jalur penurunan yang digunakan untuk mencapai hal ini adalah :

```plaintext
m/47'/0'/0'/
```

Secara konkret, untuk menghasilkan kunci publik terkompresi dan kode string yang terkait dengan kode pembayaran yang dapat digunakan kembali, kita mulai dengan menghitung kunci privat utama dari seed wallet. Kemudian kita lanjutkan dengan menurunkan sepasang anak kunci dengan menggunakan indeks `47 + 2^31` (turunan yang diperkuat). Ini diikuti dengan dua turunan lebih lanjut dari pasangan anak kunci, masing-masing menggunakan indeks `2^31` (turunan yang diperkuat).

![BTC204](assets/fr/218.webp)

### Pertukaran kunci Diffie-Hellman pada kurva elips (ECDH)

Protokol kriptografi yang menjadi inti dari BIP47 dikenal dengan singkatan ECDH, yaitu *Eliptic-Curve Diffie-Hellman*. Metode ini merupakan varian dari pertukaran kunci Diffie-Hellman yang asli.

Diperkenalkan pada tahun 1976, Diffie-Hellman adalah protokol perjanjian kunci yang memungkinkan dua pihak, masing-masing dilengkapi dengan pasangan kunci (publik dan privat), untuk menyepakati rahasia bersama, bahkan ketika berkomunikasi hanya melalui saluran publik yang tidak aman.

![BTC204](assets/fr/219.webp)

Rahasia bersama ini (dalam hal ini, kunci biru) kemudian dapat digunakan untuk operasi lain. Biasanya, rahasia bersama ini dapat digunakan untuk mengenkripsi dan mendekripsi komunikasi pada jaringan yang tidak aman:

![BTC204](assets/fr/220.webp)

Untuk mencapai hal ini, Diffie-Hellman menggunakan aritmatika modular untuk menghitung rahasia bersama. Berikut ini cara kerjanya dalam istilah awam:


- Alice dan Bob menyetujui warna yang sama, dalam hal ini kuning, yang merupakan data publik (penyerang mengetahui warna ini);
- Alice memilih warna rahasia, dalam hal ini merah, dan mencampurkan keduanya untuk mendapatkan warna jingga;
- Bob juga memilih warna rahasia, dalam hal ini biru, dan mencampurkannya dengan warna kuning untuk mendapatkan warna hijau;
- Mereka kemudian menukar warna yang dihasilkan, oranye dan hijau. Pertukaran ini dapat terjadi pada jaringan yang tidak aman dan diamati oleh penyerang;
- Dengan mencampurkan warna hijau milik Bob dengan warna rahasianya sendiri, Alice menghasilkan warna cokelat;
- Bob, melakukan hal yang sama dengan warna oranye dan biru rahasia Alice, juga mendapatkan warna cokelat.

![BTC204](assets/fr/221.webp)

Dalam kepopuleran ini, warna coklat mewakili rahasia yang dimiliki oleh Alice dan Bob. Bayangkan, pada kenyataannya, tidak mungkin bagi penyerang untuk memisahkan warna oranye dan hijau, untuk menemukan warna rahasia Alice atau Bob.

Sekarang mari kita lihat bagaimana protokol ini benar-benar bekerja, bukan dengan analogi warna, tetapi menggunakan bilangan riil dan aritmatika modular!

Sebelum kita membahas mekanisme Diffie-Hellman, izinkan saya mengingatkan Anda secara singkat mengenai dua konsep matematika penting yang akan kita perlukan:


- Bilangan prima adalah bilangan asli yang hanya memiliki dua pembagi: $ 1$ dan dirinya sendiri. Sebagai contoh, $7$ adalah bilangan prima karena hanya dapat dibagi oleh $1$ dan $7$. Di sisi lain, $8$ bukanlah bilangan prima, karena dapat dibagi dengan $1$, $2$, $4$ dan $8$. Oleh karena itu, bilangan ini memiliki empat pembagi bilangan bulat positif, bukan dua;
- **modulo** (dicatat sebagai $mod$ atau $\%$) adalah operasi matematika yang, di antara dua bilangan bulat, mengembalikan sisa pembagian Euclidean dari bilangan bulat pertama dengan bilangan bulat kedua. Sebagai contoh, $16\bmod 5 = $1$.

**Pertukaran kunci Diffie-Hellman antara Alice dan Bob terjadi sebagai berikut:**


- Alice dan Bob setuju dengan dua bilangan yang sama: $p$ dan $g$. $p$ adalah sebuah bilangan prima, dan semakin besar angkanya, semakin aman Diffie-Hellman. $g$ adalah sebuah akar primitif dari $p$. Kedua bilangan ini dapat dikomunikasikan secara jelas pada jaringan yang tidak aman. Mereka mewakili setara dengan **warna kuning** dalam popularisasi sebelumnya. Oleh karena itu, penting bagi Alice dan Bob untuk menggunakan nilai yang sama persis untuk $p$ dan $g$.
- Setelah parameter ini ditentukan, Alice dan Bob masing-masing memilih nomor acak rahasia. Alice menamai angka acak rahasianya dengan $a (setara dengan **warna merah**) dan Bob menamai angka $b (setara dengan **warna biru**). Angka-angka ini harus tetap dirahasiakan.
- Alih-alih menukar angka $a$ dan $b$ secara langsung, masing-masing pihak menghitung $A$ dan $B$ sebagai berikut:

$A$ sama dengan $g$ yang dipangkatkan dengan pangkat $a$ modulo $p$:

$$
A = g^a \bmod p
$$

$B$ sama dengan $g$ yang dipangkatkan dengan pangkat $b$ modulo $p$:

$$
B = g^b \bmod p
$$


- Nilai $A (setara dengan **warna oranye**) dan $B (setara dengan **warna hijau**) dipertukarkan antara kedua belah pihak. Pertukaran ini dapat dilakukan dalam teks yang jelas pada jaringan yang tidak aman;
- Alice, setelah menerima $B$, menghitung nilai $z$ sebagai berikut:

$z$ sama dengan $B$ yang dipangkatkan dengan pangkat $a$ modulo $p$:

$$
z = B^a \bmod p
$$

Pengingat:

$$
B = g^b \bmod p
$$

Hasilnya adalah :

$$
z = B^a \bmod p
$$

$$
z = (g^b)^a \bmod p
$$

Dengan menerapkan aturan daya :

$$
(x^n)^m = x^{nm}
$$

Hasilnya adalah :

$$
z = g^{ba} \bmod p
$$


- Sementara itu, Bob, setelah menerima $A$, juga menghitung nilai $z$ sebagai berikut:

$z$ sama dengan $A$ yang dipangkatkan dengan pangkat $b$ modulo $p$:

$$
z = A^b \bmod p
$$

Hasilnya adalah :

$$
z = (g^a)^b \bmod p
$$

$$
z = g^{ab} \bmod p
$$

$$
z = g^{ba} \bmod p
$$

Berkat distributivitas operator modulo, Alice dan Bob mendapatkan nilai yang sama persis, yaitu $z$. Angka ini mewakili rahasia bersama mereka, setara dengan **warna coklat** pada saat mereka mempopulerkan warna cat dengan kaleng. Mereka sekarang dapat menggunakan rahasia bersama ini untuk mengenkripsi komunikasi mereka secara simetris melalui jaringan yang tidak aman.

![BTC204](assets/fr/222.webp)

Seorang penyerang, bahkan jika ia memiliki $p$, $g$, $A$ dan $B$ (nilai publik), tidak akan bisa menghitung $a$, $b$ atau $z$ (nilai privat). Untuk mencapai hal ini, eksponensial harus dibalik, sebuah operasi yang tidak mungkin dilakukan tanpa mencoba semua kemungkinan satu per satu, karena ini sama saja dengan menghitung logaritma diskrit, yaitu kebalikan dari eksponensial pada sebuah grup siklik berhingga.

Jadi, selama nilai $a$, $b$ dan $p$ cukup besar, protokol Diffie-Hellman aman. Biasanya, dengan parameter 2048 bit (angka desimal 600 digit), menguji semua kemungkinan untuk $a$ dan $b$ tidak praktis. Sampai saat ini, dengan jumlah tersebut, algoritma ini dianggap aman.

Di sinilah letak kelemahan utama protokol Diffie-Hellman. Agar aman, algoritme ini harus menggunakan angka yang besar. Itulah sebabnya, akhir-akhir ini, kami lebih suka menggunakan algoritma ECDH (*Eliptic Curve Diffie-Hellman*), sebuah varian Diffie-Hellman yang didasarkan pada kurva aljabar, lebih tepatnya kurva elips. Pendekatan ini memungkinkan untuk bekerja dengan jumlah yang jauh lebih kecil dengan tetap mempertahankan keamanan yang setara, sehingga mengurangi sumber daya yang diperlukan untuk perhitungan dan penyimpanan.

Prinsip umum dari algoritma ini tetap sama. Namun, alih-alih menggunakan angka acak $a$ dan angka $A$ yang dihitung dari $a$ dengan eksponensial modular, kami menggunakan sepasang kunci yang ditetapkan pada kurva elips. Alih-alih mengandalkan distributivitas dari operator modulo, kita menggunakan hukum grup pada kurva eliptik, dan lebih tepatnya asosiatifitas dari hukum ini.

Untuk menjelaskan secara singkat prinsip kriptografi pada kurva eliptik, sebuah kunci privat diwakili oleh sebuah angka acak antara $1$ dan $n-1$, di mana $n$ merepresentasikan urutan kurva. Kunci publik, di sisi lain, adalah sebuah titik tertentu pada kurva ini, yang didapatkan dari kunci privat dengan menambahkan dan menggandakan titik dari titik pembangkitan, sesuai dengan persamaan :

$$
K = k \cdot G
$$

Dalam rumus ini, $K$ menunjukkan kunci publik, $k$ kunci privat, dan $G$ titik generator.

Fitur penting dari kunci-kunci ini adalah kemudahannya untuk menghitung $K$ dari $k$ dan $G$, sementara hampir tidak mungkin untuk menemukan $k$ dari $K$ dan $G$. Asimetri ini menciptakan fungsi satu arah. Dengan kata lain, mudah untuk menghitung kunci publik jika Anda mengetahui kunci privat, tetapi mengambil kunci privat dari kunci publik tidak mungkin dilakukan. Keamanan ini didukung lebih lanjut oleh kesulitan komputasi dari logaritma diskrit.

Kita akan menggunakan properti ini untuk mengadaptasi algoritma Diffie-Hellman. *prinsip operasi ECDH adalah sebagai berikut:*** 1


- Alice dan Bob menyetujui kurva elips yang aman secara kriptografi dan parameternya. Informasi ini bersifat publik;
- Alice menghasilkan sebuah angka acak $ka$ yang akan menjadi kunci pribadinya. Kunci pribadi ini harus tetap dirahasiakan. Ia menentukan kunci publiknya $Ka$ dengan menambahkan dan menggandakan titik-titik pada kurva elips yang dipilih:

$$
K_a = k_a \cdot G
$$


- Bob juga menghasilkan sebuah angka acak $kb$, yang akan menjadi kunci pribadinya. Dia menghitung kunci publik yang terkait dengan $Kb$ :

$$
K_b = k_b \cdot G
$$


- Alice dan Bob saling bertukar kunci publik $Ka$ dan $Kb$ pada jaringan publik yang tidak aman.
- Alice menghitung sebuah titik $(x,y)$ pada kurva dengan menggunakan kunci privatnya $ka$ pada kunci publik Bob $Kb$:

$$
(x,y) = k_a \cdot K_b
$$


- Bob menghitung sebuah titik $(x,y)$ pada kurva dengan menggunakan kunci privatnya $kb$ pada kunci publik Alice $Ka$:

$$
(x,y) = k_b \cdot K_a
$$


- Alice dan Bob mendapatkan titik yang sama pada kurva elips. Rahasia bersama adalah absis $x$ dari titik ini.

Mereka mendapatkan rahasia bersama yang sama karena :

$$
(x,y) = k_a \cdot K_b = k_a \cdot (k_b \cdot G) = (k_a \cdot k_b) \cdot G = (k_b \cdot k_a) \cdot G = k_b \cdot (k_a \cdot G) = k_b \cdot K_a
$$

Seorang penyerang potensial yang mengamati jaringan publik yang tidak aman hanya dapat memperoleh kunci publik dari setiap individu dan parameter dari kurva eliptik yang dipilih. Seperti yang telah dijelaskan di atas, informasi ini saja tidak cukup untuk menentukan kunci privat. Akibatnya, penyerang tidak dapat menemukan rahasia yang dibagikan antara Alice dan Bob.

Oleh karena itu, ECDH adalah sebuah algoritma pertukaran kunci. Algoritma ini sering digunakan bersama dengan metode kriptografi lainnya untuk membuat protokol yang lengkap. Sebagai contoh, ECDH merupakan inti dari TLS (*Transport Layer Security*), sebuah protokol enkripsi dan autentikasi yang digunakan untuk lapisan transport Internet. TLS menggunakan ECDHE untuk pertukaran kunci, sebuah varian dari ECDH yang kuncinya bersifat sementara, untuk memberikan kerahasiaan yang persisten. Selain itu, TLS menggunakan algoritma autentikasi seperti ECDSA, algoritma enkripsi seperti AES, dan fungsi hash seperti SHA256.

TLS bertanggung jawab atas huruf `s` pada `https` dan gembok di bilah alamat peramban Anda - simbol komunikasi terenkripsi. Dengan mengikuti kursus ini, kamu akan menggunakan ECDH, dan kemungkinan besar kamu akan menggunakannya setiap hari tanpa menyadarinya.

### Transaksi pemberitahuan

Seperti yang telah kita lihat di bagian sebelumnya, ECDH adalah varian dari bursa Diffie-Hellman yang menggunakan pasangan kunci yang dibuat berdasarkan kurva elips. Untunglah kita sudah memiliki banyak pasangan kunci yang sesuai dengan standar ini di dompet Bitcoin kita! Ide dari BIP47 adalah untuk menggunakan pasangan kunci dari dompet Bitcoin hirarkis deterministik kedua belah pihak untuk membuat rahasia bersama yang bersifat fana di antara mereka. BIP47 menggunakan ECDHE (*Eliptic Curve Diffie-Hellman **Ephemeral***).

![BTC204](assets/fr/223.webp)

ECDHE pertama kali digunakan dalam BIP47 untuk mengirimkan kode pembayaran dari pengirim ke penerima. Ini adalah **transaksi pemberitahuan** yang terkenal. Langkah ini sangat penting, karena agar BIP47 dapat bekerja secara efektif, kedua belah pihak yang terlibat (pengirim dan penerima) harus mengetahui kode pembayaran masing-masing. Pengetahuan ini memungkinkan untuk mendapatkan kunci publik yang bersifat sementara dan, sebagai akibatnya, alamat penerima yang kosong.

Sebelum pertukaran ini, pengirim secara logis sudah mengetahui kode pembayaran penerima, karena telah mengambilnya di luar rantai, misalnya dari situs web, faktur, atau jejaring sosialnya. Akan tetapi, penerima belum tentu mengetahui kode pembayaran pengirim. Akan tetapi, kode tersebut harus dikirimkan kepadanya; jika tidak, ia tidak akan dapat memperoleh kunci sementara yang dibutuhkan untuk mengidentifikasi alamat tempat penyimpanan bitcoinnya, atau mengakses dananya. Meskipun transmisi kode pengirim ini secara teknis dapat dilakukan di luar rantai dengan cara komunikasi lain, hal ini menimbulkan masalah jika dompet hanya akan diambil dari seed saja.

Hal ini dikarenakan, tidak seperti alamat konvensional, alamat BIP47 tidak diturunkan secara langsung dari seed penerima - menggunakan `xpub` akan lebih sederhana dalam kasus ini - tetapi dihasilkan dari perhitungan yang menggabungkan dua kode pembayaran: kode pembayaran dari pengirim dan kode pembayaran dari penerima. Jadi, jika penerima kehilangan dompetnya dan mencoba memulihkannya dari seed-nya, dia akan memulihkan kode pembayarannya sendiri, yang secara langsung berasal dari seed-nya. Akan tetapi, untuk memulihkan alamat fana, ia juga akan membutuhkan kode pembayaran dari semua orang yang telah mengiriminya bitcoin melalui BIP47. Oleh karena itu, pentingnya transaksi notifikasi, yang memungkinkan informasi ini disimpan di blockchain Bitcoin, namun tetap dapat ditemukan dengan mudah tanpa harus mencari melalui miliaran transaksi yang telah dilakukan sejak diluncurkan pada tahun 2009.

![BTC204](assets/fr/224.webp)

Oleh karena itu, memungkinkan untuk mengimplementasikan BIP47 tanpa menggunakan transaksi notifikasi, asalkan setiap pengguna menyimpan cadangan kode pembayaran rekan-rekannya. Akan tetapi, metode ini terbukti rumit untuk dikelola hingga solusi yang sederhana, kuat, dan efisien untuk membuat, menyimpan, dan memperbarui cadangan ini dikembangkan. Saat ini, transaksi notifikasi hampir tidak dapat dihindari.

Pada bab-bab selanjutnya, kita akan melihat protokol lain dengan tujuan yang sama dengan BIP47, tetapi tidak memerlukan transaksi notifikasi. Akan tetapi, alternatif-alternatif ini memiliki kekurangan dan kelebihan masing-masing.

Selain perannya untuk menyimpan kode pembayaran, transaksi notifikasi juga memiliki fungsi pemberitahuan untuk penerima, sesuai dengan namanya. Fungsi ini memberi tahu pelanggan penerima bahwa sebuah terowongan pembayaran baru telah dibuat, dan menyarankan agar ia mengawasi alamat-alamat sementara yang dihasilkan.

### Model kerahasiaan BIP47

Sebelum merinci operasi teknis transaksi notifikasi, penting untuk membahas model kerahasiaan yang terkait dengan BIP47, yang membenarkan langkah-langkah tertentu yang diambil saat membuat transaksi awal ini.

Kode pembayaran itu sendiri tidak memiliki risiko langsung terhadap kerahasiaan. Tidak seperti model Bitcoin tradisional, yang bertujuan untuk memutuskan hubungan antara identitas pengguna dan transaksinya (yang bersifat publik) dengan menjaga anonimitas kunci dan alamat, kode pembayaran dapat secara terbuka dikaitkan dengan identitas tanpa menimbulkan ancaman.

Hal ini karena kode pembayaran tidak digunakan untuk secara langsung mendapatkan alamat yang menerima pembayaran BIP47. Sebaliknya, alamat-alamat ini dihasilkan melalui aplikasi ECDH antara kunci-kunci yang berasal dari kode pembayaran dari dua pihak yang terlibat.

Dengan demikian, kode pembayaran itu sendiri tidak secara langsung menyebabkan hilangnya kerahasiaan, karena hanya alamat notifikasi yang berasal darinya. Meskipun alamat ini dapat mengungkapkan informasi tertentu, alamat ini biasanya tidak mengungkapkan pihak-pihak yang bertransaksi dengan Anda, kecuali jika analisis rantai yang menyeluruh dilakukan. Memang, jika pengirim menggunakan UTXO yang dapat ditautkan ke identitasnya untuk melakukan transaksi notifikasi, maka dapat disimpulkan bahwa identitasnya mungkin terkait dengan pembayaran BIP47 ke kode pembayaran Anda. Hal ini tidak akan mengungkapkan transaksi yang mendasarinya, tetapi akan menunjukkan kemungkinan keberadaannya.

Oleh karena itu, sangat penting untuk menjaga pemisahan yang ketat antara kode pembayaran pengguna. Dengan mengingat hal ini, komunikasi awal kode adalah momen penting untuk kerahasiaan pembayaran, namun sangat penting agar protokol dapat berfungsi dengan baik. Jika salah satu kode pembayaran dapat diperoleh secara publik (seperti di situs web), kode kedua, kode pengirim, tidak boleh ditautkan ke kode pertama.

Mari kita ambil contoh konkret: Saya ingin memberikan donasi kepada sebuah gerakan politik melalui BIP47 :


- Organisasi ini telah mempublikasikan kode pembayarannya di situs webnya atau melalui jejaring sosialnya;
- Oleh karena itu, kode ini terkait dengan gerakan politik;
- Saya mendapatkan kode pembayaran ini;
- Sebelum mengirim, saya harus memastikan mereka mengetahui kode pembayaran saya sendiri, yang juga terhubung dengan identitas saya karena saya menggunakannya untuk menerima transaksi di jejaring sosial saya.

Bagaimana saya bisa menyampaikan kode saya tanpa risiko? Menggunakan sarana komunikasi konvensional dapat menyebabkan kebocoran informasi, dan dengan demikian mengasosiasikan saya dengan gerakan politik ini. Transaksi notifikasi menawarkan solusi, berkat lapisan enkripsi yang mencegah hubungan seperti itu antara dua kode. Meskipun ini bukan satu-satunya metode untuk mengirimkan kode pembayaran pengirim secara diam-diam, ini adalah metode yang sangat efektif.

Pada diagram di bawah ini, garis oranye menunjukkan titik-titik di mana aliran informasi harus diinterupsi, dan panah hitam menunjukkan koneksi yang berpotensi dapat diamati oleh pihak ketiga:

![BTC204](assets/fr/225.webp)

Pada kenyataannya, dalam model kerahasiaan tradisional Bitcoin, sering kali sulit untuk memisahkan aliran informasi antara pasangan kunci dan pengguna, terutama dalam transaksi jarak jauh. Sebagai contoh, dalam konteks kampanye donasi, penerima harus mengungkapkan alamat atau public key melalui situs web atau jejaring sosialnya. Penggunaan BIP47 yang benar, terutama dengan transaksi notifikasi, memungkinkan untuk mengatasi masalah ini berkat ECDHE dan lapisan enkripsi yang akan kita bahas nanti.

Tentu saja, model kerahasiaan klasik Bitcoin masih berlaku untuk kunci publik yang bersifat sementara, yang berasal dari kombinasi dua kode pembayaran. Kedua model ini sebenarnya saling melengkapi. Yang ingin saya tekankan di sini adalah, tidak seperti penggunaan kunci publik yang biasa digunakan untuk menerima Bitcoin, kode pembayaran dapat dihubungkan dengan identitas tertentu, karena informasi "_Alice bertransaksi dengan Bob_" akan dipecahkan pada tahap selanjutnya. Kode pembayaran digunakan untuk menghasilkan alamat pembayaran, tetapi hanya berdasarkan pengamatan terhadap blockchain, tidak mungkin untuk menghubungkan transaksi pembayaran BIP47 dengan kode pembayaran yang digunakan untuk mengeksekusinya, kecuali jika UTXO yang terlibat telah ditautkan ke sebuah identitas sebelumnya dan pengguna mengaitkan kode pembayaran mereka dengan identitas masing-masing.

Singkatnya, model kerahasiaan yang ditawarkan oleh pembayaran BIP47 dapat dianggap lebih unggul daripada model dasar Bitcoin, meskipun ini bukan berarti ini adalah keajaiban.

### Membangun transaksi notifikasi

Sekarang mari kita lihat bagaimana cara kerja transaksi notifikasi ini. Bayangkan Alice ingin mengirim dana ke Bob menggunakan BIP47. Dalam contoh saya, Alice bertindak sebagai pengirim dan Bob sebagai penerima. Bob telah mempublikasikan kode pembayarannya di situs webnya. Oleh karena itu, Alice sudah mengetahui kode pembayaran Bob.

**1- Alice menghitung rahasia bersama dengan ECDH :**


- Dia memilih pasangan kunci dari dompet HD-nya di cabang yang berbeda dengan kode pembayarannya. Perhatikan bahwa pasangan ini tidak boleh dengan mudah dikaitkan dengan alamat notifikasi Alice, atau dengan identitas Alice (lihat bagian sebelumnya);
- Alice memilih kunci privat untuk pasangan ini. Kita menyebutnya $a$ (huruf kecil);

$$
a
$$


- Alice mengambil kunci publik yang terkait dengan alamat notifikasi Bob. Kunci ini adalah anak pertama yang berasal dari kode pembayaran Bob (indeks $/0$). Kita menyebut kunci publik ini sebagai $B$ (huruf besar). Kunci privat yang terkait dengan kunci publik ini dinamai $b$ (huruf kecil). $B$ ditentukan dengan menambahkan dan menggandakan titik-titik pada kurva eliptik dari $G$ (titik pembangkit) dengan $b$ (kunci privat):

$$ B = b \cdot G $$


- Alice menghitung titik rahasia $S$ (huruf besar) pada kurva eliptik dengan menambahkan dan menggandakan titik-titik, dengan menggunakan kunci privatnya $a$ dari kunci publik Bob $B$.

$$ S = a \cdot B $$


- Alice menghitung faktor penyamaran $f$ yang akan digunakan untuk mengenkripsi kode pembayarannya. Untuk melakukan hal ini, dia menggunakan fungsi HMAC-SHA512 untuk menentukan sebuah bilangan acak semu. Masukan kedua pada fungsi ini adalah sebuah nilai yang hanya dapat ditemukan oleh Bob: $x$, yang merupakan absis dari titik rahasia yang dihitung di atas. Masukan pertama adalah $o$, yang merupakan UTXO yang digunakan sebagai masukan untuk transaksi ini (titik keluar).

$$ f = \text{HMAC-SHA512}(o, x) $$

**2 - Alice mengubah kode pembayaran pribadinya menjadi basis 2 (biner) **

**3- Ia menggunakan faktor penyamaran ini sebagai kunci untuk melakukan enkripsi simetris pada muatan kode pembayarannya.** Algoritma enkripsi yang digunakan hanyalah `XOR`. Operasi yang dilakukan sebanding dengan sandi Vernam, juga dikenal sebagai "One-Time Pad".


- Alice pertama-tama membagi faktor kebutaannya menjadi dua: 32 byte pertama diberi nama $f1$ dan 32 byte terakhir diberi nama $f2$. Hal ini memberi kita :

$$ f = f1 || f2 $$


- Alice menghitung cipher $x'$ dari absis kunci publik $x$ dari kode pembayarannya, dan cipher $c'$ dari kode string $c$ secara terpisah. $f1$ dan $f2$ masing-masing bertindak sebagai kunci sandi. Operasi yang digunakan adalah `XOR` (atau eksklusif).

$$ x' = x \oplus f1 $$

$$ c' = c \oplus f2 $$


- Alice mengganti nilai sebenarnya dari absis kunci publik $x$ dan kode string $c$ pada kode pembayarannya dengan nilai terenkripsi $x'$ dan $c'$.

**Oleh karena itu, Alice saat ini memiliki kode pembayarannya dengan muatan terenkripsi. Dia akan membuat dan menyiarkan sebuah transaksi yang melibatkan kunci publiknya $A$ sebagai input, sebuah output ke alamat notifikasi Bob, dan sebuah output `OP_RETURN` yang terdiri dari kode pembayarannya dengan muatan terenkripsi. **Transaksi ini adalah transaksi notifikasi**.

Sebuah `OP_RETURN` adalah sebuah opcode yang menandai hasil transaksi Bitcoin sebagai tidak valid. Saat ini, opcode ini digunakan untuk menyiarkan atau menambatkan informasi pada blockchain Bitcoin. Opcode ini dapat menyimpan hingga 80 byte data, yang kemudian dituliskan ke dalam rantai dan dapat dilihat oleh semua pengguna lainnya.

Seperti yang sudah kita lihat pada bagian sebelumnya, ECDH digunakan untuk menghasilkan sebuah rahasia bersama antara dua pengguna yang berkomunikasi melalui jaringan yang tidak aman, dan berpotensi untuk diamati oleh penyerang. Pada BIP47, ECDH digunakan untuk berkomunikasi pada jaringan Bitcoin, yang pada dasarnya merupakan jaringan komunikasi yang transparan, dan diamati oleh banyak penyerang. Rahasia bersama yang dihitung melalui pertukaran kunci ECDH kemudian digunakan untuk mengenkripsi informasi rahasia yang akan dikirimkan: kode pembayaran pengirim (Alice).

Saya akan meringkas langkah-langkah yang baru saja kita lihat bersama untuk melakukan transaksi notifikasi:


- Alice mengambil kode pembayaran dan alamat notifikasi Bob;
- Alice memilih UTXO dari portofolio HD-nya dengan pasangan kunci yang sesuai;
- Ini menghitung titik rahasia pada kurva elips menggunakan ECDH ;
- Alat ini menggunakan titik rahasia ini untuk menghitung HMAC, yang merupakan faktor penyilaukan;
- Dia menggunakan faktor pembutakan ini untuk mengenkripsi muatan kode pembayaran pribadinya;
- Ia menggunakan output transaksi `OP_RETURN` untuk mengomunikasikan kode pembayaran tersembunyi kepada Bob.

![BTC204](assets/fr/226.webp)

### Pemberitahuan transaksi: studi praktis

Untuk memahami cara kerjanya secara lebih detail, dan khususnya penggunaan `OP_RETURN`, mari kita lihat sebuah transaksi notifikasi yang nyata. Saya melakukan transaksi seperti itu di testnet, yang dapat Anda temukan [dengan mengklik di sini] (https://mempool.space/fr/testnet/tx/0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e).

![BTC204](assets/fr/227.webp)

Melihat transaksi ini, kita sudah bisa melihat bahwa transaksi ini memiliki satu input dan 4 output:


- Keluaran pertama adalah `OP_RETURN` yang berisi kode pembayaran tersembunyi;
- Output kedua dari 546 sat menunjuk ke alamat notifikasi penerima;
- Hasil ketiga sebesar 15.000 sat merupakan biaya layanan, karena saya menggunakan Samourai Wallet untuk melakukan transaksi ini;
- Keluaran keempat sebesar 2 juta sat mewakili nilai tukar, yaitu sisa selisih dari masukan saya yang kembali ke alamat lain milik saya.

Yang paling menarik untuk dipelajari adalah output 0 menggunakan `OP_RETURN`. Mari kita lihat lebih dekat apa yang dikandungnya. Berikut adalah `scriptPubKey` dalam bentuk heksadesimal:

```text
6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000
```

Ada beberapa bagian dalam skrip ini. Pertama, file :

```text
6a4c
```

Di antara opcode, kita dapat mengenali `0x6a` yang menunjukkan `OP_RETURN` dan `0x4c` yang menunjukkan `OP_PUSHDATA1`.

Byte setelah opcode terakhir ini menunjukkan ukuran muatan berikutnya. Ini menunjukkan `x50`, atau 80 byte:

```text
6a4c50
```

Selanjutnya, kami memiliki metadata kode pembayaran saya dalam teks yang jelas:

```text
010002
```

Absis terenkripsi dari kunci publik kode pembayaran saya:

```text
b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164
```

Kode string terenkripsi dari kode pembayaran saya:

```text
927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d8
```

Dan terakhir, padding menjadi 80 byte, ukuran standar dari `OP_RETURN`:

```text
00000000000000000000000000
```

Untuk membantu Anda memahami, berikut ini adalah kode pembayaran saya dalam teks biasa dalam basis 58 :

```text
PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
```

Dan di basis 16 :

```text
4701000277507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42add94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc000000000000000000000000008604e4db
```

Jika kita membandingkan kode pembayaran plaintext saya dengan `OP_RETURN`, kita dapat melihat bahwa HRP (`x47`) dan checksum (`x8604e4db`) tidak dikirimkan. Hal ini normal, karena informasi ini ditujukan untuk manusia.

Selanjutnya, kita dapat mengenali versi (`0x01`), bit field (`0x00`) dan paritas kunci publik (`0x02`). Dan, di akhir kode pembayaran, byte kosong (`x000000000000000000000000000000`) yang memungkinkan padding mencapai total 80 byte. Semua metadata ini dikirimkan tanpa dienkripsi.

Akhirnya, kita dapat mengamati bahwa absis kunci publik (`x77507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42a`) dan kode string (`xdd94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc`) telah dienkripsi. Ini adalah muatan kode pembayaran.

### Apa itu XOR?

Kita telah melihat pada bagian sebelumnya bahwa kode pembayaran dikirimkan secara terenkripsi menggunakan operasi XOR. Mari kita lihat lebih dekat bagaimana cara kerja operator ini, karena operator ini digunakan secara luas dalam kriptografi.

XOR adalah operator logika bitwise yang didasarkan pada aljabar Boolean. Diberikan dua operan dalam bit, operator ini mengembalikan `1` jika bit-bit dengan pangkat yang sama berbeda, dan mengembalikan `0` jika bit-bit dengan pangkat yang sama sama. Berikut adalah tabel kebenaran XOR menurut nilai operand `D` dan `E`:

| D | E | D X ATAU E |

| --- | --- | ------- |

| 0 | 0 | 0 |

| 0 | 1 | 1 |

| 1 | 0 | 1 |

| 1 | 1 | 0 |

Sebagai contoh:

$$
0110 \oplus 1110 = 1000
$$

Atau:

$$
010011 \oplus 110110 = 100101
$$

Dengan ECDH, penggunaan XOR sebagai lapisan enkripsi sangat konsisten. Pertama, berkat operator ini, enkripsi bersifat simetris. Ini berarti bahwa penerima dapat mendekripsi kode pembayaran dengan kunci yang sama yang digunakan untuk enkripsi. Kunci enkripsi dan dekripsi dihitung dari rahasia bersama menggunakan ECDH. Simetri ini dimungkinkan oleh sifat komutativitas dan asosiativitas dari operator XOR:


- Properti lainnya :

$$
D \oplus D = 0
$$

$$
D \oplus 0 = D
$$


- Komutativitas :

$$
D \oplus E = E \oplus D
$$


- Keterkaitan :

$$
D \oplus (E \oplus Z) = (D \oplus E) \oplus Z = D \oplus E \oplus Z
$$

Jika:

$$
D \oplus E = L
$$

Lalu:

$$
D \oplus L = D \oplus (D \oplus E) = D \oplus D \oplus E = 0 \oplus E = E \\
\therefore D \oplus L = E
$$

Kedua, metode enkripsi ini sangat mirip dengan sandi Vernam (One-Time Pad), satu-satunya algoritma enkripsi yang dikenal saat ini yang memiliki keamanan tanpa syarat (atau mutlak). Agar sandi Vernam memiliki fitur ini, kunci enkripsi haruslah acak sempurna, dengan ukuran yang sama dengan pesan dan hanya digunakan satu kali. Dalam metode enkripsi yang digunakan di sini untuk BIP47, kuncinya memang berukuran sama dengan pesan, dan faktor pembutakan berukuran sama persis dengan penggabungan absis dari kunci publik dengan kode string kode pembayaran. Kunci enkripsi ini hanya digunakan sekali. Di sisi lain, kunci ini tidak berasal dari keacakan yang sempurna, karena ini adalah HMAC. Sebaliknya, kunci ini bersifat acak semu. Jadi, ini bukanlah sebuah sandi Vernam, tetapi metodenya mendekati.

### Tanda terima transaksi notifikasi

Sekarang Alice telah mengirimkan notifikasi transaksi kepada Bob, mari kita lihat bagaimana Bob menafsirkannya. Sebagai pengingat, Bob harus memiliki akses ke kode pembayaran Alice. Tanpa informasi ini, seperti yang akan kita lihat pada bagian selanjutnya, dia tidak akan dapat memperoleh pasangan kunci yang dibuat oleh Alice, dan oleh karena itu tidak akan dapat mengakses bitcoin yang diterimanya melalui BIP47. Untuk saat ini, muatan kode pembayaran Alice dienkripsi. Mari kita lihat bagaimana Bob mendekripsinya.

**1-** Bob memantau transaksi yang menghasilkan output dengan alamat notifikasinya.

**2-** Ketika sebuah transaksi memiliki output pada alamat notifikasinya, Bob menganalisisnya untuk melihat apakah transaksi tersebut berisi output OP_RETURN yang sesuai dengan standar BIP47.

**3-** Jika byte pertama dari muatan OP_RETURN adalah `x01`, Bob memulai pencariannya untuk rahasia yang mungkin dibagikan dengan ECDH :


- Bob memilih kunci publik input untuk transaksi tersebut. Yaitu, kunci publik Alice bernama $A$ dengan ekstensi :

$$ A = a \cdot G $$


- Bob memilih kunci privat $b$ yang terkait dengan alamat notifikasi pribadinya:

$$ b $$


- Bob menghitung titik rahasia $S$ (rahasia bersama ECDH) pada kurva eliptik dengan menambahkan dan menggandakan titik, menerapkan kunci privatnya $b$ pada kunci publik Alice $A$:

$$ S = b \cdot A $$


- Bob menentukan faktor penyamaran $f$ yang akan memungkinkan muatan kode pembayaran Alice untuk didekripsi. Dengan cara yang sama seperti yang telah dihitung oleh Alice sebelumnya, Bob akan menemukan $f$ dengan mengaplikasikan HMAC-SHA512 pada $x$, nilai absis dari titik rahasia $S$, dan pada $o$, UTXO yang digunakan sebagai input pada transaksi notifikasi:

$$ f = \text{HMAC-SHA512}(o, x) $$

**4-** Bob menafsirkan data OP_RETURN dalam transaksi notifikasi sebagai kode pembayaran. Dia hanya akan mendekripsi muatan dari kode pembayaran potensial ini menggunakan faktor pembutakan $f$:


- Bob membagi faktor penyamaran $f$ menjadi 2 bagian: 32 byte pertama dari $f$ akan menjadi $f1$ dan 32 byte terakhir akan menjadi $f2$;
- Bob mendekripsi nilai absis terenkripsi $x'$ dari kunci publik kode pembayaran Alice:

$$ x = x' \oplus f1 $$


- Bob mendekripsi nilai kode string terenkripsi $c'$ dari kode pembayaran Alice:

$$ c = c' \oplus f2 $$

**5-** Bob memeriksa apakah nilai kunci publik dari kode pembayaran Alice merupakan bagian dari grup secp256k1. Jika iya, ia akan mengartikannya sebagai kode pembayaran yang valid. Jika tidak, ia mengabaikan transaksi tersebut.

Sekarang setelah Bob mengetahui kode pembayaran Alice, Alice dapat mengiriminya pembayaran hingga `2^32`, tanpa harus mengulangi transaksi notifikasi jenis ini.

Mengapa cara ini berhasil? Bagaimana Bob dapat menentukan faktor penyamaran yang sama dengan Alice, dan dengan demikian menguraikan kode pembayarannya? Mari kita lihat lebih dekat aksi ECDH dalam contoh yang baru saja kita jelaskan.

Pertama-tama, kita berurusan dengan enkripsi simetris. Ini berarti bahwa kunci enkripsi dan kunci dekripsi memiliki nilai yang sama. Kunci ini dalam transaksi notifikasi adalah faktor yang membutakan:

$$ f = f1 || f2 $$

Oleh karena itu, Alice dan Bob harus mendapatkan nilai yang sama untuk $f$, tanpa mentransmisikannya secara langsung, karena penyerang dapat mencurinya dan mendekripsi informasi rahasia tersebut. Faktor pembutakan ini diperoleh dengan menerapkan HMAC-SHA512 ke 2 nilai:


- absis dari suatu titik rahasia ;
- dan UTXO yang dikonsumsi pada input transaksi.

Oleh karena itu, Bob membutuhkan kedua informasi ini untuk mendekripsi muatan kode pembayaran Alice. Untuk input UTXO, Bob dapat dengan mudah mengambilnya dengan mengamati transaksi notifikasi. Untuk poin rahasia, Bob perlu menggunakan ECDH. Seperti yang terlihat pada bagian sebelumnya mengenai Diffie-Hellman, hanya dengan menukarkan kunci publik masing-masing dan secara diam-diam mengaplikasikan kunci privat mereka pada kunci publik satu sama lain, Alice dan Bob dapat menemukan sebuah titik rahasia yang tepat pada kurva elips. Transaksi notifikasi didasarkan pada mekanisme ini:


- Sepasang kunci milik Bob :

$$ B = b \cdot G $$


- Pasangan kunci Alice:

$$ A = a \cdot G $$


- Untuk sebuah rahasia $S (x, y)$:

$$ S = a \cdot B = a \cdot (b \cdot G) = (b \cdot a) \cdot G = b \cdot A $$

![BTC204](assets/fr/228.webp)

Setelah Bob mengetahui kode pembayaran Alice, dia akan dapat mendeteksi pembayaran BIP47-nya, dan dia akan dapat memperoleh kunci privat yang memblokir bitcoin yang diterima.

Saya akan meringkas langkah-langkah yang baru saja kita lihat bersama untuk menerima dan menginterpretasikan transaksi notifikasi:


- Bob memantau keluaran transaksi ke alamat notifikasinya;
- Ketika mendeteksi satu, ia akan mengambil informasi yang terkandung dalam OP_RETURN ;
- Bob memilih kunci publik sebagai input dan menghitung titik rahasia menggunakan ECDH ;
- Alat ini menggunakan titik rahasia ini untuk menghitung HMAC, yang merupakan faktor penyilaukan;
- Ia menggunakan faktor pembutakan ini untuk mendekripsi muatan kode pembayaran Alice yang terkandung dalam OP_RETURN.

![BTC204](assets/fr/229.webp)

### Transaksi pembayaran BIP47

Mari kita lihat proses pembayaran dengan BIP47. Untuk mengingatkan Anda tentang situasi saat ini:


- Alice mengetahui kode pembayaran Bob, yang ia ambil dari situs webnya;
- Bob mengetahui kode pembayaran Alice dari notifikasi transaksi;
- Alice akan melakukan pembayaran pertama kepada Bob. Dia bisa membuat lebih banyak lagi dengan cara yang sama.

Sebelum menjelaskan proses ini, saya pikir penting untuk mengingat indeks mana yang sedang kita kerjakan. Jalur penurunan untuk kode pembayaran dijelaskan sebagai berikut: `m/47'/0'/0'`. Kedalaman berikut ini membagi indeks-indeks tersebut sebagai berikut:


- Pasangan anak normal (tidak diperkuat) pertama adalah yang digunakan untuk menghasilkan alamat notifikasi yang dibahas pada bagian sebelumnya: `m/47'/0'/0'/0` ;
- Pasangan kunci anak normal digunakan dalam ECDH untuk menghasilkan alamat tanda terima pembayaran BIP47, seperti yang akan kita lihat di bagian ini: dari `m/47'/0'/0'/0` hingga `m/47'/0'/0'/2.147.483.647`;
- Pasangan kunci anak yang diperkuat adalah kode pembayaran sementara: dari `m/47'/0'/0'/0'` hingga `m/47'/0'/0'/2.147.483.647'`.

Setiap kali Alice ingin mengirim pembayaran kepada Bob, dia mendapatkan alamat kosong yang baru dan unik, sekali lagi menggunakan protokol ECDH:


- Alice memilih kunci pribadi pertama yang berasal dari kode pembayaran pribadinya yang dapat digunakan kembali:

$$ a $$


- Alice memilih kunci publik pertama yang tidak terpakai yang berasal dari kode pembayaran Bob. Kita akan menyebut kunci publik ini sebagai $B$. Kunci ini diasosiasikan dengan kunci privat $b$ yang hanya diketahui oleh Bob:

$$ B = b \cdot G $$


- Alice menghitung titik rahasia $S$ pada kurva eliptik dengan menambahkan dan menggandakan titik dengan menggunakan kunci privatnya $a$ dari kunci publik Bob $B$:

$$ S = a \cdot B $$


- Dari titik rahasia ini, Alice menghitung rahasia bersama $s$ (huruf kecil). Untuk melakukan ini, ia memilih absis dari titik rahasia $S$ yang bernama $Sx$, dan meneruskan nilai ini ke fungsi hash SHA256:

$$ S = (Sx, Sy) $$

$$ s = \text{SHA256}(Sx) $$


- Alice menggunakan rahasia bersama $s$ ini untuk menghitung alamat penerimaan pembayaran Bitcoin. Pertama, ia memeriksa apakah $s$ terdapat pada urutan kurva secp256k1. Jika tidak demikian, ia akan menambah indeks kunci publik Bob untuk mendapatkan rahasia bersama yang lain;
- Pada langkah kedua, ia menghitung kunci publik $K0$ dengan menambahkan titik $B$ dan $s-G$ pada kurva elips. Dengan kata lain, Alice menambahkan kunci publik yang berasal dari kode pembayaran Bob $B$ ke titik lain yang dihitung pada kurva eliptik dengan menambahkan dan menggandakan titik dengan rahasia bersama $s$ dari titik generator kurva secp256k1 $G$. Titik baru ini merepresentasikan sebuah kunci publik, dan kita menyebutnya sebagai $K0$:

$$ K0 = B + s \cdot G $$


- Dengan kunci publik $K0$ ini, Alice dapat memperoleh alamat penerimaan kosong dengan cara standar (misalnya SegWit V0 di bech32).

Setelah Alice mendapatkan alamat penerima $K0$ milik Bob, ia dapat melakukan transaksi Bitcoin dengan cara standar. Untuk melakukan ini, ia memilih UTXO yang dimilikinya, yang diamankan dengan pasangan kunci dari cabang dompet HD-nya yang berbeda, dan menggunakannya untuk memenuhi output ke alamat $K0$ Bob. Penting untuk dicatat bahwa pembayaran ini, setelah alamat tersebut didapatkan, mengikuti proses klasik dan tidak lagi bergantung pada kunci yang terkait dengan BIP47.

Saya akan meringkas langkah-langkah yang baru saja kita lihat bersama untuk mengirim pembayaran BIP47:


- Alice memilih kunci pribadi anak pertama yang berasal dari kode pembayaran pribadinya;
- Ini menghitung titik rahasia pada kurva eliptik menggunakan ECDH dari kunci publik anak pertama yang tidak terpakai yang berasal dari kode pembayaran Bob;
- Ia menggunakan titik rahasia ini untuk menghitung rahasia bersama dengan SHA256;
- Dia menggunakan rahasia bersama ini untuk menghitung titik rahasia baru pada kurva elips;
- Dia menambahkan titik rahasia baru ini ke kunci publik Bob;
- Dia mendapatkan kunci publik baru yang bersifat sementara, yang mana hanya Bob yang memiliki kunci privat yang terkait;
- Alice dapat melakukan transaksi klasik ke Bob dengan alamat penerima sementara yang diturunkan.

![BTC204](assets/fr/230.webp)

Jika Alice ingin melakukan pembayaran kedua, ia akan mengikuti langkah-langkah yang sama seperti sebelumnya, kecuali kali ini ia akan memilih public key kedua yang berasal dari kode pembayaran Bob. Secara khusus, dia akan menggunakan kunci berikutnya yang tidak terpakai. Dengan demikian, ia akan mendapatkan alamat penerima baru milik Bob, yang dinamakan $K1$:

![BTC204](assets/fr/231.webp)

Cara ini dapat dilanjutkan dan menghasilkan hingga `2^32` alamat kosong milik Bob.

Dari perspektif luar, dengan melihat blockchain, secara teoritis tidak mungkin untuk membedakan pembayaran BIP47 dengan pembayaran konvensional. Berikut ini adalah contoh transaksi pembayaran BIP47 di Testnet:

```text
94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254
```

Ini terlihat seperti transaksi klasik dengan input yang dikonsumsi, output pembayaran, dan nilai tukar:

![BTC204](assets/fr/232.webp)

### Tanda terima pembayaran BIP47 dan derivasi kunci pribadi

Alice baru saja melakukan pembayaran pertama ke alamat BIP47 kosong milik Bob. Sekarang mari kita lihat bagaimana Bob menerima pembayaran ini. Kita juga akan melihat mengapa Alice tidak memiliki akses ke private key dari alamat yang baru saja dibuatnya sendiri, dan bagaimana Bob menemukan private key tersebut untuk membelanjakan bitcoin yang baru saja diterimanya.

Segera setelah Bob menerima transaksi notifikasi dari Alice, ia mendapatkan kunci publik BIP47 $K0$ bahkan sebelum korespondennya mengirimkan pembayaran. Oleh karena itu, ia mengamati setiap pembayaran ke alamat terkait. Bahkan, ia langsung mendapatkan beberapa alamat yang ia amati ($K0$, $K1$, $K2$, $K3$...). Berikut adalah bagaimana ia mendapatkan kunci publik $K0$ ini:


- Bob memilih kunci pribadi anak pertama yang berasal dari kode pembayarannya. Kunci pribadi ini diberi nama $b$. Kunci ini diasosiasikan dengan kunci publik $B$ yang digunakan Alice untuk melakukan perhitungan pada langkah sebelumnya:

$$ b $$


- Bob memilih kunci publik pertama Alice yang berasal dari kode pembayarannya. Kunci ini diberi nama $A$. Kunci ini berhubungan dengan kunci pribadi $a$ yang digunakan Alice untuk melakukan perhitungan, dan hanya diketahui oleh Alice. Bob dapat melakukan proses ini, karena ia mengetahui kode pembayaran Alice, yang dikirimkan kepadanya dengan notifikasi transaksi:

$$ A = a \cdot G $$


- Bob menghitung titik rahasia $S$, dengan menambahkan dan menggandakan titik-titik pada kurva eliptik, dengan menggunakan kunci privatnya $b$ pada kunci publik Alice $A$. Di sini, sekali lagi, ECDH digunakan untuk menjamin bahwa titik $S$ ini akan sama untuk Bob dan Alice:

$$ S = b \cdot A $$


- Dengan cara yang sama seperti Alice, Bob mengisolasi absis dari titik ini $S$. Kita menamai nilai ini sebagai $Sx$. Dia memberikan nilai ini ke fungsi SHA256 untuk menemukan rahasia bersama $s$ (huruf kecil):

$$ s = \text{SHA256}(Sx) $$


- Dengan cara yang sama seperti Alice, Bob menghitung titik $s-G$ pada kurva elips. Ia kemudian menambahkan titik rahasia ini ke kunci publik $B$ miliknya. Dia kemudian mendapatkan titik baru pada kurva eliptik, yang dia tafsirkan sebagai kunci publik $K0$:

$$ K0 = B + s \cdot G $$

Setelah Bob memiliki kunci publik $K0$ ini, ia dapat memperoleh kunci privat yang terkait untuk membelanjakan bitcoinnya. Hanya dia yang dapat menghasilkan kunci pribadi ini:


- Bob menjumlahkan kunci pribadi putrinya $b$ yang berasal dari kode pembayaran pribadinya. Hanya dia yang dapat memperoleh nilai $b$. Dia kemudian menambahkan $b$ ke rahasia bersama $s$ untuk mendapatkan $k0$, kunci pribadi $K0$:

$$ k0 = b + s $$

Berkat hukum grup dari kurva eliptik, Bob mendapatkan kunci privat yang sesuai dengan kunci publik yang digunakan oleh Alice. Oleh karena itu, kita memiliki :

$$ K0 = k0 \cdot G $$

Saya akan meringkas langkah-langkah yang baru saja kita lihat bersama untuk menerima pembayaran BIP47 dan menghitung private key yang sesuai:


- Bob memilih kunci pribadi anak pertama yang berasal dari kode pembayaran pribadinya;
- Ini menghitung titik rahasia pada kurva eliptik menggunakan ECDH dari kunci publik anak pertama yang berasal dari kode string Alice;
- Ia menggunakan titik rahasia ini untuk menghitung rahasia bersama dengan SHA256;
- Dia menggunakan rahasia bersama ini untuk menghitung titik rahasia baru pada kurva elips;
- Dia menambahkan titik rahasia baru ini ke kunci publik pribadinya;
- Dia mendapatkan kunci publik baru yang bersifat sementara, kunci publik yang akan digunakan Alice untuk mengirimkan pembayaran pertamanya;
- Bob menghitung kunci pribadi yang terkait dengan kunci publik yang fana ini dengan menambahkan kunci pribadi anak perempuannya yang berasal dari kode pembayarannya dan rahasia bersama.

![BTC204](assets/fr/233.webp)

Karena Alice tidak dapat memperoleh $b$ (kunci pribadi Bob), ia tidak dapat menentukan $k0$ (kunci pribadi yang terkait dengan alamat penerimaan BIP47 milik Bob). Secara skematis, kita dapat merepresentasikan perhitungan rahasia bersama $S$ sebagai berikut:

![BTC204](assets/fr/228.webp)

Setelah rahasia bersama ditemukan dengan ECDH, Alice dan Bob menghitung kunci publik pembayaran BIP47 $K0$, dan Bob juga menghitung kunci privat terkait $k0$:

![BTC204](assets/fr/234.webp)

### Pengembalian pembayaran BIP47

Karena Bob mengetahui kode pembayaran yang dapat digunakan kembali milik Alice, ia sudah memiliki semua informasi yang dibutuhkan untuk mengirimkan pengembalian dana kepadanya. Dia tidak perlu menghubungi Alice lagi untuk meminta informasi apa pun. Dia hanya perlu memberi tahu Alice dengan sebuah transaksi notifikasi, sehingga Alice dapat mengambil alamat BIP47-nya dengan seed-nya, dan kemudian dia juga dapat mengirimkan pembayaran hingga `2^32`.

Fitur pengembalian dana khusus untuk BIP47 dan merupakan salah satu keunggulannya dibandingkan metode lain, seperti Pembayaran Diam, yang akan kita bahas di bab-bab selanjutnya.

Bob kemudian dapat mengganti uang Alice dengan cara yang sama seperti saat ia mengirimkan pembayaran kepadanya. Perannya dibalik:

![BTC204](assets/fr/235.webp)

*Terima kasih banyak kepada [Fanis Michalakis] (https://x.com/FanisMichalakis) atas koreksi dan saran ahli pada artikel yang menginspirasi penulisan bab ini!

https://planb.network/tutorials/privacy/on-chain/paynym-bip47-a492a70b-50eb-4f95-a766-bae2c5535093

## Pembayaran Senyap

<chapterId>2871d594-414e-4598-a830-91c9eb84dfb8</chapterId>


BIP47 telah dikritik secara luas karena ketidakefisienan onchain-nya. Seperti yang telah dijelaskan pada bab sebelumnya, ia membutuhkan transaksi notifikasi yang harus dilakukan untuk setiap penerima baru. Kendala ini menjadi tidak berarti jika kita berencana untuk membuat saluran pembayaran yang berkelanjutan dengan penerima ini. Memang, satu transaksi notifikasi membuka jalan untuk pembayaran BIP47 berikutnya dalam jumlah yang hampir tak terbatas.

Namun, dalam situasi tertentu, transaksi notifikasi dapat menjadi kendala bagi pengguna. Mari kita ambil contoh donasi satu kali kepada penerima: dengan alamat Bitcoin klasik, satu transaksi sudah cukup untuk menyelesaikan donasi. Namun dengan BIP47, diperlukan dua transaksi: satu untuk notifikasi dan satu lagi untuk pembayaran yang sebenarnya. Ketika permintaan untuk ruang blok rendah dan biaya transaksi rendah, langkah ekstra ini biasanya tidak menjadi masalah. Namun, pada saat terjadi kemacetan, biaya transaksi bisa menjadi sangat tinggi untuk satu kali pembayaran, berpotensi menggandakan biaya yang harus dikeluarkan oleh pengguna dibandingkan dengan transaksi Bitcoin standar, yang mungkin tidak dapat diterima oleh pengguna.

Untuk situasi di mana pengguna berencana untuk melakukan hanya beberapa pembayaran ke pengenal statis, solusi lain telah dikembangkan. Ini termasuk Pembayaran Senyap, yang dijelaskan dalam [BIP352] (https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). Protokol ini memungkinkan untuk menggunakan pengenal statis untuk menerima pembayaran tanpa menghasilkan penggunaan ulang alamat, dan tanpa memerlukan penggunaan transaksi notifikasi. Mari kita lihat bagaimana protokol ini bekerja.

---
*Untuk memahami bab ini sepenuhnya, sangat penting untuk menguasai cara kerja ECDH (Elliptic Curve Diffie-Hellman) dan derivasi kunci kriptografi pada HD wallet. Konsep-konsep ini telah dibahas secara mendetail pada bab sebelumnya mengenai BIP47. Saya tidak akan mengulanginya di sini. Jika anda belum terbiasa dengan konsep-konsep ini, saya sarankan anda untuk membaca bab sebelumnya sebelum melanjutkan ke bab ini. Saya tidak akan membahas kembali risiko yang terkait dengan penggunaan ulang alamat penerima, atau pentingnya memiliki pengenal unik untuk menerima pembayaran.* Saya hanya akan menyebutkan beberapa poin yang ingin saya sampaikan di sini

---
### Mengapa tidak memindahkan notifikasi?

Seperti yang telah dibahas dalam bab BIP47, transaksi notifikasi memiliki dua fungsi utama:


- Ini memberi tahu penerima ;
- Ini mengirimkan kode pembayaran pengirim.

Orang mungkin secara naif berpikir bahwa proses notifikasi ini dapat dilakukan di luar rantai. Secara teori, hal ini sangat memungkinkan: yang harus dilakukan oleh penerima adalah menunjukkan sarana komunikasi untuk menerima kode pembayaran BIP47 dari pengirim. Akan tetapi, ada dua masalah utama dengan pendekatan ini:


- Pertama, ini akan memindahkan proses transmisi kode ke protokol komunikasi lain. Masalah yang berkaitan dengan biaya dan kerahasiaan pertukaran akan tetap ada, tetapi hanya akan dipindahkan ke protokol baru ini. Dalam hal kerahasiaan, hal ini juga dapat membuat hubungan antara identitas pengguna dan aktivitas onchain, yang mana hal ini ingin kami hindari dengan melakukan notifikasi langsung pada blockchain. Selain itu, melakukan notifikasi di luar blockchain akan menimbulkan risiko penyensoran (seperti pemblokiran dana) yang tidak ada pada Bitcoin;
- Kedua, hal ini akan menimbulkan masalah pemulihan. Dengan BIP47, penerima harus mengetahui kode pembayaran pengirim untuk mengakses dana. Hal ini berlaku pada saat penerimaan, tetapi juga dalam hal pemulihan dana melalui seed jika dompet hilang. Dengan notifikasi onchain, risiko ini dapat dihindari, karena pengguna dapat mengambil dan mendekripsi transaksi notifikasi hanya dengan mengetahui seed-nya. Akan tetapi, jika notifikasi dilakukan di luar blockchain, pengguna harus menyimpan cadangan dinamis dari semua kode pembayaran yang diterima, yang mana tidak praktis untuk rata-rata pengguna.

Semua kendala ini membuat penggunaan notifikasi onchain sangat penting untuk BIP47. Namun, Silent Payments berusaha untuk menghindari langkah notifikasi onchain ini karena biayanya. Oleh karena itu, solusi yang diadopsi bukanlah memindahkan notifikasi, tetapi menghilangkannya sama sekali. Untuk mencapai hal ini, sebuah kompromi harus diterima: pemindaian. Tidak seperti BIP47, di mana pengguna tahu persis di mana menemukan dananya berkat transaksi notifikasi, dengan Silent Payments, pengguna harus memeriksa semua transaksi Bitcoin yang ada untuk mendeteksi pembayaran apa pun yang ditujukan untuknya. Untuk mengurangi beban operasional ini, pencarian Silent Payments dibatasi hanya pada transaksi yang mungkin mengandung pembayaran tersebut, yaitu transaksi yang memiliki setidaknya satu keluaran Taproot P2TR. Pemindaian ini juga hanya berfokus pada transaksi sejak tanggal pembuatan dompet (tidak perlu memindai transaksi yang berasal dari tahun 2009 jika dompet dibuat pada tahun 2024).

Jadi, Anda dapat melihat mengapa BIP47 dan Pembayaran Diam, meskipun ditujukan untuk tujuan yang sama, melibatkan pertukaran yang berbeda dan oleh karena itu **sesungguhnya memenuhi kasus penggunaan yang berbeda**. Untuk pembayaran satu kali, seperti donasi satu kali, Pembayaran Diam lebih tepat karena biayanya lebih rendah. Di sisi lain, untuk transaksi reguler ke penerima yang sama, seperti dalam kasus platform bursa atau mining pool, BIP47 mungkin lebih disukai.

Mari kita lihat operasi teknis dari Pembayaran Diam untuk lebih memahami apa yang dipertaruhkan. Untuk melakukan hal ini, saya sarankan kita menggunakan pendekatan yang sama dengan dokumen penjelasan BIP352. Kita akan secara bertahap menguraikan perhitungan yang harus dilakukan, elemen demi elemen, membenarkan setiap penambahan baru.

### Beberapa konsep yang perlu dipahami

Sebelum memulai, penting untuk diketahui bahwa Silent Payments hanya bergantung pada penggunaan jenis skrip P2TR (*Pay to Taproot*). Tidak seperti BIP47, tidak perlu untuk mendapatkan alamat penerima dari kunci publik anak dengan melakukan hashing. Pada standar P2TR, kunci publik yang telah di-tweak digunakan secara langsung dan tidak dienkripsi pada alamatnya. Jadi, alamat penerimaan Taproot pada dasarnya adalah kunci publik dengan beberapa metadata. Kunci publik yang telah diubah ini merupakan agregasi dari dua kunci publik lainnya: satu yang memungkinkan pembelanjaan langsung dan tradisional melalui tanda tangan sederhana, dan yang lainnya mewakili akar Merkle dari MAST, yang mengesahkan pembelanjaan sesuai dengan salah satu kondisi yang mungkin tertulis di pohon Merkle.

![BTC204](assets/fr/068.webp)

Ada dua alasan utama mengapa keputusan untuk membatasi Pembayaran Senyap secara eksklusif untuk Taproot:


- Pertama, hal ini sangat memudahkan implementasi dan peningkatan di masa depan dalam perangkat lunak portofolio, karena hanya satu standar yang perlu dipatuhi;
- Kedua, pendekatan ini membantu meningkatkan anonset pengguna dengan mendorong mereka untuk tidak membagi diri mereka di antara berbagai jenis skrip, yang menghasilkan sidik jari portofolio yang berbeda dalam analisis rantai (untuk informasi lebih lanjut tentang konsep ini, silakan lihat bab 4 bagian 2).

### Derivasi naif dari kunci publik Pembayaran Senyap

Mari kita mulai dengan contoh sederhana untuk memahami cara kerja SP (Pembayaran Diam). Kita ambil contoh Alice dan Bob, dua orang pengguna Bitcoin. Alice ingin mengirim Bitcoin ke Bob dengan alamat penerima yang kosong. Ada tiga tujuan dari proses ini:


- Alice harus dapat membuat alamat kosong;
- Bob harus dapat mengidentifikasi pembayaran yang dikirim ke alamat spesifik ini;
- Bob harus bisa mendapatkan kunci pribadi yang terkait dengan alamat ini untuk membelanjakan dananya.

Alice memiliki UTXO di dalam dompet Bitcoinnya yang aman dengan pasangan kunci berikut ini:


- $a$: kunci privat;
- $A$: kunci publik ($A = a \cdot G$)

Bob memiliki alamat SP yang telah ia publikasikan di Internet dengan :


- $b$: kunci pribadi;
- $B$: kunci publik ($B = b \cdot G$)

Dengan mengambil alamat Bob, Alice dapat menghitung alamat kosong baru milik Bob menggunakan ECDH. Kita sebut saja alamat ini sebagai $P$ :

$$ P = B + \text{hash}(a \cdot B) \cdot G $$

Dalam persamaan ini, Alice hanya menghitung hasil skalar dari kunci privatnya $a$ dan kunci publik Bob $B$. Dia telah memasukkan hasil ini ke dalam sebuah fungsi hash yang diketahui oleh semua orang. Nilai yang dihasilkan kemudian dikalikan secara skalar dengan titik pembangkit $G$ dari kurva elips `secp256k1`. Terakhir, Alice menambahkan titik yang dihasilkan ke kunci publik $B$ milik Bob. Setelah Alice memiliki alamat $P$ ini, ia menggunakannya sebagai output dalam sebuah transaksi, yaitu mengirimkan bitcoin ke alamat tersebut.

> *Dalam konteks Pembayaran Diam, fungsi "hash" sesuai dengan fungsi hash SHA256 yang secara khusus ditandai dengan `BIP0352/SharedSecret`, yang memastikan bahwa hash yang dihasilkan unik untuk protokol ini dan tidak dapat digunakan kembali dalam konteks lain, sambil menawarkan perlindungan tambahan terhadap penggunaan kembali nonce dalam tanda tangan. Standar ini sesuai dengan standar [yang ditentukan dalam BIP340 untuk tanda tangan Schnorr] (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) pada `secp256k1`.*
Berkat sifat kurva elips yang menjadi dasar ECDH, kita tahu bahwa :

$$ a \cdot B = b \cdot A $$

Oleh karena itu, Bob akan dapat menghitung alamat penerima yang menjadi tujuan pengiriman bitcoin oleh Alice. Untuk melakukan ini, dia memantau semua transaksi Bitcoin yang memenuhi kriteria Pembayaran Diam dan menerapkan perhitungan berikut pada setiap transaksi untuk melihat apakah pembayaran tersebut ditujukan kepadanya (*pemindaian):

$$ P' = B + \text{hash}(b \cdot A) \cdot G $$

Ketika ia memindai transaksi Alice, ia menyadari bahwa $P'$ sama dengan $P$. Oleh karena itu, ia tahu bahwa pembayaran tersebut ditujukan kepadanya:

$$ P' = B + \text{hash}(b \cdot A) \cdot G = B + \text{hash}(a \cdot B) \cdot G = P $$

Dari sini, Bob akan dapat menghitung kunci privat $p$ yang memungkinkan alamat $P$ untuk dibelanjakan:

$$ p = (b + \text{hash}(b \cdot A)) \bmod n $$

Seperti yang dapat Anda lihat, untuk menghitung kunci privat $p$ ini, Anda harus memiliki kunci privat $b$. Hanya Bob yang memiliki kunci pribadi $b$ ini. Oleh karena itu, dia akan menjadi satu-satunya yang dapat membelanjakan bitcoin yang dikirim ke alamat Silent Payments-nya.

![BTC204](assets/fr/236.webp)

*Legenda:*


- $B$ : Kunci publik/alamat statis yang diterbitkan oleh Bob
- $b$ : Kunci pribadi Bob
- $A$ : Kunci publik UTXO Alice yang digunakan sebagai input transaksi
- $a$ : Kunci pribadi Alice
- $G$ : Titik pembangkit kurva elips `secp256k1`
- $\text{SHA256}$ : Fungsi hash SHA256 yang ditandai dengan `BIP0352/SharedSecret`
- $s$ : Rahasia umum ECDH
- $P$ : Kunci publik/alamat unik untuk pembayaran ke Bob

Berikut ini adalah pendekatan awal yang cukup naif untuk menggunakan alamat statis Bob, yang dicatat sebagai $B$, untuk mendapatkan alamat unik $P$ untuk mengirim bitcoin. Akan tetapi, metode ini terlalu sederhana dan memiliki beberapa kekurangan yang perlu diperbaiki. Masalah pertama adalah, dalam skema ini, Alice tidak dapat membuat beberapa output ke Bob dalam transaksi yang sama.

### Bagaimana cara membuat beberapa output?

Pada contoh di bagian sebelumnya, Alice membuat satu keluaran yang akan dikirimkan ke Bob di alamat uniknya, yaitu $P$. Dengan input yang sama yang dipilih, tidak mungkin bagi Alice untuk membuat dua alamat kosong yang terpisah untuk Bob, karena metode yang digunakan akan selalu menghasilkan hasil yang sama untuk $P$, yaitu alamat yang sama. Akan tetapi, mungkin terdapat banyak situasi dimana Alice ingin membagi pembayarannya kepada Bob ke dalam beberapa jumlah yang lebih kecil, sehingga menciptakan beberapa UTXO. Oleh karena itu, perlu untuk menemukan sebuah metode untuk mencapai hal ini.

Untuk mencapai hal ini, kita akan sedikit memodifikasi perhitungan yang dilakukan Alice untuk mendapatkan $P$, sehingga ia dapat menghasilkan dua alamat yang berbeda untuk Bob, yaitu $P_0$ dan $P_1$.

Untuk memodifikasi perhitungan dan mendapatkan 2 alamat yang berbeda, cukup tambahkan sebuah bilangan bulat yang memodifikasi hasilnya. Dengan demikian, Alice akan menambahkan $0$ pada perhitungannya untuk mendapatkan alamat $P_0$ dan $1$ untuk mendapatkan alamat $P_1$. Kita sebut saja bilangan bulat ini sebagai $i$:

$$ P_i = B + \text{hash}(a \cdot B \text{ ‖ } i) \cdot G $$

Proses perhitungan tetap tidak berubah dari metode sebelumnya, kecuali kali ini Alice akan menggabungkan $a \cdot B$ dengan $i$ sebelum melanjutkan dengan hash. Anda kemudian cukup memodifikasi $i$ untuk mendapatkan alamat baru milik Bob. Sebagai contoh:

$$ P_0 = B + \text{hash}(a \cdot B \text{ ‖ } 0) \cdot G $$

$$ P_1 = B + \text{hash}(a \cdot B \text{ ‖ } 1) \cdot G $$

Ketika Bob memindai blockchain untuk mencari Pembayaran Diam yang ditujukan untuknya, ia mulai dengan menggunakan $i = 0$ untuk alamat $P_0$. Jika ia tidak menemukan pembayaran apa pun pada $P_0$, ia menyimpulkan bahwa transaksi ini tidak mengandung Pembayaran Senyap yang ditujukan untuknya, dan meninggalkan pemindaian. Namun, jika $P_0$ valid dan berisi pembayaran untuknya, ia melanjutkan dengan $P_1$ dalam transaksi yang sama untuk memeriksa apakah Alice telah melakukan pembayaran kedua. Jika $P_1$ ternyata tidak valid, ia berhenti mencari transaksi ini; jika tidak, ia akan terus menguji nilai $i$ yang berurutan:

$$ P_0 = B + \text{hash}(b \cdot A \text{ ‖ } 0) \cdot G $$

$$ P_1 = B + \text{hash}(b \cdot A \text{ ‖ } 1) \cdot G $$

Karena Bob langsung berhenti di $i = 0$ jika $P_0$ tidak bekerja, menggunakan bilangan bulat ini hampir tidak menambah beban operasional tambahan pada Bob untuk tahap pemindaian transaksi.

Bob kemudian dapat menghitung kunci privat dengan cara yang sama:

$$
p_0 = (b + \text{hash}(b \cdot A \text{ ‖ } 0)) \bmod n
$$

$$
p_1 = (b + \text{hash}(b \cdot A \text{ ‖ } 1)) \bmod n
$$

![BTC204](assets/fr/237.webp)

*Legenda:*


- $B$ : Kunci publik/alamat statis yang diterbitkan oleh Bob
- $b$ : Kunci pribadi Bob
- $A$ : Kunci publik UTXO Alice yang digunakan sebagai input transaksi
- $a$ : Kunci pribadi Alice
- $G$ : Titik pembangkit kurva elips `secp256k1`
- $\text{SHA256}$ : Fungsi hash SHA256 yang ditandai dengan `BIP0352/SharedSecret`
- $s_0$ : ECDH rahasia umum pertama
- $s_1$ : Rahasia umum ECDH kedua
- $P_0 $ : Kunci publik pertama / alamat unik untuk pembayaran ke Bob
- $ P_1 $ : Kunci publik kedua / alamat unik untuk pembayaran ke Bob

Dengan metode ini, kita mulai mendapatkan protokol yang bagus, tetapi masih ada beberapa tantangan yang harus diatasi, tidak terkecuali pencegahan penggunaan ulang alamat.

### Bagaimana cara menghindari penggunaan ulang alamat?

Seperti yang telah kita lihat pada bagian sebelumnya, Alice menggunakan pasangan kunci yang mengamankan UTXO miliknya, yang akan ia gunakan untuk menghitung rahasia bersama ECDH dengan Bob. Rahasia ini memungkinkannya untuk mendapatkan alamat unik $P_0$. Akan tetapi, pasangan kunci ($a$, $A$) yang digunakan oleh Alice dapat mengamankan beberapa UTXO jika ia menggunakan alamat ini beberapa kali. Jika Alice melakukan dua kali pembayaran ke alamat statis Bob, $B$, dengan menggunakan dua UTXO yang diamankan dengan kunci yang sama, $A$, hal ini akan mengakibatkan penggunaan ulang alamat untuk Bob.

> *Penggunaan ulang alamat adalah praktik yang sangat buruk dalam hal kerahasiaan pengguna. Untuk mengetahui alasannya, saya sarankan Anda untuk meninjau bagian pertama dari kursus pelatihan ini.*
Memang, karena alamat unik $P_0$ berasal dari $A$ dan $B$, maka jika Alice mendapatkan alamat kedua untuk pembayaran kedua ke $B$, dengan kunci yang sama $A$, ia akan mendapatkan alamat yang sama persis dengan $P_0$. Untuk menghindari risiko ini dan mencegah penggunaan ulang alamat dalam Pembayaran Senyap, kita harus memodifikasi sedikit perhitungan kita.

Apa yang kita inginkan adalah setiap UTXO yang dikonsumsi oleh Alice sebagai input untuk pembayaran memberikan alamat unik di sisi Bob, bahkan jika beberapa UTXO diamankan oleh pasangan kunci yang sama. Jadi, yang perlu kita lakukan adalah menambahkan referensi ke UTXO ketika menghitung alamat unik $P_0$. Referensi ini hanya akan berupa hash dari UTXO yang digunakan sebagai input:

$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$

Dan Alice akan menambahkan referensi ini ke dalam input untuk perhitungan alamat unik $P_0$ :

$$ P_0 = B + \text{hash}(\text{inputHash} \cdot a \cdot B \text{ ‖ } 0) \cdot G $$

Ketika memindai, Bob juga dapat menambahkan $\text{inputHash}$, karena yang harus ia lakukan adalah mengamati transaksi untuk menyimpulkan $\text{outpoint}$:

$$ P_0 = B + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0) \cdot G $$

Ketika menemukan $P_0$ yang valid, ia dapat menghitung kunci privat $p_0$ yang sesuai:

$$
p_0 = (b + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0)) \bmod n
$$

![BTC204](assets/fr/238.webp)

*Legenda:*


- $B$ : Kunci publik/alamat statis yang diterbitkan oleh Bob
- $b$ : Kunci pribadi Bob
- $A$ : Kunci publik UTXO Alice yang digunakan sebagai input transaksi
- $a$ : Kunci pribadi Alice
- $ H $ : Hash UTXO digunakan sebagai input
- $G$ : Titik pembangkit kurva elips `secp256k1`
- $\text{SHA256}$ : Fungsi hash SHA256 yang ditandai dengan `BIP0352/SharedSecret`
- $s_0$ : Rahasia umum ECDH yang pertama
- $P_0 $ : Kunci publik pertama / alamat unik untuk pembayaran ke Bob

Untuk saat ini, perhitungan kami mengasumsikan bahwa Alice menggunakan satu input untuk transaksinya. Akan tetapi, dia seharusnya dapat menggunakan beberapa input. Oleh karena itu, di sisi Bob, untuk setiap transaksi yang melibatkan beberapa input, ia harus menghitung ECDH untuk setiap input untuk menentukan apakah sebuah pembayaran ditujukan untuknya. Metode ini tidak memuaskan, jadi kita perlu mencari solusi untuk mengurangi beban kerja!

### Mengubah kunci publik menjadi input

Untuk mengatasi masalah ini, alih-alih menggunakan pasangan kunci yang mengamankan input tertentu di sisi Alice, kita akan menggunakan jumlah semua pasangan kunci yang digunakan dalam input transaksi. Jumlah ini kemudian akan dianggap sebagai sebuah pasangan kunci yang baru. Teknik ini dikenal dengan istilah "tweaking".

Sebagai contoh, bayangkan transaksi Alice memiliki 3 input, masing-masing diamankan dengan pasangan kunci yang berbeda:


- $a_0$ digunakan untuk mengamankan masukan #0 ;
- $a_1$ digunakan untuk mengamankan input #1;
- $a_2$ mengamankan masukan #2.

![BTC204](assets/fr/239.webp)

Mengikuti metode yang telah dijelaskan sebelumnya, Alice harus memilih satu pasangan kunci dari antara $a_0$, $a_1$, dan $a_2$ untuk menghitung rahasia ECDH dan menghasilkan alamat pembayaran tunggal $P$ dari alamat statis Bob, yaitu $B$. Akan tetapi, pendekatan ini mengharuskan Bob untuk menguji setiap kemungkinan secara berurutan, dimulai dari $a_0$, kemudian $a_1$, dan seterusnya, hingga ia mengidentifikasi pasangan yang menghasilkan alamat $P$ yang valid. Proses ini mengharuskan Bob untuk menjalankan kalkulasi ECDH pada semua input untuk semua transaksi, yang secara signifikan meningkatkan beban operasional pemindaian.

Untuk menghindari hal ini, kita akan meminta Alice untuk menghitung $P$ dengan menggunakan jumlah dari semua kunci input. Dengan menggunakan contoh kita, kunci privat yang telah diubah, $a$ akan dihitung sebagai berikut:

$$ a = a_0 + a_1 + a_2 $$

Dengan cara yang sama, Alice dan Bob dapat menghitung kunci publik yang telah diubah:

$$ A = A_0 + A_1 + A_2 $$

Dengan metode ini, Bob hanya perlu menghitung jumlah dari kunci publik transaksi, kemudian menghitung rahasia ECDH dari $A saja, yang sangat mengurangi jumlah perhitungan yang diperlukan untuk tahap pemindaian.

Namun, ingatlah bagian sebelumnya. Kita telah menambahkan hash $\text{inputHash}$ ke dalam perhitungan kita, yang digunakan sebagai nonce untuk menghindari penggunaan ulang alamat:

$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$

Namun jika Anda memiliki beberapa input dalam sebuah transaksi, Anda harus dapat menentukan $\text{outpoint}$ mana yang dipilih dalam perhitungan ini. Menurut BIP352, kriteria pemilihan $\text{outpoint}$ yang akan digunakan adalah memilih yang terkecil secara leksikografis, yang berarti memilih UTXO yang muncul pertama kali dalam urutan abjad. Metode ini menstandarkan UTXO yang akan dipilih dalam setiap transaksi. Sebagai contoh, jika $\text{outpoint}$ terkecil secara leksikografis ini adalah $\text{outpoint}_L$, maka perhitungan $\text{inputHash}$ adalah :

$$ \text{inputHash} = \text{hash}(\text{outpoint}_L \text{ ‖ } A) $$

Perhitungannya kemudian tetap sama dengan yang disajikan pada bagian sebelumnya, kecuali bahwa kunci privat $a$ dan kunci publiknya $A$ tidak lagi menjadi pasangan yang digunakan untuk mengamankan satu input, tetapi sekarang merepresentasikan perubahan untuk semua pasangan kunci pada input.

### Tombol pengeluaran dan pemindaian terpisah

Untuk saat ini, kita telah merujuk pada alamat statis Silent Payment $B$ sebagai kunci publik yang unik. Ingat, kunci publik $B$ inilah yang digunakan Alice untuk membuat ECDH rahasia bersama, yang pada gilirannya akan menghitung alamat pembayaran unik $P$. Bob menggunakan kunci publik $B$ dan kunci privat $b$ yang sesuai untuk tahap pemindaian. Tetapi dia juga akan menggunakan kunci pribadi $b$ untuk menghitung kunci pribadi $p$ yang memungkinkan pembelanjaan dari alamat $P$.

Kerugian dari metode ini adalah kunci pribadi $b$, yang digunakan untuk menghitung semua kunci pribadi dari alamat yang telah menerima Pembayaran Diam, juga digunakan oleh Bob untuk memindai transaksi. Langkah ini mengharuskan kunci $b$ tersedia pada perangkat lunak dompet yang terhubung ke internet, yang membuatnya lebih rentan terhadap risiko pencurian daripada menyimpannya di dompet dingin. Idealnya, akan sangat menguntungkan untuk dapat mengambil keuntungan dari Silent Payments dengan tetap menjaga kunci pribadi $b$, yang mengontrol akses ke semua kunci pribadi lainnya, tetap aman di dompet perangkat keras. Untungnya, protokol ini telah diadaptasi untuk memungkinkan hal tersebut.

Untuk melakukan hal ini, BIP352 mengharuskan receiver menggunakan 2 pasang tombol yang berbeda:


- b_{\text{spend}}$: untuk menghitung kunci privat dari alamat pembayaran yang unik;
- b_{\text{scan}}$: untuk menemukan alamat pembayaran yang unik.

Dengan cara ini, Bob dapat menyimpan private key $b_{\text{spend}}$ pada perangkat keras dompet dan menggunakan private key $b_{\text{scan}}$ pada perangkat lunak online untuk menemukan Silent Payments miliknya, tanpa membuka $b_{\text{spend}}$. Di sisi lain, kunci publik $B_{\text{scan}}}$ dan $B_{\text{spend}}}$ keduanya diungkapkan secara publik, karena keduanya terletak di alamat statis Bob, yaitu $B$:

$$ B = B_{\text{scan}} \text{ ‖ } B_{\text{membelanjakan}} $$

Untuk menghitung alamat pembayaran unik $P_0$ milik Bob, Alice sekarang akan melakukan perhitungan berikut:

$$ P_0 = B_{\text{spend}} + \text{hash}(\text{inputHash} \cdot a \cdot B_{\text{scan}} \text{ ‖ } 0) \cdot G $$

Untuk menemukan pembayaran yang ditujukan kepadanya, Bob akan melakukan perhitungan berikut:

$$ P_0 = B_{\text{buang}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$

Seperti yang dapat Anda lihat, sejauh ini Bob tidak perlu menggunakan $b_{\text{spend}}$, yang ada pada dompet perangkat kerasnya. Ketika ia ingin membelanjakan $P_0$, ia dapat melakukan perhitungan berikut untuk menemukan kunci pribadi $p_0$ :

$$ p_0 = (b_{\text{pengeluaran}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0)) \bmod n $$

![BTC204](assets/fr/240.webp)

*Legenda:*


- $B_{\text{scan}}$: Kunci pemindaian publik Bob (alamat statis)
- $b_{\text{scan}}$ : Kunci pemindaian pribadi Bob
- $B_{\text{spend}}$ : Kunci pengeluaran publik Bob (alamat statis)
- $b_{\text{spend}}$ : Kunci pengeluaran pribadi Bob
- $A$ : Jumlah input kunci publik (tweak)
- $a$ : Kunci pribadi yang sesuai dengan kunci publik yang telah diubah
- $H$ : Hash dari UTXO terkecil (secara leksikografis) yang digunakan sebagai input
- $G$ : Titik pembangkit kurva elips `secp256k1`
- $\text{SHA256}$ : Fungsi hash SHA256 yang ditandai dengan `BIP0352/SharedSecret`
- $s_0$ : ECDH rahasia umum pertama
- $P_0 $ : Kunci publik pertama / alamat unik untuk pembayaran ke Bob

### Menggunakan alamat SP dengan label

Oleh karena itu, Bob memiliki alamat statis $B$ untuk Pembayaran Diam seperti :

$$ B = B_{\text{scan}} \text{ ‖ } B_{\text{membelanjakan}} $$

Masalah dengan metode ini adalah metode ini tidak memungkinkan Anda untuk memisahkan pembayaran yang berbeda yang dikirim ke alamat ini. Sebagai contoh, jika Bob memiliki 2 pelanggan yang berbeda untuk bisnisnya, dan dia ingin membedakan pembayaran ke masing-masing pelanggan, dia akan membutuhkan 2 alamat statis yang berbeda. Solusi yang naif, dengan pendekatan saat ini, adalah Bob membuat dua dompet yang terpisah, masing-masing dengan alamat statisnya sendiri, atau bahkan membuat dua alamat statis yang berbeda di dalam dompet yang sama. Akan tetapi, solusi ini membutuhkan pemindaian seluruh blockchain dua kali (satu kali untuk setiap alamat) untuk mendeteksi pembayaran yang ditujukan untuk masing-masing alamat. Pemindaian ganda ini meningkatkan beban operasional Bob secara tidak wajar.

Untuk mengatasi masalah ini, BIP352 menggunakan sistem label yang mengizinkan alamat statis yang berbeda, tanpa menambah beban kerja yang tidak masuk akal untuk menemukan Pembayaran Diam di blockchain. Untuk melakukan ini, kita menambahkan sebuah bilangan bulat $m$ ke dalam kunci pengeluaran publik $B_{\text{spend}}$. Bilangan bulat ini dapat mengambil nilai $1$ untuk alamat statis pertama, kemudian $2$ untuk alamat statis kedua, dan seterusnya. Kunci pengeluaran $B_{\text{spend}}$ sekarang akan disebut $B_m$ dan akan dibangun dengan cara ini:

$$ B_m = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } m) \cdot G $$

Misalnya, untuk kunci pengeluaran pertama dengan label $1$ :

$$ B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G $$

Alamat statis yang diterbitkan oleh Bob sekarang akan terdiri dari $B_{\text{scan}}$ dan $B_m$. Sebagai contoh, alamat statis pertama dengan label $1$ akan menjadi :

$$ B = B_{\text{scan}} \text{ ‖ } B_1 $$

> *Kami hanya memulai dari label 1 karena label 0 dicadangkan untuk perubahan.*
Alice, pada bagiannya, akan mendapatkan alamat pembayaran tunggal $P$ dengan cara yang sama seperti sebelumnya, tetapi menggunakan $B_1$ yang baru, bukan $B_{\text{spend}}$:

$$ P_0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B_{\text{scan}} \text{ ‖ } 0) \cdot G $$

Pada kenyataannya, Alice bahkan tidak perlu tahu bahwa Bob memiliki alamat berlabel, karena dia hanya menggunakan bagian kedua dari alamat statis yang dia berikan, dan dalam kasus ini, ini adalah nilai $B_1$ daripada $B_{text{spend}}$.

Untuk memindai pembayaran, Bob akan selalu menggunakan nilai alamat statis awalnya dengan $B_{\text{spend}}$ dengan cara ini:

$$ P_0 = B_{\text{buang}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$

Kemudian, dia hanya mengurangkan nilai yang dia temukan untuk $P_0$ dari setiap output satu per satu. Dia kemudian memeriksa apakah salah satu hasil dari pengurangan ini cocok dengan nilai salah satu label yang dia gunakan pada portofolionya. Jika, misalnya, output #4 cocok dengan label $1$, ini berarti bahwa output ini adalah Pembayaran Diam yang terkait dengan alamat yang dilabeli secara statis $B_1$:

$$ Out_4 - P_0 = \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G $$

Ini bekerja karena :

$$ B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G $$

Berkat metode ini, Bob dapat menggunakan banyak alamat statis ($B_1$, $B_2$, $B_3$...), semuanya berasal dari alamat statis dasarnya ($B = B_{\text{scan}} \text{ ‖ } B_{\text{spend}}$), untuk menjaga agar penggunaan tetap terpisah.

Namun, harap diperhatikan bahwa pemisahan alamat statis ini hanya berlaku dari sudut pandang manajemen portofolio pribadi, tetapi tidak memisahkan identitas. Karena semuanya memiliki $B_{\text{scan}}$ yang sama, sangat mudah untuk mengaitkan semua alamat statis bersama-sama dan menyimpulkan bahwa mereka adalah milik satu entitas.

![BTC204](assets/fr/241.webp)

*Legenda:*


- $B_{\text{scan}}$: Kunci pemindaian publik Bob (alamat statis)
- $b_{\text{scan}}$ : Kunci pemindaian pribadi Bob
- $B_{\text{spend}}$ : Kunci pengeluaran publik Bob (alamat awal)
- $B_m$ : Kunci pengeluaran publik Bob yang diberi label (alamat statis)
- $b_m$: Kunci pengeluaran pribadi Bob yang diberi label
- $A$ : Jumlah input kunci publik (tweak)
- $a$ : Kunci pribadi yang sesuai dengan kunci publik yang telah diubah
- $H$ : Hash dari UTXO terkecil (secara leksikografis) yang digunakan sebagai input
- $G$ : Titik pembangkit kurva elips `secp256k1`
- $\text{SHA256}$ : Fungsi hash SHA256 yang ditandai dengan `BIP0352/SharedSecret`
- $s_0$ : Rahasia umum ECDH yang pertama
- $P_0 $ : Kunci publik pertama / alamat unik untuk pembayaran ke Bob
- $p_0$ : Kunci pribadi dari alamat pembayaran unik pertama ke Bob
- $X$ : Hash dari kunci pribadi pemindaian dengan label

### Bagaimana cara membuat alamat Pembayaran Diam?

Untuk membuat alamat yang didedikasikan untuk Pembayaran Senyap, pertama-tama Anda harus mendapatkan 2 pasangan kunci dari dompet Bitcoin HD Anda:


- Pasangan $b_{\text{scan}}$, $B_{\text{scan}}$ untuk mencari pembayaran yang ditujukan kepada kami;
- Pasangan $b_{\text{spend}}$, $B_{\text{spend}}$ untuk memikirkan bitcoin yang telah kita terima.

Pasangan ini diperoleh dengan menggunakan jalur berikut (*Bitcoin Mainnet*):

```text
scan : m / 352' / 0' / 0' / 1' / 0
spend : m / 352' / 0' / 0' / 0' / 0
```

Setelah kita memiliki 2 pasang kunci ini, kita cukup menggabungkannya (ujung ke ujung) untuk membuat muatan alamat statis:

$$ B = B_{\text{scan}} \text{ ‖ } B_{\text{membelanjakan}} $$

Jika kita ingin menggunakan label, kita akan mengganti $B_{\text{spend}}$ dengan $B_m$ :

$$ B = B_{\text{scan}} \text{ ‖ } B_m $$

Dengan label $ m $ :

$$ B_m = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } m) \cdot G $$

Setelah kita mendapatkan payload ini, kita tambahkan HRP (*Human-Readable Part*) `sp` dan versi `q` (= versi 0). Kami juga menambahkan checksum dan memformat alamat sebagai bech32m.

Sebagai contoh, berikut ini adalah alamat statis Pembayaran Diam saya:

```text
sp1qqvhjvsq2vz8zwrw372vuzle7472zup2ql3pz64yn5cpkw5ngv2n6jq4nl8cgm6zmu48yk3eq33ryc7aam6jrvrg0d0uuyzecfhx2wgsumcurv77e
```

Poin penting mengenai alamat statis, yang mungkin sudah Anda pahami pada bagian sebelumnya, adalah bahwa alamat ini tidak terlihat dalam transaksi Bitcoin. Hanya alamat pembayaran $P$ yang digunakan dalam output yang muncul di blockchain dalam format Taproot standar. Jadi, dari luar, tidak mungkin untuk membedakan transaksi yang melibatkan Silent Payment dengan transaksi biasa yang menggunakan output P2TR.

Seperti halnya BIP47, tidak mungkin untuk membuat koneksi antara alamat statis $B$ dan alamat pembayaran $P$ yang berasal dari $B$. Bahkan, walaupun Eve, seorang penyerang potensial, mencoba untuk memindai blockchain dengan alamat statis $B$ milik Bob, ia tidak akan dapat melakukan perhitungan yang dibutuhkan untuk menentukan $P$. Untuk melakukannya, ia akan membutuhkan kunci pribadi Bob $b_{\text{scan}}$, atau kunci pribadi pengirim $a$, tetapi keduanya tentu saja bersifat pribadi. Oleh karena itu, sangat mungkin untuk secara eksplisit menghubungkan alamat statis seseorang dengan sebuah bentuk identitas pribadi.

### Bagaimana cara menggunakan Pembayaran Diam?

Proposal Silent Payments relatif baru dan hanya diimplementasikan oleh sejumlah kecil dompet saat ini. Sepengetahuan saya, hanya ada 3 produk perangkat lunak yang mendukungnya:


- [CakeWallet](https://cakewallet.com/)
- [Silentium](https://app.silentium.dev/)
- [DonationWallet](https://github.com/Sosthene00/donationwallet)

Kami akan segera memberikan tutorial terperinci tentang cara mengatur alamat statis Silent Payments Anda sendiri.

Karena fitur ini masih baru, kami menyarankan Anda untuk berhati-hati dan menghindari penggunaan Pembayaran Senyap dalam jumlah besar di mainnet.

*Untuk membuat bab tentang Pembayaran Diam, saya menggunakan [situs penjelasan Pembayaran Diam](https://silentpayments.xyz/) dan [dokumen penjelasan BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki).*

# Bagian Akhir

<partId>2aee56c0-b285-4799-b4f7-373a552ee2b2</partId>

## Ulasan & Peringkat

<chapterId>195d149f-80fa-5816-8b46-995a9226d082</chapterId>

<isCourseReview>true</isCourseReview>

## Ujian akhir

<chapterId>e803d394-e3c1-5816-a6b4-a69a2472019c</chapterId>

<isCourseExam>true</isCourseExam>

## Kesimpulan

<chapterId>cd8e5c67-50e4-4dcd-8e04-88ba5ec95305</chapterId>

<isCourseConclusion>true</isCourseConclusion>
