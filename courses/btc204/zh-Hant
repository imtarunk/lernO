---
name: Bitcoin 上的隱私權
goal: 了解並掌握使用 Bitcoin 時的隱私權保護原則
objectives: 

  - 定義理解隱私權問題所需的理論概念
  - 識別並降低與 Bitcoin 使用者失密相關的風險
  - 在 Bitcoin 上使用保護您隱私的方法和工具
  - 瞭解連鎖分析方法並制定防禦策略

---
# 在 Bitcoin 上保護您的隱私

在金融交易的保密性逐漸成為奢侈品的今天，了解並掌握使用 Bitcoin 時的隱私權保護原則至關重要。本訓練課程提供您所有理論與實務的關鍵，讓您能自主達成此目標。

今天，在 Bitcoin 上，有公司專門從事 Blockchain 分析。他們的核心業務正是入侵您的私人領域，以損害您交易的機密性。事實上，在 Bitcoin 中並沒有「隱私權」這種東西。因此，應由您，使用者，來維護您的自然權利並保護您交易的機密性，因為沒有人會替您做這件事。

本課程的設計既全面又具概括性。每個技術概念都有詳細的說明，並有圖表解釋。目的是讓所有人都能獲得相關知識。因此，BTC204 是初學者和中級使用者都能負擔得起的。本課程也為更有經驗的比特幣使用者提供附加價值，因為我們深入探討某些經常被誤解的技術概念。

加入我們，改變您對 Bitcoin 的使用方式，成為知情的使用者，能夠瞭解與機密性相關的問題，並保護您的隱私。

+++
# 簡介

<partId>e17474a8-8899-4bdb-a7f8-bc52ddb01440</partId>

## 訓練介紹

<chapterId>08ba1933-f393-4fb5-8279-777d874caedb</chapterId>

在金融交易的機密性逐漸成為奢侈品的今天，了解並掌握使用 Bitcoin 時的隱私權保護原則至關重要。本訓練課程提供您所有理論與實務的關鍵，讓您能自主達成此目標。

今天，在 Bitcoin 上，有公司專門從事 Blockchain 分析。他們的核心業務正是入侵您的私人領域，以損害您交易的機密性。事實上，在 Bitcoin 中並沒有「隱私權」這種東西。因此，應由您，使用者，來維護您的自然權利，並保護您交易的機密性，因為沒有人會替您做這件事。

Bitcoin 不只是「數字往上升」和儲蓄保值。憑藉其獨特的特性和歷史，它首先是反經濟的工具。多虧了這項強大的發明，您可以自由地處理您的金錢，花掉它、累積它，而沒有人能阻止您。

Bitcoin 讓您和平地脫離國家的枷鎖，讓您充分享受您的自然權利，而這些權利是既有法律所無法挑戰的。感謝 Satoshi Nakamoto 的發明，您有能力強制尊重您的私有財產，並重新獲得 Contract 的自由。

不過，Bitcoin 並非默認匿名，這對於從事反經濟活動的個人來說可能是一種風險，尤其是在專制統治的地區。但這並不是唯一的危險。由於 Bitcoin 是寶貴且不可識別的資產，因此可能成為竊賊的目標。因此，保護您的隱私也變成了一個安全問題：它可以幫助您防止駭客入侵和人身攻擊。

正如我們將要看到的，雖然協定本身提供了某些機密性保護，但使用其他工具來優化和捍衛這種機密性也是至關重要的。

本訓練課程旨在提供 Bitcoin 機密性所涉及問題的全面概觀。每個技術概念都有詳細說明，並輔以解釋圖表。目的是讓每個人，甚至是初學者和中級用戶都能理解這些知識。對於經驗較豐富的比特幣使用者，我們也會在整個課程中涵蓋一些技術性很強，有時也是很少人知道的概念，以加深對每個主題的理解。

本訓練課程的目的不是讓您在使用 Bitcoin 時完全匿名，而是提供您基本的工具，讓您知道如何根據個人目標保護您的機密。您可以自由地從介紹的概念和工具中選擇，根據您的特定目標和需求制定自己的策略。

### 第 1 節：定義和關鍵概念

首先，我們要回顧一下支配 Bitcoin 運作的基本原則，如此一來，我們就可以冷靜地處理與機密性相關的概念。掌握一些基本概念是很有必要的，例如 UTXO、接收位址和腳本，這樣才能完全理解我們在接下來的章節中要介紹的概念。我們也將介紹 Bitcoin 的一般保密性模型，正如 Satoshi Nakamoto 所想像的一樣，這將使我們能夠掌握相關的利害關係和風險。

![BTC204](assets/fr/001.webp)

### 第 2 節：瞭解和防護連鎖分析

在第二部分，我們將探討 Blockchain 分析公司用來追蹤您在 Bitcoin 上活動的技術。了解這些方法對於加強您的隱私權保護至關重要。本節的目的是檢視攻擊者的策略，以便更好地瞭解風險，並為我們將在以下各節中研究的技術做好準備。我們會分析交易模式、內外部啟發式方法，以及對這些模式可能的詮釋。除了理論之外，我們還會透過實例和練習，學習如何使用 Block explorer 進行連鎖分析。

![BTC204](assets/fr/002.webp)

### 第 3 節：掌握保護您隱私權的最佳做法

在培訓課程的第三部分，我們將進入細節：練習！目的是掌握所有基本的最佳實務，這些實務應該成為任何 Bitcoin 使用者的自然反應。我們將介紹空白位址的使用、標記、整合、完整節點的使用，以及 KYC 和獲取方法。我們的目的是為您提供一個全面的概覽，讓您了解要避免的陷阱，以便在我們追求保護隱私權的過程中建立穩固的基礎。對於其中一些實務，我們會引導您參閱如何實作的特定教學。

![BTC204](assets/fr/003.webp)

### 第 4 節：瞭解 CoinJoin 交易

談到 Bitcoin 上的隱私權，怎麼能不提 coinjoins 呢？在第 4 節中，您將瞭解有關這種混合方法的所有資訊。您將學習到什麼是 coinjoins、它的歷史和目標，以及 CoinJoin 存在的不同類型。最後，對於較有經驗的使用者，我們會看看什麼是 anonsets 和 entropy，以及如何計算它們。

![BTC204](assets/fr/004.webp)

### 第 5 節：了解其他先進保密技術的挑戰

在第五部分，我們會看看除了 CoinJoin 之外，在 Bitcoin 上可以保護您隱私的所有其他技術。多年來，開發人員在設計專門保護隱私的工具時展現了非凡的創造力。我們將探討所有這些方法，例如 PayJoin、協同交易、Coin Swap 和 Atomic Swap，詳細說明它們的運作方式、目標和任何弱點。

我們也會研究節點網路和交易傳播層級的隱私權。我們也會討論多年來為了加強 Bitcoin 上使用者隱私權而提出的各種通訊協定，包括靜態 Address 通訊協定。

![BTC204](assets/fr/005.webp)

# 定義和主要概念

<partId>b9bbbde3-34c0-4851-83e8-e2ffb029cf31</partId>

## Bitcoin 的 UTXO 型號

<chapterId>8d6b50c5-bf74-44f4-922b-25204991cb75</chapterId>

Bitcoin 首先是一種貨幣，但您真的知道 BTC 在協定上的表示方式嗎？

### Bitcoin 上的 UTXOs：它們是什麼？

Bitcoin 通訊協定以 UTXO 模式為基礎，代表「未使用的交易輸出」。

這種模式與傳統的銀行體系有很大的不同，傳統的銀行體系依賴帳戶和餘額機制來追蹤資金流。事實上，在銀行體系中，個人的餘額被保存在與身份相關的帳戶中。例如，當您從麵包師傅那裡買了一根法棍，您的銀行只需從您的帳戶中扣除購買的金額，減少您的餘額，而麵包師傅的帳戶則貸記相同的金額，增加其餘額。在這個系統中，除了交易記錄之外，您帳戶內的錢和您帳戶外的錢之間沒有任何關聯。

![BTC204](assets/fr/006.webp)

Bitcoin 的運作方式不同。帳戶的概念並不存在，貨幣單位也不是透過餘額來管理，而是透過 UTXOs 來管理。一個 UTXO 代表特定數量的比特幣，這些比特幣尚未被花掉，因此形成「一塊 Bitcoin」，可大可小。例如，一個 UTXO 可以值 `500 BTC` 或簡單的 `700 Sats`。

**> Satoshi，通常縮寫為 sat，是 Bitcoin 的最小單位，相當於法定貨幣中的美分。

```plaintext
1 BTC = 100 000 000 SATS
```

理論上，一個 UTXO 可以代表任何價值的比特幣，從一個 sat 到理論最大值約 2,100 萬 BTC 不等。然而，邏輯上不可能擁有所有的 2,100 萬個比特幣，而且有一個較低的經濟門檻，稱為「Dust」，低於這個門檻的 UTXO 被認為在經濟上是無利可圖的。

**> 在 Bitcoin 上創建的最大 UTXO 的價值為`500,000 BTC`。它是 MtGox 平台在 2011 年 11 月的一次整合行動中創建的：[29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf](https://Mempool.space/fr/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)

### UTXOs和支出條件

UTXOs 是 Exchange 在 Bitcoin 上的工具。每次交易都會消耗作為輸入的 UTXOs，並產生作為輸出的新 UTXOs。當交易完成時，用於輸入的 UTXO 被視為已 「耗盡」，新的 UTXO 會產生，並分配給交易輸出中指示的接收者。因此，UTXO 只代表未用完的交易輸出，也就是在特定時間屬於使用者的比特幣數量。

![BTC204](assets/fr/007.webp)

所有的 UTXO 都是由定義可使用條件的腳本所保護。要使用 UTXO，使用者必須向網路證明他或她符合保護 UTXO 的腳本所規定的條件。通常，UTXO 受公開金鑰 (或代表此公開金鑰的接收 Address) 保護。若要使用與此公開金鑰相關的 UTXO，使用者必須提供使用此金鑰所做的數位簽章，以證明他持有對應的私人金鑰。這就是為什麼我們說您的 Bitcoin Wallet 實際上並不包含比特幣，而是儲存了您的私人密碼鑰匙，而私人密碼鑰匙又讓您可以存取您的 UTXOs，進而存取它們所代表的比特幣。

![BTC204](assets/fr/008.webp)

由於 Bitcoin 中沒有帳號的概念，因此 Wallet 的餘額就是它可以花費的所有 UTXO 的總和。例如，如果您的 Bitcoin Wallet 可以花費以下 4 個 UTXO：

```plaintext
- 2 BTC
- 8 BTC
- 5 BTC
- 2 BTC
```

您的投資組合總結餘將為 `17 BTC`。

![BTC204](assets/fr/009.webp)

## Bitcoin 交易的結構

<chapterId>29d3aaab-de2e-4746-ab40-c9748898850c</chapterId>

### 交易輸入和輸出

Bitcoin 交易是記錄在 Blockchain 上的一個操作，將 Ownership 的比特幣從一個人轉移至另一個人。更精確的說，因為我們是在 UTXO 模型上，而且沒有帳號，所以交易滿足了保證一個或多個 UTXOs 的支出條件，消耗它們，等於創造了有新支出條件的新 UTXOs。簡而言之，交易將比特幣從滿足的腳本移動到新的腳本，新的腳本是為了確保比特幣的安全而設計的。

![BTC204](assets/fr/010.webp)

因此，每個 Bitcoin 交易由一個或多個輸入和一個或多個輸出組成。輸入是 generate 輸出的交易所消耗的 UTXO。輸出是新的 UTXO，可作為未來交易的輸入。

![BTC204](assets/fr/011.webp)

**> 理論上，一個 Bitcoin 交易可以有無限多的輸入和輸出。唯一的限制是最大區塊大小。

Bitcoin 交易中的每個輸入都是指先前未使用的 UTXO。要使用 UTXO 作為輸入，其持有者必須證明他/她是合法的擁有者，方法是驗證相關的腳本，也就是滿足所施加的支出條件。一般而言，這意味著提供一個數位簽章，該數位簽章是以對應公開金鑰的私密金鑰製作，而公開金鑰則是該 UTXO 的最初保證。因此，腳本包括驗證該簽章與收到資金時所使用的公開金鑰相符。

![BTC204](assets/fr/012.webp)

每個輸出依次指定要轉移的比特幣數量以及接收者。後者是由新的腳本定義的，通常是用接收的 Address 或新的公開金鑰來封鎖新建立的 UTXO。

根據共識規則，總輸出必須小於或等於總輸入，交易才會被視為有效。換句話說，交易產生的新 UTXOs 總和不得超過作為輸入消耗的 UTXOs 總和。這個原則是合乎邏輯的：如果您只有 `500,000 Sats`，您就不能購買 `700,000 Sats`。

### Exchange 並在 Bitcoin 交易中合併

因此，Bitcoin 交易對 UTXO 的作用可以比作重新鑄造一枚金幣。事實上，UTXO 是不可分割的，只能熔化。這意味著用戶不能簡單地將一個代表一定金額比特幣的 UTXO 分為幾個較小的 UTXO。他必須在交易中完全消耗 UTXO，以創造一個或多個任意輸出值的新 UTXO，而這些數值必須小於或等於初始值。

此機制與金幣相似。假設您擁有一枚 2 盎司的硬幣，但想要支付 1 盎司的金額，假設賣方不能給您找零錢。您必須熔化您的硬幣，然後鑄造 2 枚各 1 盎司的新硬幣。

Bitcoin 以類似的方式運作。讓我們假設 Alice 有`10,000 Sats` 的 UTXO 並希望購買`4,000 Sats` 的法棍。Alice 將以 1 個 滿 滿 滿 滿 10,000 Sats` 的 UTXO 作為輸入（她將全額消耗），以 2 個 滿 滿 4,000 Sats` 和 滿 6,000 Sats` 的 UTXO 作為輸出進行交易。4,000 Sats` 的 UTXO 將被送到麵包師傅那裡作為法棍的付款，而 6,000 Sats` 的 UTXO 將以零錢的形式返回 Alice。這個 UTXO 會回到交易的原始發行者，在 Bitcoin 行話中稱為 "Exchange"。

![BTC204](assets/fr/013.webp)

現在讓我們想像一下，Alice 並沒有一支 `10,000 Sats` 的 UTXO，而是有兩支每支 `3,000 Sats` 的 UTXO。在這種情況下，任何一個 UTXO 都不足以設定魔杖的 `4,000 Sats`。因此 Alice 必須同時使用 2 個 淨值為 `3,000 Sats` 的 UTXO 作為交易的輸入。如此一來，輸入的總金額將達到 `6,000 Sats`，使她能夠滿足支付給麵包師的 `4,000 Sats`。這種將數個 UTXO 組合起來作為交易投入的方法通常被稱為 「合併」。

![BTC204](assets/fr/014.webp)

### 交易費用

直覺上，人們可能會認為交易成本也代表交易的產出。但實際情況並非如此。交易成本代表總投入與總輸出之間的差額。這意味著，在使用部分投入的價值來支付交易中的預期產出之後，仍有一定的投入總額未被使用。這筆餘額就是交易成本。

```plaintext
Frais = total inputs - total outputs
```

讓我們以 Alice 為例，她的 UTXO 為 `10,000 Sats`，想要以 `4,000 Sats` 的價格購買法棍。Alice 以她的 UTXO `10,000 Sats` 作為輸入來建立一個交易。然後，她會產生 `4,000 Sats` 的輸出，讓麵包師傅支付長棍麵包的費用。為了鼓勵礦工將她的交易整合到區塊中，Alice 分配了 `200 Sats` 的費用。接著，她又創造了第二筆輸出，Exchange，這筆輸出將返還給她，金額為 `5,800 Sats`。

![BTC204](assets/fr/015.webp)

運用費用公式，我們可以看到確實有 `200 Sats` 剩給未成年人：

```plaintext
Frais = total inputs - total outputs
Frais = 10 000 - (4 000 + 5 800)
Frais = 10 000 - 9 800
Frais = 200
```

當 Miner 成功驗證一個區塊時，他就有權透過所謂的「coinbase」交易，為其區塊中包含的所有交易收取這些費用。

### 在 Bitcoin 上建立 UTXOs

如果您仔細閱讀了前面的段落，現在就會知道，UTXO 只能通過消耗其他現有的 UTXO 來創建。如此一來，Bitcoin 幣就形成了一個連續的鏈。然而，您可能想知道這條鏈中的第一個 UTXOs 是如何產生的。這就產生了一個類似於雞和蛋的問題：這些原始的 UTXO 從何而來？

答案就在**交易代幣庫**。

Cooinbase 是一種特定類型的 Bitcoin 交易，每個區塊都是唯一的，而且永遠是其中的第一個。它允許找到有效 Proof of Work 的 Miner 收到他的 Block reward。此獎勵由兩個 Elements 組成： **區塊授予**和**交易費**，在上一節討論過。

Coinbase Transaction 的獨特之處在於，它是唯一一種能夠無中生有地創造比特幣的裝置，不需要消耗輸入到 generate 的輸出。這些新創造的比特幣，我們可以稱之為「原始的 UTXOs」。

![BTC204](assets/fr/016.webp)

區塊資助比特幣是按照共識規則中預先設定的發行時間表，從零開始創建的新 BTC。區塊補助每 210,000 個區塊，也就是大約每四年減半一次，這個過程稱為 "Halving"。最初，每次補助會創造 50 個比特幣，但這個數量已逐漸減少；目前，每個區塊補助 3.125 個比特幣。

至於交易費用，雖然它們也代表新創建的 BTC，但不得超過區塊中所有交易的總投入和總輸出之差。我們之前看到，這些費用代表未用於交易輸出的那部分輸入。技術上來說，這部分會在交易過程中「遺失」，而 Miner 有權以一個或多個新 UTXO 的形式重新創造這部分價值。這是交易發行者與 Miner 之間的價值轉移，Miner 將其加入 Blockchain。

**> Coinbase Transaction 產生的比特幣有 100 個區塊的成熟期，在此期間，Miner 不能使用這些比特幣。此規則的設計是為了避免因使用新產生的比特幣而產生的複雜問題，因為這些新產生的比特幣可能會在之後被淘汰。

### UTXO 模型的影響

首先，UTXO 模式直接影響 Bitcoin 的交易費用。由於每個區塊的容量是有限的，因此礦工會傾向於那些提供與其在區塊中所佔空間相關的最佳費用的交易。事實上，交易的輸入和輸出中包含的 UTXOs 越多，它就越重，因此需要更高的費用。這也是我們經常嘗試減少投資組合中 UTXO 數量的原因之一，這也會影響保密性，我們會在本課程的第三部分詳細討論這個主題。

其次，如前幾節所述，Bitcoin 幣本質上是一串 UTXO。因此，每筆交易都會在過去的 UTXO 和未來的 UTXO 之間建立連結。因此，UTXOs 可以明確地跟隨比特幣從創造到目前支出的路徑。這種透明度可以從正面來看，因為它可以讓每個使用者確定收到的比特幣的真實性。然而，Blockchain 分析也是基於這種可追蹤性和可審計性的原則，這種做法旨在損害您的機密性。我們將在課程的第二部分深入探討這種做法。

## Bitcoin 的隱私模式

<chapterId>769d8963-3ed5-4094-b21d-9203c7d9e465</chapterId>

### 金錢：真實、誠信和雙重花費

貨幣的功能之一就是解決需求雙重重合的問題。在一個以物易物的系統中，要完成一個 Exchange 的交易，不僅需要找到一個人送出與我的需求相對應的物品，同時也要提供他一個等值的物品，以滿足他自己的需求。取得這種平衡是一件複雜的事情。

![BTC204](assets/fr/017.webp)

這就是為什麼我們使用金錢來移動空間和時間中的價值。

![BTC204](assets/fr/018.webp)

為了讓硬幣解決這個問題，提供商品或服務的一方必須確信自己有能力在日後花費這筆錢。因此，任何希望接受硬幣（無論是數位硬幣還是實物硬幣）的理性個體，都會確保它符合兩項基本標準：


- 作品必須具有完整性和真實性 ;**
- 且不得雙重花費。

如果您使用的是實體貨幣，這是第一個最難確定的特徵。在不同的歷史時期，金屬錢幣的完整性經常受到修剪或穿孔等做法的影響。例如，在古羅馬，公民通常的做法是刮掉金幣的邊緣，以收集一點貴金屬，同時保存金幣以備日後交易之用。硬幣的內在價值因此而降低，但其面值卻維持不變。這也是後來硬幣邊緣出現凹槽的原因之一。

真偽也是實體貨幣媒介難以驗證的特徵。現今打擊偽造貨幣的技術越來越複雜，迫使零售商投資成本高昂的驗證系統。

另一方面，由於其本質，雙重消費對實體貨幣來說並不是問題。如果我給你一張 10 歐元的鈔票，它就不可撤銷地從我的手中離開，並進入你的手中。簡言之，我將無法再次使用這張 10 歐元的鈔票。

![BTC204](assets/fr/019.webp)

對於數位貨幣而言，難度則有所不同。確保硬幣的真實性和完整性通常比較簡單。正如我們在上一節所看到的，Bitcoin 的 UTXO 模型使得追溯一個硬幣的來源成為可能，從而驗證它確實是由符合共識規則的 Miner 所創造的。

另一方面，確保沒有 Double-spending 則比較複雜，因為所有數位商品的本質都是資訊。與實體商品不同，資訊在交換時不會被分割，而是透過相乘的方式散播。舉例來說，如果我用電子郵件寄給你一份文件，它就會被複製。你無法確定我是否已經刪除原始文件。

![BTC204](assets/fr/020.webp)

### 防止雙重花費 Bitcoin

要避免這種數位資產重複的唯一方法，就是要知道系統上所有的交易所。這樣，我們就可以知道誰擁有什麼，並根據進行的交易更新每個人的持有量。舉例來說，銀行系統中的經文錢就是這樣。當您使用信用卡向商家支付 10 歐元時，銀行會記錄 Exchange 並更新帳簿。

![BTC204](assets/fr/021.webp)

在 Bitcoin 上，Double-spending 以相同的方式防止。我們尋求確認是否有交易已經花掉了相關的硬幣。如果硬幣從未被使用過，那麼我們就可以確定不會發生雙重花費的情況。Satoshi 中本在白皮書中用著名的短語描述了這一原則：

** 確認沒有交易的唯一方法是注意所有交易

但與銀行模式不同的是，我們不希望必須信任 Bitcoin 上的中央實體。因此，所有使用者都需要能夠確認這種沒有雙重花費的情況，而不需要仰賴第三方。所以每個人都需要瞭解所有 Bitcoin 交易。這就是 Bitcoin 交易在所有網路節點上公開廣播，並在 Blockchain 上以明文記錄的原因。

正是這種資訊的公開傳播，使得 Bitcoin 的隱私權保護變得複雜。在傳統的銀行系統中，理論上只有金融機構知道所進行的交易。而在 Bitcoin 中，所有使用者都會透過各自的節點得知所有交易。

### 保密模式：銀行系統 vs. Bitcoin

在傳統系統中，您的銀行帳戶與您的身份相關聯。銀行家能夠知道哪個銀行帳戶屬於哪位客戶，以及與之相關的交易。但是，銀行和公共領域之間的資訊流被隔絕了。換句話說，不可能知道屬於另一個人的銀行帳戶的餘額和交易。只有銀行才能獲得這些資訊。

![BTC204](assets/fr/022.webp)

舉例來說，您的銀行知道您每天早上從當地的麵包店購買法棍，但您的鄰居卻不知道這項交易。如此一來，資訊的流動對於相關的各方，尤其是銀行，是可以取得的，但對於外人卻是無法取得的。

![BTC204](assets/fr/023.webp)

由於我們在上一節所看到的交易公開散播的限制，Bitcoin 的保密模型無法遵循銀行系統的模型。在 Bitcoin 的情況下，由於交易與公共領域之間的資訊流通無法斷絕，因此**的保密模型依賴於使用者身分與交易**本身的分離。

![BTC204](assets/fr/024.webp)

例如，如果您從麵包店買了一根法棍，並以 BTC 付款，您的鄰居擁有自己的完整節點，他可以看到您的交易完成，就像他可以看到系統中的所有其他交易一樣。但是，如果遵守保密原則，他應該無法將此特定交易與您的身份聯繫起來。

![BTC204](assets/fr/025.webp)

但由於 Bitcoin 交易都是公開的，因此仍有可能在這些交易之間建立關聯，從而推斷出相關各方的資訊。這項活動本身甚至構成一門專業，稱為「Blockchain 分析」。在課程的下一部分，我邀請您探索 Blockchain 分析的基本原理，讓您了解您的比特幣是如何被追蹤的，並更好地防禦它們。

# 瞭解並防止連鎖分析

<partId>4739371e-9fef-45b0-bcaa-b7a4df6b4470</partId>

## 什麼是 Bitcoin 連鎖分析？

<chapterId>7d198ba6-4af2-4f24-86cb-3c79cb25627e</chapterId>

### 定義與操作

Blockchain 分析是追蹤比特幣在 Blockchain 上流向的做法。一般來說，鏈分析是基於觀察先前交易樣本的特徵。然後在我們想要分析的交易中找出這些相同的特徵，並從中推斷出合理的解釋。這種以實際方法來尋找足夠好的解決方案的問題解決方法，稱為「啟發式」。

通俗來說，連鎖分析有三個主要階段：

1. **Observing the Blockchain ;**

2. **識別已知特徵；**

3. **假設的演繹 **

![BTC204](assets/fr/026.webp)

任何人都可以進行 Blockchain 分析。您只需要透過完整的節點存取 Blockchain 的公開資訊，就可以觀察交易動向並提出假設。也有一些免費的工具可以促進這種分析，例如 [OXT.me](https://oxt.me/)，我們會在本節的最後兩章詳細探討。然而，保密性的主要風險來自專門從事字串分析的公司。這些公司已將 Blockchain 分析提升至工業規模，並將服務出售給金融機構和政府。在這些公司中，Chainalysis 肯定是最知名的。

### 連鎖分析目標

Blockchain 分析的目的之一是將 Bitcoin 上的各種活動集中在一起，以確定進行這些活動的使用者的唯一性。之後，就可以嘗試將此活動群組與真實身分連結。

![BTC204](assets/fr/027.webp)

回想上一章。我解釋了為什麼 Bitcoin 的隱私模型最初是基於使用者身分與交易的分離。因此，我們很容易會認為 Blockchain 的分析毫無用處，因為即使我們能夠彙總網路上的活動，也無法將這些活動與真正的身分聯繫起來。

理論上，這個說法是正確的。在本課程的第一部分，我們看到密碼金鑰對是用來建立 UTXO 的條件。本質上，這些金鑰對不會洩露其持有者的身份資訊。因此，即使我們能夠將與不同配對密碼匙相關的活動歸類在一起，也無法得知這些活動背後的實體。

![BTC204](assets/fr/028.webp)

然而，實際情況要複雜得多。有許多行為可以將真實身份與上鏈活動聯繫起來。在分析中，這稱為入口點，而入口點有很多。

最常見的是 KYC (*Know Your Customer*)。如果您從一個受監管的平台提取您的比特幣到您的一個個人接收地址，那麼有些人就能夠將您的身份與該 Address 連結起來。更廣義地說，進入點可以是您的真實生活和 Bitcoin 交易之間的任何形式的互動。例如，如果您在社交網絡上發佈了一個接收的 Address，這就可以成為分析的切入點。如果您用比特幣向您的麵包師傅付款，他就可以將您的臉（您身份的一部分）與 Bitcoin Address 聯繫起來。

使用 Bitcoin 時，這些入口點幾乎是無法避免的。雖然我們可能會嘗試限制它們的範圍，但它們始終存在。這就是為什麼結合旨在保護您隱私的方法至關重要。儘管將您的真實身份與交易分開是一種有趣的方法，但在今天仍然不足夠。事實上，如果您所有的上鏈活動都可以集中在一起，那麼即使是最小的切入點，也很可能會破壞您建立的單一保密性 Layer。

![BTC204](assets/fr/029.webp)

### 防禦連鎖分析

因此，我們在使用 Bitcoin 時，也需要能夠應付 Blockchain 的分析。如此一來，我們就可以將我們活動的聚集程度降到最低，並限制切入點對我們隱私權的影響。

![BTC204](assets/fr/030.webp)

有什麼比了解 Blockchain 分析中使用的方法更好的方法來反駁 Blockchain 分析呢？如果您想知道如何在 Bitcoin 上改善您的隱私，您需要瞭解這些方法。這會讓您更好地掌握 CoinJoin 或 PayJoin 等技術（我們會在課程的最後部分瞭解這些技術），並減少您可能犯下的錯誤。

https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/tutorials/privacy/on-chain/payjoin-848b6a23-deb2-4c5f-a27e-93e2f842140f
在這方面，我們可以用密碼學和密碼分析來做類比。一個好的密碼學家首先是一個好的密碼分析師。要設計出新的加密演算法，就必須知道它會面對哪些攻擊，同時也要研究之前的演算法為什麼會被破解。同樣的原則也適用於 Bitcoin 隱私權。了解 Blockchain 分析方法是防禦這些方法的關鍵。這就是為什麼我在本訓練課程中加入一整篇 on chain 分析的原因。

### 連鎖分析方法

重要的是要了解弦分析不是一門精確的科學。它依賴於從先前觀察或邏輯詮釋所衍生出來的啟發式方法。這些規則允許我們得到相當可靠的結果，但絕非絕對精確。換句話說，**弦分析所得出的結論總是有一定的可能性。舉例來說，我們或許能夠以不同程度的確切性估計兩個位址屬於同一個實體，但總是無法完全確定。

連鎖分析的重點正是在於聚合各種啟發式方法，將出錯的風險降到最低。在某種程度上，這是一種證據的累積，讓我們更接近現實。

這些著名的啟發式方法可以分成不同的類別，我們將在下面詳細說明：


- 交易模式 ;**
- 交易內部啟發式方法 ;**
- 交易外部的啟發式 **

### Satoshi 中本與連鎖分析

前兩個鏈分析啟發式方法是由 Satoshi Nakamoto 自己發現的。他在 Bitcoin 的白皮書第 10 部分中談到了它們。它們是 ：


- cIOH (*Common Input Ownership Heuristic*)；
- 和 Address 的再利用。

![BTC204](assets/fr/031.webp)

資料來源：S. Nakamoto，「Bitcoin：點對點電子現金系統」，https://Bitcoin.org/Bitcoin.pdf，2009 年。

我們會在接下來的章節中看到它們是什麼，但有趣的是，這兩種啟發式方法至今仍在連鎖分析中佔有優勢。

## 交易模式

<chapterId>d365a101-2d37-46a5-bfb9-3c51e37bf96b</chapterId>

交易模式只是典型交易的整體模型或結構，可以在 Blockchain 上找到，其可能的詮釋也是已知的。研究模式時，我們會專注於單一交易，並從高層次進行分析。

換句話說，我們只會觀察輸入中的 UTXO 數量和輸出中的 UTXO 數量，而不會糾纏於交易的更多具體細節或環境。根據觀察到的模式，我們可以解讀交易的本質。接著，我們會尋找其結構的特徵，並推演出解釋。

![BTC204](assets/fr/032.webp)

在本節中，我們將一併瞭解在連鎖分析中遇到的主要交易模式，對於每一種模式，我都會給您這個結構可能的詮釋，以及一個具體的範例。

### 單次出貨（或單次付款）

讓我們從一個很常見的模式開始，因為這是大多數 Bitcoin 付款上出現的模式。簡單付款模式的特點是消耗一個或多個 UTXOs 作為輸入，生產 2 個 UTXOs 作為輸出。因此，這個模式是這樣的

![BTC204](assets/fr/033.webp)

當我們在 Blockchain 上發現這個交易結構時，我們已經可以做出解釋。顧名思義，這個模型表示我們正在進行傳送或付款交易。使用者在輸入時消耗了自己的 UTXO，在輸出時滿足了付款 UTXO 和 Exchange UTXO（錢退回給同一使用者）。

因此，我們知道被觀察的使用者很可能已不再擁有兩個輸出 UTXO 之一（付款 UTXO），但仍擁有另一個 UTXO（Exchange UTXO）。

目前，我們無法指定哪個輸出代表哪個 UTXO，因為這不是模式研究的目的。我們將透過以下幾節所研究的啟發式方法來達到目的。在現階段，我們的目標只限於識別有關交易的性質，在本例中就是簡單的傳送。

例如，以下是採用簡單傳送模式的 Bitcoin 交易：

```plaintext
b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769
```

![BTC204](assets/fr/034.webp)

Source : [Mempool.space](https://Mempool.space/fr/tx/b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769)

看完這第一個例子之後，您應該對研究「交易模式」的意義有了更深的了解。我們研究交易時，只會著眼於其結構，而不會考慮其環境或交易的具體細節。在這第一步，我們只看大局。

現在您瞭解了什麼是模式，接下來讓我們看看其他現有的模式。

### 清掃

第二個模型的特點是以單一 UTXO 的消耗量作為輸入，並以單一 UTXO 的生產量作為輸出。

![BTC204](assets/fr/035.webp)

這個模型的詮釋是，我們處在一個自我轉移的場合。用戶把他的比特幣轉給了自己，轉給了屬於他的另一個 Address。由於交易中沒有 Exchange，我們極不可能是在進行付款。事實上，當進行付款時，付款人幾乎不可能擁有與賣方所需金額完全相對應的 UTXO，再加上交易費用。一般而言，付款方因此有義務產生一個 Exchange 輸出。

然後，我們知道被觀察的使用者很可能仍持有這個 UTXO。在連鎖分析的情況下，如果我們知道交易中作為輸入的 UTXO 屬於 Alice，我們就可以假設作為輸出的 UTXO 也屬於她。稍後有趣的是找到交易內部的啟發式方法來強化這個假設（我們將在第 3.3 章研究這些啟發式方法）。

例如，以下是採用掃描模式的 Bitcoin 交易：

```plaintext
35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d
```

![BTC204](assets/fr/036.webp)

Source : [Mempool.space](https://Mempool.space/fr/tx/35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d)

不過，請小心，這類型的模式也可能揭示出是向加密貨幣 Exchange 平台的帳戶自轉。透過研究已知的地址和交易的背景，我們才能知道這是刷到自我保管的 Wallet 或是提款到平台。事實上，Exchange 平台的地址通常很容易辨認。

讓我們再以 Alice 為例：如果掃描到一個平台已知的 Address（例如 Binance），這可能意味著比特幣已經從 Alice 直接擁有的地方轉移出去了，很可能是為了出售或存放在這個平台上。另一方面，如果目的地 Address 不詳，我們有理由假設這只是另一個仍屬於 Alice 的 Wallet。但這類研究更屬於啟發式而非模式。

### 整合

此模型的特點是在輸入端消耗數個 UTXO，而在輸出端產生單個 UTXO。

![BTC204](assets/fr/037.webp)

對這種模式的解讀是，我們正處於合併的時期。這是 Bitcoin 使用者常見的做法，目的在於合併數個 UTXO，以預見交易費用可能增加。在費用較低的期間執行此操作，可以節省未來的費用。我們會在第 4.3 章詳細討論這種做法。

我們可以推斷，這個交易模型背後的使用者很可能在輸入時擁有所有的 UTXOs，而在輸出時仍然擁有 UTXO。所以這可能是自動轉移。

與橫掃一樣，這類型的模式也可以揭示出向 Exchange 平台帳戶的自我轉移。研究已知的地址和交易的背景，才能讓我們知道這是整合到自我保管的投資組合，還是提款到平台。

舉例來說，這裡有一筆 Bitcoin 交易，採用了整合模式：

```plaintext
77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94
```

![BTC204](assets/fr/038.webp)

Source : [Mempool.space](https://Mempool.space/fr/tx/77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94)

在連鎖分析中，這個模型可以揭示大量的資訊。舉例來說，如果我們知道其中一項輸入是屬於 Alice 的，我們就可以假設所有其他輸入和這項交易的輸出也是屬於她的。如此一來，我們就可以沿著之前的交易鏈往上追溯，以發現和分析可能與 Alice 有關的其他交易。

![BTC204](assets/fr/039.webp)

### 成組支出

此模型的特點是消耗少數 UTXO 作為輸入（通常只有一個），並生產許多 UTXO 作為輸出。

![BTC204](assets/fr/040.webp)

這個模型的詮釋是，我們正處於群組支出的狀態。這種做法很可能揭示了非常大的經濟活動，例如 Exchange 平台。群組化支出能讓這些實體在單一交易中合併支出，從而節省成本。

我們可以從這個模型推斷，輸入中的 UTXO 來自一家經濟活動水平很高的公司，而輸出中的 UTXOs 將會分散。很多會屬於從平台上提取比特幣的公司客戶。其他的可能會流向合作公司。最後，一定會有一個或多個交易所回到發行公司。

例如，這裡有一筆 Bitcoin 交易，採用了捆綁式花費模式（據推測，這是由 Bybit 平台發行的交易）：

```plaintext
8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43
```

![BTC204](assets/fr/041.webp)

Source : [Mempool.space](https://Mempool.space/fr/tx/8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43)

### 特定於通訊協定的交易

在交易模式中，我們也可以識別出那些揭示出使用特定協定的交易模式。例如，Whirlpool 幣合（在第五部分討論）會有一個容易識別的結構，以區別於其他更常規的交易。

![BTC204](assets/fr/042.webp)

分析此圖案顯示，我們很可能正處於合作交易的狀態。也有可能觀察到一個 CoinJoin。如果後一種假設被證實是正確的，那麼退出的次數可以讓我們粗略估計 CoinJoin 的參與者數目。

例如，這裡有一個 Bitcoin 交易，採用 CoinJoin 協同交易模式：

```plaintext
00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea
```

![BTC204](assets/fr/043.webp)

Source : [Mempool.space](https://Mempool.space/fr/tx/00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea)

有許多其他的通訊協定有其特定的結構。例如，有 Wabisabi 交易、Stamps 交易和 Runes 交易。

多虧了這些交易模式，我們已經可以詮釋特定交易的一定資訊。但是，交易結構並非分析的唯一資訊來源。我們也可以研究其細節。這些內部細節我喜歡稱之為「內部啟發式」，我們會在下一章研究它們。

## 內部啟發式

<chapterId>c54b5abe-872f-40f4-a0d0-c59faff228ba</chapterId>

內部啟發式 (internal heuristic) 是我們在交易本身中找出的特定特徵，不需要檢視其環境，就能讓我們做出推論。模式著重於高層次的交易整體結構，而內部啟發式則不同，它是以可擷取的資料集為基礎。這包括


- 各種 UTXO 的進出金額；
- 與腳本有關的一切：接收地址、版本、鎖定時間...

一般而言，這類啟發式方法可讓我們識別特定交易中的 Exchange。如此一來，我們就可以在幾個不同的交易中持續追蹤一個實體。事實上，如果我們識別出屬於我們想要追蹤的使用者的 UTXO，那麼在他進行交易時，就必須確定哪些輸出已經轉移給其他使用者，哪些輸出代表 Exchange，因此 Exchange 仍由他持有。

![BTC204](assets/fr/044.webp)

讓我再次提醒您，這些啟發式方法並非絕對精確。單獨來看，它們只能讓我們識別可能發生的情況。多種啟發式方法的累積有助於減少不確定性，但卻無法完全消除不確定性。

### 內部相似性

這個啟發式方法是研究同一筆交易的輸入和輸出之間的相似性。如果在輸入和交易的其中一個輸出上觀察到相同的特徵，那麼這個輸出很可能就是 Exchange。

最明顯的特點是在同一筆交易中重複使用接收的 Address。

![BTC204](assets/fr/045.webp)

這個啟發式的方法幾乎沒有讓人懷疑的空間。除非他的私密金鑰被駭客入侵，否則相同的接收 Address 必然會揭露單一使用者的活動。結果的解釋是交易 Exchange 是以相同的 Address 作為輸入的輸出。我們就可以從這個 Exchange 繼續追蹤這個人。

舉例來說，這裡有一筆交易，這個啟發式的方法大概可以用在這筆交易上：

```plaintext
54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0
```

![BTC204](assets/fr/046.webp)

Source : [Mempool.space](https://Mempool.space/tx/54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0)

輸入與輸出之間的這些相似性並不止於 Address 重複使用。使用腳本的任何相似性都可以用來套用啟發式。例如，有時候我們可以觀察到輸入與其中一個交易輸出之間有相同的版本。

![BTC204](assets/fr/047.webp)

在這個圖表上，我們可以看到輸入 n° 0 解鎖了 P2WPKH 腳本 (SegWit V0 以 `bc1q` 開頭)。輸出 n° 0 使用相同類型的腳本。另一方面，輸出 n° 1 使用 P2TR 腳本 (SegWit V1，以 `bc1p` 開頭)。這個特徵的解釋是，與輸入具有相同版本的 Address 很可能就是 Exchange Address。因此，它會永遠屬於同一個使用者。

這裡有一筆交易，可能可以應用這個啟發式方法：

```plaintext
db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578
```

![BTC204](assets/fr/048.webp)

Source : [Mempool.space](https://Mempool.space/tx/db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578)

關於後者，我們可以看到輸入編號 0 和輸出編號 1 使用 P2WPKH 指令碼 (SegWit V0)，而輸出編號 0 則使用不同的 P2PKH 指令碼 (Legacy)。

在 2010 年代早期，由於可用的指令碼種類有限，這種以指令碼版本為基礎的啟發式方法相對地沒有什麼幫助。然而，隨著時間的推移和 Bitcoin 的連續更新，腳本類型的多樣性也日益增加。因此，這個啟發式方法變得越來越重要，因為隨著腳本類型的擴大，使用者會分成較小的群組，因此增加了應用這個內部版本重複使用啟發式方法的機會。因此，僅從保密性的角度來看，建議您選擇最常見的腳本類型。例如，在我寫這些行文時，Taproot 腳本 (`bc1p`)的使用頻率比 SegWit V0 腳本 (`bc1q`)低。雖然前者在某些特定情況下具有經濟和保密優勢，但對於較傳統的單一簽章用途而言，基於保密理由，在新標準獲得更廣泛採用之前，堅持使用較舊的標準可能是合理的。

### 整數付款

另一個可以幫助我們識別 Exchange 的內部啟發式是圓數啟發式。一般而言，面對簡單的付款模式 (1 個輸入和 2 個輸出)，如果其中一個輸出花費的金額是整數，那麼這代表付款。

![BTC204](assets/fr/049.webp)

根據排除法，如果一個輸出代表付款，另一個則代表 Exchange。因此可以解釋為輸入使用者很可能始終擁有被識別為 Exchange 的輸出。

應該強調的是，這個啟發式的方法並不總是適用，因為大多數的付款仍是以信託會計單位進行。事實上，當法國的零售商接受 Bitcoin 時，通常不會以 Sats 顯示穩定的價格。相反，他會選擇在歐元價格和比特幣支付金額之間進行轉換。因此，交易結束時不應該有整數。

儘管如此，分析師可以嘗試考慮交易在網路中廣播時的 Exchange 費率來進行轉換。讓我們舉一個交易的例子，輸入為 `97,552 Sats`，有兩個輸出，一個為 `31,085 Sats`，另一個為 `64,152 Sats`。乍看之下，此交易似乎不涉及整數金額。但是，通過應用交易時 64,339 歐元的 Exchange 匯率，我們得到了如下的歐元轉換：


- 投入為 62.76 歐元；
- 20 歐元的產出；
- 41.27 歐元的產出。

一旦轉換成法定貨幣，此交易就可以用來套用整數付款啟發式。20 歐元的輸出可能流向商家，或至少改變了 Ownership。根據推論，41.27 歐元的輸出可能仍由原始使用者持有。

![BTC204](assets/fr/050.webp)

如果有一天，Bitcoin 成為我們交流中的首選計算單位，這個啟發式的分析可能會變得更有用。

舉例來說，這裡有一筆交易，這個啟發式的方法大概可以用在這筆交易上：

```plaintext
2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a
```

![BTC204](assets/fr/051.webp)

Source : [Mempool.space](https://Mempool.space/tx/2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a)

### 最大輸出

當我們在簡單的付款模型上找出 2 個交易輸出之間有足夠大的差距時，我們可以估計最大的輸出可能是外國的 Exchange。

![BTC204](assets/fr/052.webp)

這個最大輸出的啟發式肯定是最不精確的。就其本身而言，它相當薄弱。不過，這個特徵可以與其他啟發式結合，以減少我們詮釋的不確定性。

舉例來說，如果我們要看的交易有整筆付款和較大額付款，同時應用整筆付款啟發式和較大額付款啟發式就能降低我們的不確定性。

舉例來說，這裡有一筆交易，這個啟發式的方法大概可以用在這筆交易上：

```plaintext
b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf
```

![BTC204](assets/fr/053.webp)

Source : [Mempool.space](https://Mempool.space/tx/b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf)

## 外部啟發式

<chapterId>4a170e3b-200d-431a-8285-18a23ff617ba</chapterId>

研究外部啟發式方法意味著分析某些 Elements 的相似性、模式和特徵，這些都不是交易本身所特有的。換句話說，以前我們只限於利用內部啟發式分析交易內在的 Elements，而現在由於有了外部啟發式分析，我們的分析領域擴大到包括交易的環境。

### Address 再使用

這是比特幣玩家最著名的啟發式方法之一。Address 重複使用使得在不同的交易和不同的 UTXOs 之間建立聯繫成為可能。當一個接收 Bitcoin 的 Address 被多次使用時，它就會發生。

因此，可以利用 Address 在同一筆交易中的重複使用，作為內部啟發式來識別 Exchange（正如我們在前一章所看到的）。但是，Address 重複使用也可以用來作為外部啟發式，識別幾個交易背後的實體的唯一性。

重複使用 Address 的詮釋是該 Address 上封鎖的所有 UTXO 均屬於 (或曾經屬於) 同一個實體。這種啟發式方法幾乎沒有留下不確定性的空間。一經識別，所得的詮釋很可能與現實相符。因此，它可以將不同的 onchain 活動歸類。

![BTC204](assets/fr/054.webp)

正如在第三部分的介紹中所解釋的，這個啟發式是由 Satoshi Nakamoto 自己發現的。在白皮書中，他提到了一個幫助用戶避免產生這種情況的解決方案，那就是簡單地為每筆新交易使用空白的 Address：

"_作為額外的防火牆，每筆交易都可以使用新的金鑰對，以保持它們與共同擁有者無關。

![BTC204](assets/fr/055.webp)

來源：S：S. Nakamoto，「Bitcoin：點對點電子現金系統」，https://Bitcoin.org/Bitcoin.pdf，2009 年。

例如，這裡有一個 Address 在幾個交易中被重複使用：

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/fr/056.webp)

來源 : [Mempool.space](https://Mempool.space/Address/bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0)

### 文字相似性和 Wallet 印記

除了 Address 重複使用外，還有許多其他啟發式方法可讓您將行動連結至相同的組合或 Address 群組。

首先，分析師可以尋找腳本使用的相似性。例如，某些少數腳本 (如 Multisig) 可能比 SegWit V0 腳本更容易被發現。我們躲藏的群體越大，就越難被發現。這就是為什麼在良好的 CoinJoin 協定上，所有參與者都使用完全相同類型的腳本的原因之一。

一般而言，分析師也可以專注於投資組合的特徵指紋。這些都是特定用途的過程，可以加以識別，以便利用它們作為追蹤的啟發式方法。換句話說，如果我們觀察到歸屬於被追蹤實體的交易上有相同內部特徵的累積，我們就可以嘗試在其他交易上找出這些相同的特徵。

舉例來說，我們就可以識別出被追蹤的使用者有系統地將變更傳送至 P2TR 位址 (`bc1p...`)。如果這個過程重複發生，我們就可以將它作為啟發式來進行其餘的分析。我們也可以使用其他指紋，例如 UTXO 的順序、變更在輸出中的位置、RBF (Replace-by-fee) 訊號，或是版本號碼、`nSequence`欄位和`nLockTime`欄位。

![BTC204](assets/fr/057.webp)

正如[@LaurentMT](https://twitter.com/LaurentMT)在[Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji)（法語播客）中指出的，隨著時間的推移，投資組合指紋在連鎖分析中的用處正在顯著增加。事實上，腳本類型的不斷增加，以及投資組合軟體對這些新功能日益漸進式的部署，都突顯了這些差異。在某些情況下，甚至有可能識別出被追蹤實體所使用的確切軟體。因此，我們必須了解，投資組合足跡的研究對於近期的交易尤其重要，而非 2010 年代初期開始的交易。

總而言之，足跡可以是 Wallet 自動執行或使用者手動執行的任何特定作法，我們可以在其他交易上找到這些足跡，以幫助我們進行分析。

### 通用輸入 Ownership 啟發式 (CIOH)

共同輸入 Ownership 啟發式 (CIOH) 是一種啟發式，指出當交易有多個輸入時，這些輸入都可能來自單一實體。因此，它們的 Ownership 是共通的。

![BTC204](assets/fr/058.webp)

要應用 CIOH，我們首先要觀察一個有數個輸入的交易。這可能是 2 個輸入或 30 個輸入。一旦找出這個特徵，我們就會檢查交易是否符合已知的交易模式。例如，如果有 5 個金額大致相同的輸入和 5 個金額完全相同的輸出，我們就會知道這是 CoinJoin 的結構。我們將無法應用 CIOH。

![BTC204](assets/fr/059.webp)

另一方面，如果交易不符合任何已知的協同交易模型，那麼我們可以解釋為所有輸入都可能來自同一個實體。這對於擴展已知的叢集或繼續追蹤非常有用。

![BTC204](assets/fr/060.webp)

CIOH 是由 Satoshi Nakamoto 發現的。他在白皮書的第 10 部分談到了這一點：

"_[...]連結對於多筆交易是不可避免的，因為多筆交易必然會揭露它們的記項是由同一個所有人所持有。風險是，如果鑰匙的所有者被揭露，連結可能會揭露屬於同一所有者的其他交易。_"

![BTC204](assets/fr/061.webp)

特別令人著迷的是，Satoshi 中本，甚至在 Bitcoin 正式推出之前，就已經找出使用者的兩個主要隱私漏洞，也就是 CIOH 和 Address 重複使用。這樣的先見之明相當了不起，因為這兩種啟發式方法即使在今天，仍然是 Blockchain 分析中最有用的。

舉例來說，我們可以在以下交易中應用 CIOH：

```plaintext
20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712
```

![BTC204](assets/fr/062.webp)

Source : [Mempool.space](https://Mempool.space/tx/20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712)

### off-chain 數據

當然，鏈分析並不僅限於 onchain 資料。任何先前分析的資料或網際網路上可取得的資料也可用來精進分析。

舉例來說，如果我們觀察到追蹤到的交易有系統地從相同的 Bitcoin 節點廣播，並且我們能夠識別其 IP Address，我們就可能能夠識別來自同一個實體的其他交易，以及確定發行者的部分身分。儘管這種做法不容易實現，因為它需要操作許多節點，但一些專門從事 Blockchain 分析的公司可能會採用這種方法。

分析師也可以選擇依賴先前開放原始碼的分析，或依賴自己先前的分析。也許我們就能找到指向我們已經找出的地址群組的輸出。有時候，也可以依賴指向 Exchange 平台的輸出，因為這些公司的地址一般都是眾所周知的。

同樣地，您也可以用排除法來執行分析。舉例來說，如果在分析一個有兩個輸出的交易時，其中一個輸出與已知的 Address 叢集有關，但與我們正在追蹤的實體不同，那麼我們就可以解釋另一個輸出可能代表 Exchange。

頻道分析也包括稍為一般性的 OSINT (*Open Source Intelligence*) 元件，涉及網際網路搜尋。正因如此，我們建議不要直接在社交網路或網站上發佈地址，不論是否為假名。

![BTC204](assets/fr/063.webp)

### 時間模型

我們較少去想它，但某些人類行為是可以在鏈上識別的。或許在分析中最有用的就是您的睡眠模式！是的，當您睡覺時，您不會廣播 Bitcoin 交易。但您通常會在大致相同的時間睡覺。這就是為什麼在 Blockchain 分析中使用時間分析是很常見的做法。簡單來說，這就是統計特定實體的交易廣播到 Bitcoin 網路的時間。透過分析這些時間模式，我們可以推論出豐富的資訊。

首先，時間分析有時可以識別被追蹤實體的性質。如果我們觀察到交易在 24 小時內持續播送，那麼這就表示有高度的經濟活動。這些交易背後的實體很可能是一間公司，可能是國際性的，也可能有自動化的內部程序。

例如，[我在幾個月前](https://twitter.com/Loic_Pandul/status/1701127409712452072) 分析[錯誤分配了 19 個 bitcoins 費用的交易](https://Mempool.space/tx/d5392d474b4c436e1c9d1f4ff4be5f5f9bb0eb2e26b61d2781751474b7e870fd) 時，就發現了這種模式。簡單的時間分析讓我可以假設，我們是在和自動化服務打交道，因此很可能是在和一個大型實體（例如 Exchange 平台）打交道。

事實上，幾天後，透過 Paxos Exchange 平台發現這些資金屬於 PayPal。

相反地，如果我們可以看到時間模式相當分散在 16 個特定小時內，那麼我們就可以估計我們所處理的是個人使用者，或可能是當地公司，這取決於交換的數量。

除了觀察到的實體的性質之外，時間模式也可以透過時區告訴我們使用者的大概位置。如此一來，我們就可以與其他交易進行比對，並使用它們的時間戳作為額外的啟發式，加入我們的分析中。

舉例來說，在我之前提到的多重使用的 Address 上，我們可以看到交易，無論是進出都集中在 13 小時的間隔上。

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/fr/064.webp)

來源 : OXT.me

這個範圍可能對應歐洲、非洲或中東。因此，我們可以假設這些交易背後的使用者居住在這些地區。

從另一個角度來看，這種類型的時間分析也導致了 Satoshi Nakamoto 不是從日本，而是從美國運作的假設： [*The Time Zones of Satoshi Nakamoto*](https://medium.com/@insearchofsatoshi/the-time-zones-of-Satoshi-nakamotoo-aa40f035178f)

## 使用 Block explorer 進行實踐

<chapterId>6493cf2f-225c-405f-9375-c4304f1087ed</chapterId>

在最後一章，我們要將目前所學的概念付諸實踐。我會向您展示真實 Bitcoin 交易的範例，您必須提取我要求您提供的資訊。

理想情況下，若要執行這些練習，最好使用專業的連鎖分析工具。然而，自從 Samourai Wallet 的創造者被捕之後，唯一的免費分析工具 OXT.me 就不再可用了。因此，我們會選擇經典的 Block explorer 來進行這些練習。我推薦使用[Mempool.space](https://Mempool.space/)，因為它有許多功能和一系列的連鎖分析工具，但您也可以選擇其他的探索器，例如[Bitcoin Explorer](https://bitcoinexplorer.org/)。

首先，我會向您介紹練習。請使用您的 Block explorer 完成這些練習，並將答案寫在紙上。然後，在本章的最後，我會提供您答案，以便您檢查和修正您的結果。

*這些練習所選取的交易，純粹是以有點隨機的方式，根據其特性而選取的。本章僅用於教育和資訊目的。我想清楚說明，我既不支持也不鼓勵惡意使用這些工具。目的是教您如何保護自己免受字串分析的傷害，而不是進行分析以揭露他人的私人資訊。

### 練習 1

要分析的交易的識別碼 ：

```plaintext
3769d3b124e47ef4ffb5b52d11df64b0a3f0b82bb10fd6b98c0fd5111789bef7
```

這個交易模型的名稱是什麼？只檢視它的模型，也就是交易的結構，可以得出什麼合理的解釋？

### 練習二

要分析的交易的識別碼 ：

```plaintext
baa228f6859ca63e6b8eea24ffad7e871713749d693ebd85343859173b8d5c20
```

這個交易模型的名稱是什麼？只檢視它的模型，也就是交易的結構，可以得出什麼合理的解釋？

### 練習三

要分析的交易的識別碼 ：

```plaintext
3a9eb9ccc3517cc25d1860924c66109262a4b68f4ed2d847f079b084da0cd32b
```

此交易的模式是什麼？

使用交易的內部啟發式方法確定其模型後，Exchange 可能代表什麼輸出？

### 練習 4

要分析的交易的識別碼 ：

```plaintext
35f0b31c05503ebfdf7311df47f68a048e992e5cf4c97ec34aa2833cc0122a12
```

此交易的模式是什麼？

使用交易的內部啟發式方法確定其模型後，Exchange 可能代表什麼輸出？

### 練習五

讓我們想像一下 Loïc 在社交網路 Twitter 上發佈了他的一個 Bitcoin 接收地址：

![BTC204](assets/fr/065.webp)

```plaintext
bc1qja0hycrv7g9ww00jcqanhfpqmzx7luqalum3vu
```

根據這些資訊，並僅使用 ** Address 重複使用啟發式 **，哪些 Bitcoin 交易可以連結到 Loïc 的身分？

*很明顯，我不是這台接收器 Address 的真正擁有者，我也沒有把它發佈到社交網路。這是我隨手從 Blockchain* 拍攝的 Address

### 練習 6

在練習 5 之後，由於 Address 重複使用啟發式，您能夠找出 Loïc 似乎有參與的幾個 Bitcoin 交易。通常，在已識別的交易中，您應該會發現這個交易：

```plaintext
2d9575553c99578268ffba49a1b2adc3b85a29926728bd0280703a04d051eace
```

這筆交易是第一筆向 Loïc 的 Address 送出資金的交易。您認為 Loïc 透過這筆交易收到的 bitcoins 從何而來？

### 練習七

在練習 5 之後，由於 Address 重複使用啟發式，您已經可以找出 Loïc 似乎有參與的幾個 Bitcoin 交易。現在您要找出 Loïc 從何而來。根據找到的交易，執行時間分析，找出 Loïc 最可能使用的時區。從這個時區，確定 Loïc 似乎居住的地點 (國家、州/地區、城市...)。

![BTC204](assets/fr/066.webp)

### 練習八

以下是要研究的 Bitcoin 交易：

```plaintext
bb346dae645d09d32ed6eca1391d2ee97c57e11b4c31ae4325bcffdec40afd4f
```

單看這筆交易，我們可以解讀哪些資訊？

### 運動解決方案

***練習 1:***

此交易的模型是簡單付款模型。如果我們只研究它的結構，我們可以解釋一個輸出代表 Exchange，另一個輸出代表實際付款。因此，我們知道被觀察的使用者很可能不再擁有輸出的兩個 UTXO 之一（付款的 UTXO），但仍擁有另一個 UTXO（Exchange 的 UTXO）。

***練習二：***

此交易的模式為群組支出模式。這個模型很可能揭示了一個大規模的經濟活動，例如 Exchange 平台。我們可以推斷，輸入的 UTXO 來自一家經濟活動水平很高的公司，而輸出的 UTXO 將是分散的。有些會屬於公司客戶，他們將其比特幣提取到自我保管的錢包中。其他的可能會流向合作公司。最後，無疑會有一些 Exchange 會回到發行公司。

***練習三：***

此交易的模式是簡單付款。因此，我們可以對交易運用內部啟發式分析，嘗試找出 Exchange。

我個人發現至少有兩種內部啟發式方法支持相同的假設：


- 重複使用相同類型的腳本 ；
- 最大的輸出。

最明顯的啟發式就是重複使用相同類型的腳本。事實上，輸出 `0` 是一個 `P2SH`，可從其接收以 `3` 開頭的 Address 識別出來：

```plaintext
3Lcdauq6eqCWwQ3UzgNb4cu9bs88sz3mKD
```

而輸出 `1` 是 `P2WPKH`，可由其 Address `bc1q` 開頭識別：

```plaintext
bc1qya6sw6sta0mfr698n9jpd3j3nrkltdtwvelywa
```

用於此交易輸入的 UTXO 也使用 `P2WPKH`腳本：

```plaintext
bc1qyfuytw8pcvg5vx37kkgwjspg73rpt56l5mx89k
```

因此，我們可以假設輸出 `0` 對應於付款，而輸出 `1` 是交易 Exchange，這將意味著輸入使用者永遠擁有輸出 `1`。

為了支持或反駁這個假設，我們可以尋找其他啟發式的方法，來證實我們的想法，或是降低我們的假設是正確的可能性。

我至少發現了另外一個啟發式。這是最大的輸出啟發式。輸出`0`測量`123,689 Sats`，而輸出`1`測量`505,839 Sats`。因此，這兩個輸出之間存在顯著差異。最大輸出啟發式表明，最大的輸出可能是外國的 Exchange。這個啟發式進一步強化了我們最初的假設。

因此，提供 UTXO 作為輸入的使用者很可能仍持有 `1` 輸出，這似乎體現了交易的 Exchange。

***練習 4:***

此交易的模式是簡單付款。因此，我們可以對交易運用內部啟發式分析，嘗試找出 Exchange。

我個人發現至少有兩種內部啟發式方法支持相同的假設：


- 重複使用相同類型的腳本 ；
- 圓柱輸出。

最明顯的啟發式就是重複使用相同類型的腳本。事實上，輸出 `0` 是一個 `P2SH`，可透過接收以 `3` 開頭的 Address 識別：

```plaintext
3FSH5Mnq6S5FyQoKR9Yjakk3X4KCGxeaD4
```

而輸出 `1` 是 `P2WPKH`，其 Address 以 `bc1q` 開頭：

```plaintext
bc1qvdywdcfsyavt4v8uxmmrdt6meu4vgeg439n7sg
```

用作此交易輸入的 UTXO 也使用 `P2WPKH`腳本：

```plaintext
bc1qku3f2y294h3ks5eusv63dslcua2xnlzxx0k6kp
```

因此，我們可以假設輸出 `0` 對應付款，而輸出 `1` 是交易 Exchange，這表示輸入使用者永遠擁有輸出 `1`。

為了支持或反駁這個假設，我們可以尋找其他啟發式的方法，來證實我們的想法，或是降低我們的假設是正確的可能性。

我至少發現了另外一個啟發式。那就是整數輸出。輸出`0`計量`70,000 Sats`，而輸出`1`計量`22,962 Sats`。因此，在 BTC 帳戶單位中，我們有一個完全圓整的輸出。圓形輸出啟發式顯示，具有圓形金額的 UTXO 最有可能是付款的 UTXO，排除後，另一個代表 Exchange。這個啟發式進一步強化了我們最初的假設。

然而，在這個範例中，另一個啟發式可能會挑戰我們最初的假設。事實上，輸出`0`大於輸出`1`。根據啟發式，最大的輸出一般是外國的 Exchange，我們可以推斷輸出`0`是外國的 Exchange。然而，這個反假設似乎不太可信，因為其他兩個啟發式似乎比最大輸出啟發式更有說服力。因此，儘管有這個表面上的矛盾，維持我們最初的假設似乎是合理的。

因此，提供 UTXO 作為輸入的使用者很可能仍持有 `1` 輸出，這似乎體現了交易的 Exchange。

***練習 5:***

我們可以看到有 8 項交易可以與 Loïc 的身份相關聯。其中 4 項涉及比特幣的接收：

```plaintext
2d9575553c99578268ffba49a1b2adc3b85a29926728bd0280703a04d051eace
8b70bd322e6118b8a002dbdb731d16b59c4a729c2379af376ae230cf8cdde0dd
d5864ea93e7a8db9d3fb113651d2131567e284e868021e114a67c3f5fb616ac4
bc4dcf2200c88ac1f976b8c9018ce70f9007e949435841fc5681fd33308dd762
```

另外 4 筆涉及 Bitcoin 出貨：

```plaintext
8b52fe3c2cf8bef60828399d1c776c0e9e99e7aaeeff721fff70f4b68145d540
c12499e9a865b9e920012e39b4b9867ea821e44c047d022ebb5c9113f2910ed6
a6dbebebca119af3d05c0196b76f80fdbf78f20368ebef1b7fd3476d0814517d
3aeb7ce02c35eaecccc0a97a771d92c3e65e86bedff42a8185edd12ce89d89cc
```

***練習 6:***

如果我們看看這筆交易的模型，很明顯這是一筆捆綁式支出。事實上，這筆交易有單一的輸入和 51 個輸出，顯示出經濟活動的高度。因此，我們可以假設 Loïc 從 Exchange 平台提取了比特幣。

有幾個因素強化了這個假設。首先，用來保護 UTXO 輸入的腳本類型是 P2SH 2/3 Multisig 腳本，這表示 Exchange 平台典型的進階安全層級：

```plaintext
OP_PUSHNUM_2
OP_PUSHBYTES_33 03eae02975918af86577e1d8a257773118fd6ceaf43f1a543a4a04a410e9af4a59
OP_PUSHBYTES_33 03ba37b6c04aaf7099edc389e22eeb5eae643ce0ab89ac5afa4fb934f575f24b4e
OP_PUSHBYTES_33 03d95ef2dc0749859929f3ed4aa5668c7a95baa47133d3abec25896411321d2d2d
OP_PUSHNUM_3
OP_CHECKMULTISIG
```

更重要的是，Address 研究的 `3PUv9tQMSDCEPSMsYSopA5wDW86pwRFbNF` 在超過 220,000 個不同的交易中被重複使用，這通常是 Exchange 平台的特徵，一般不關心其機密性。

應用於此 Address 的時間啟發式也顯示，在 3 個月的時間內，幾乎每天都有固定的交易播送，延長時間超過 24 小時，顯示 Exchange 平台的持續活動。

最後，這個實體處理的交易量非常巨大。在 2022 年 12 月至 2023 年 3 月期間，Address 在 222,262 次交易中接收和發送了 44 BTC。這些大量交易進一步證實了 Exchange 平台活動的可能性。

***練習 7:***

透過分析交易確認時間，可以找出下列 UTC 時間：

```plaintext
05:43
20:51
18:12
17:16
04:28
23:38
07:45
21:55
```

對這些時間表的分析顯示，UTC-7 和 UTC-8 在大多數時間表上都符合目前人類活動的範圍 (08:00 到 23:00)：

```plaintext
05:43 UTC > 22:43 UTC-7
20:51 UTC > 13:51 UTC-7
18:12 UTC > 11:12 UTC-7
17:16 UTC > 10:16 UTC-7
04:28 UTC > 21:28 UTC-7
23:38 UTC > 16:38 UTC-7
07:45 UTC > 00:45 UTC-7
21:55 UTC > 14:55 UTC-7
05:43 UTC > 21:43 UTC-8
20:51 UTC > 12:51 UTC-8
18:12 UTC > 10:12 UTC-8
17:16 UTC > 09:16 UTC-8
04:28 UTC > 20:28 UTC-8
23:38 UTC > 15:38 UTC-8
07:45 UTC > 23:45 UTC-8
21:55 UTC > 13:55 UTC-8
```

![BTC204](assets/fr/066.webp)

UTC-7時區在夏季尤其重要，因為它包括諸如......等州和地區：


- 加州（包括洛杉磯、舊金山和聖地牙哥等城市）；
- 內華達州（含拉斯維加斯） ；
- 俄勒岡州（含波特蘭） ；
- 華盛頓（含西雅圖） ；
- 加拿大不列顛哥倫比亞省地區（包括溫哥華和維多利亞等城市）。

此資訊顯示 Loïc 很可能居住在美國西岸或加拿大。

***練習 8:***

分析此交易可發現 5 個輸入和單一輸出，顯示交易已合併。應用 CIOH 啟發式，我們可以假設所有輸入的 UTXO 都是由單一實體所擁有，而輸出的 UTXO 也屬於這個實體。看來使用者選擇將他擁有的幾個 UTXO 組合起來，在輸出中形成單一的 UTXO，目的是整合他的部分。此舉的動機可能是希望利用當時低廉的交易成本，以降低未來的成本。

___

*為了撰寫這份第 3 部分 on chain 分析，我參考了下列資源：*


- 由 Samourai Wallet 於 2021 年製作的四篇系列文章，題為：[使用 OXT 瞭解 Bitcoin 隱私權](https://medium.com/oxt-research/understanding-Bitcoin-privacy-with-oxt-part-1-4-8177a40a5923) ;*
- 來自 [OXT Research](https://medium.com/oxt-research) 的各種報告，以及他們免費的 Blockchain 分析工具 (在 Samourai Wallet 的創辦人被捕後，暫時已無法使用);**。
- 更廣泛而言，我的知識來自 [@LaurentMT](https://twitter.com/LaurentMT) 和 [@ErgoBTC](https://twitter.com/ErgoBTC) 的各種推文和內容 ;*
- 我和 [@louneskmt](https://twitter.com/louneskmt)、[@TheoPantamis](https://twitter.com/TheoPantamis)、[@Sosthene___](https://twitter.com/Sosthene___) 和 [@LaurentMT](https://twitter.com/LaurentMT) 一起參加的 [Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji)。*

*我要感謝他們的作者、開發人員和製作人員。同時也感謝校對人員，他們仔細地修正了本第 3 部分所依據的文章，並給了我專業的建議 :* *。


- [Gilles Cadignan](https://twitter.com/gillesCadignan) ;*
- [Ludovic Lars](https://viresinnumeris.fr/)

# 掌握保護您隱私的最佳作法

<partId>9bd04b63-f1af-4e50-9061-6bc90009df68</partId>

## Address 重複使用

<chapterId>f3e97645-3df3-41bc-a4ed-d2c740113d96</chapterId>

在研究過會破壞 Bitcoin 機密性的技術之後，我們將在第三部分探討保護自己的最佳做法。本部分的目的不是探討改善機密性的方法，這個主題稍後會處理，而是了解如何正確地與 Bitcoin 互動，以保留其自然提供的機密性，而不需訴諸其他技術。

很明顯，在第三部分的開始，我們要談談 Address 重複使用的問題。這種現象是對使用者機密性的主要威脅。本章肯定是整個課程中最重要的一章。

### 什麼是接收 Address？

接收 Address 的 Bitcoin 是用來在 Wallet 上接收 bitcoins 的字串或識別碼。

技術上來說，接收 Address 的 Bitcoin 並非字面上的「接收」比特幣，而是用來定義可以花費比特幣的條件。具體來說，當付款寄給您時，寄件者的交易會為您建立一個新的 UTXO，作為它消耗的 UTXOs 輸入的輸出。在這個輸出上，它會貼上一個腳本，定義這個 UTXO 日後如何使用。這個腳本稱為「*ScriptPubKey*」或「*Locking Script*」。您收到的 Address，或更準確地說，其有效載荷，已整合到此腳本中。通俗來說，這個腳本基本上是這樣說的：

> 「*若要使用此新 UTXO，您必須使用與此接收 Address 相關的私人金鑰提供數位簽章*」。
![BTC204](assets/fr/067.webp)

Bitcoin 位址有不同的類型，取決於所使用的腳本模型。第一種模式稱為「傳統*」，包括 `P2PKH` (*Pay-to-PubKey-Hash*) 和 `P2SH` (*Pay-to-Script-Hash*) 位址。P2PKH 位址總是以 `1` 開頭，而 P2SH 則以 `3` 開頭。雖然這些格式仍然安全，但現在已經過時，因為它們需要較高的交易成本，而且提供的保密性也比新標準低。

SegWit V0 (`P2WPKH`和`P2WSH`) 和 Taproot / SegWit V1 (`P2TR`)位址代表現代格式。SegWit 位址以 `bc1q` 開頭，而 2021 年推出的 Taproot 位址則以 `bc1p` 開頭。

例如，這裡是 Taproot 接收 Address：

```text
bc1ps5gd2ys8kllz9alpmcwxqegn7kl3elrpnnlegwkm3xpq2h8da07spxwtf5
```

如何建立 ScriptPubKey 取決於您使用的標準：

| ScriptPubKey | 腳本範本

| ---------------- | ----------------------------------------------------------- |

| P2PKH | OP_DUP OP_HASH160 `<pubKeyHash>` OP_EQUALVERIFY OP_CHECKSIG | OP_EQUALVERIFY OP_CHECKSIG

| P2SH | OP_HASH160 `<scriptHash>` OP_EQUAL | P2SH | OP_HASH160

| P2WPKH | 0 `<pubKeyHash>` | `<pubKeyHash>`

P2WSH | 0 `<witnessScriptHash>` | P2WSH | 0 `<witnessScriptHash>` | P2WSH | 0

| P2SH - P2WPKH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL |

| P2SH - P2WSH | OP_HASH160 ``<redeemScriptHash>` OP_EQUAL |

| P2TR | 1 `<pubKey>` | P2TR

接收位址的建構也取決於所選擇的腳本模型：


- 對於 `P2PKH` 和 `P2WPKH` 位址，有效負載（即 Address 的核心）代表公開金鑰的 Hash；
- 對於 `P2SH` 和 `P2WSH` 位址，有效負載代表 .NET 的 Hash；
- 至於 `P2TR` 位址，其有效負載是經過調整的公開金鑰。P2TR 輸出結合了 _Pay-to-PubKey_ 和 _Pay-to-Script_ 兩種方式。經調整過的公開金鑰是在經典的花費公開金鑰上加上「調整」的結果，衍生自一套也可以用來花費比特幣的腳本的 Merkle Root。

![BTC204](assets/fr/068.webp)

在您的組合軟體上顯示的位址也包含 HRP (*Human-Readable Part*) (通常為 SegWit 後位址的 `bc`)、`1` 分隔符，以及 SegWit V0 的版本號`q`和 Taproot/SegWit V1 的版本號`p`。還會加入校驗和，以保證 Address 在傳輸過程中的完整性和有效性。

最後，地址會被放入標準格式中：


- 舊有 Legacy 位址的 Base58check ；
- Bech32 用於 SegWit 位址 ；
- Bech32m 用於 Taproot 位址。

以下是以 10 為基數的 bech32 和 bech32m 格式 (SegWit 和 Taproot) 的加法矩陣：

| + | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |

| --- | --- | --- | --- | --- | --- | --- | --- | --- |

| 0 | q | p | z | r | y | 9 | x | 8 |

| 8 | g | f | 2 | t | v | d | w | 0 |

| 16 | s | 3 | j | n | 5 | 4 | k | h |

| 24 | c | e | 6 | m | u | a | 7 | l |

### 什麼是 Address 重複使用？

Address 重複使用是指使用相同的接收 Address 來封鎖數個不同的 UTXO。

正如我們在上一節所看到的，每個 UTXO 都有自己的 ScriptPubKey，這個 ScriptPubKey 會鎖定 UTXO，必須滿足 ScriptPubKey 的要求 UTXO 才能在新的交易中作為輸入被使用。正是在 ScriptPubKey 中整合了有效負載位址。

當不同的 ScriptPubKeys 包含相同的接收 Address 時，這稱為 Address 重複使用。實際上，這意味著用戶重複向發件人提供相同的 Address，以便通過多次支付接收比特幣。而正是這種做法對您的隱私造成了災難性的影響。

### 為什麼 Address 的重複使用是個問題？

由於 Blockchain 是公開的，所以很容易看到哪些地址鎖定了哪些 UTXO，以及有多少比特幣。如果同一個 Address 用於多筆交易，就有可能推斷出與該 Address 相關的所有比特幣都屬於同一人。這種做法會損害使用者的隱私，因為不同的交易之間會建立確定的連結，而比特幣也會在 Blockchain 上被追蹤。Satoshi 中本自己已經在 Bitcoin 的白皮書中強調了這個問題：

> *作為額外的防火牆，每筆交易都可以使用一對新的金鑰，以保持它們與共同的所有者沒有連結*。
![BTC204](assets/fr/055.webp)

資料來源：S：S. Nakamoto，「Bitcoin：點對點電子現金系統」，https://Bitcoin.org/Bitcoin.pdf，2009 年。

Satoshi 這句話的用意是在使用者的身分與 Bitcoin 上的金鑰對有關聯的情況下，建立額外的防火牆，防止他的整個活動被公開連結到他的身分上。今天，隨著 Blockchain 分析公司和 KYC 法規的激增，使用唯一地址已不再是「額外的防火牆」，而是任何希望保留起碼隱私的人不可或缺的做法。

當您重複使用 Address 時，您會在與該 Address 相關的所有交易之間建立幾乎不可抹滅的連結。雖然這不會直接危及您的資金，因為橢圓曲線加密法保證了您私密金鑰的安全性，但卻讓您的活動更容易被監控。事實上，任何擁有節點的人都可以觀察地址的交易和餘額，完全損害您的匿名性。

![BTC204](assets/fr/054.webp)

為了說明這一點，讓我們以 Bob 為例，Bob 是一個經常在 DCA 小額購買比特幣的用戶，他總是把比特幣發送到同一個 Address。兩年之後，這個 Address 包含了相當數量的比特幣。如果 Bob 使用此 Address 向當地商家付款，後者將能看到所有相關資金，並推算出 Bob 的財富。這可能導致個人安全風險，例如企圖盜竊或勒索。如果鮑勃使用空白的 Address 來接收每筆定期購買的款項，他向商家透露的資訊就會無限減少。

在字串分析中，有 2 種類型的 Address 重複使用：


- 外部再利用 ；
- 交易內部重用。

第一種情況是當 Address 在數個不同的 Bitcoin 交易中被重複使用。這就是我們之前談過的：這個啟發式推斷所有經過這個 Address 的 UTXO 都屬於單一實體。

內部 Address 重複使用不是發生在跨越數個交易的重複使用，而是發生在單一交易內。事實上，如果用於鎖定輸入的相同 Address 被用作交易的輸出，那麼我們可以推斷此輸出仍屬於同一使用者 (Exchange)，而第二個輸出代表實際付款。這個其他的啟發式方法讓我們可以在幾個交易中持續追蹤資金。

![BTC204](assets/fr/045.webp)

Address 的重複使用在 Bitcoin 上確實是個禍害。根據 OXT.me 網站（目前無法存取）的資料，2022 年 Bitcoin 上 Address 的整體重複使用率約為 52%：

![BTC204](assets/fr/069.webp)

這個比率相當龐大，但絕大多數來自 Exchange 平台，而非個人使用者。

### 如何避免 Address 重複使用？

避免重複使用 Address 非常簡單： **simply use a new, blank Address for all new payments to your Wallet**.

感謝 BIP32，現代的組合現在是確定且分層的。這表示使用者可從單一初始資訊 generate 獲得大量地址：seed。透過儲存這單一資訊，就可以還原組合中的所有私人密碼匙，從而存取相應地址所保證的資金。

![BTC204](assets/fr/070.webp)

這就是為什麼當您在 Wallet 軟體中按下 "*receive*" 按鈕，每次都會建議一個未使用的接收 Address。在這個 Address 收到 bitcoins 之後，軟體會自動建議一個新的 Address。

> *PS: 最近有些 Wallet 軟體宣佈要停止產生空白位址，他們擔心這會被當局視為一種洗錢的行為。如果您的軟體是其中之一，我強烈建議您立即更換，因為這是使用者所不能接受的*。
如果您需要靜態識別碼來接收付款，例如捐款，由於重複使用的風險，不建議使用經典的 Bitcoin Address。取而代之，使用 Lightning Address，或選擇靜態鏈上支付識別碼，如 BIP47 或 Silent Payments。本培訓課程的第 6 部分將詳細解釋這些協定。

## 標籤和檢查零件

<chapterId>fbdb07cd-c025-48f2-97b0-bd1bc21c68a8</chapterId>

正如我們在字串分析一節中所發現的，有許多啟發和模式可用來推斷交易資訊。身為使用者，必須瞭解這些技術，才能更好地防範。

這包括嚴格管理自我保管的 Wallet，也就是了解您的 UTXO 的來源，以及在付款時小心選擇要消耗的 UTXO。這種有效率的 Wallet 管理有賴於優良 Bitcoin 錢包的兩個重要功能：標籤和硬幣控制。

在本章中，我們將探討這些功能，看看如何在不增加太多工作量的情況下，智慧地使用這些功能，以大幅優化您在 Bitcoin 上的隱私權。

### 什麼是標籤？

標籤是指為 Bitcoin Wallet 中的特定 UTXO 指定註釋或標籤。這些註釋由 Wallet 軟體本機儲存，絕不會透過 Bitcoin 網路傳輸。因此，標籤是一種個人管理工具。

例如，如果我有一個 UTXO 來自與 Charles 在 Bisq 購買的 P2P，我可以標籤它為「`Non-KYC Bisq Charles`」。

標籤是一種良好的做法，有助於記住 UTXO 的來源或預期目的地，因此有助於管理資金和優化隱私。事實上，您的 Bitcoin Wallet 必定有數個 UTXO。如果這些 UTXOs 的來源不同，您可能不希望將來合併這些 UTXOs，否則可能會暴露它們共同的 Ownership。只要正確標示所有零件，就能確保您在需要使用這些零件時，記得它們的來源，即使那是多年以後的事。

### 什麼是角落控制？

若搭配投資組合軟體上的硬幣控制選項，主動使用標籤會變得更有趣。

硬幣控制是優良 Bitcoin Wallet 軟體中的一項功能，讓您可以手動選擇特定的 UTXO 作為輸入來完成交易。事實上，為了滿足輸出付款，您需要消耗輸入 UTXO 作為回報。基於許多原因（我們稍後會詳細討論），您可能想要精確地選擇消耗哪些部分作為輸入，以滿足特定的付款。這正是硬幣控制可以讓您做到的。打个比方，这个功能类似于您在支付法棍时从 Wallet 中选择一个特定的硬币。

![BTC204](assets/fr/071.webp)

使用具有硬幣控制功能的組合軟體，再加上 UTXO 標籤，讓使用者既能分辨又能精確地選擇UTXO 進行交易。

### 您如何標示您的 UTXO？

標示 UTXO 並沒有放諸四海皆準的方法。您需要為您的投資組合定義一個易於理解的標籤系統。無論如何，請記住好的標籤是您在需要時可以理解的標籤。如果您的 Bitcoin Wallet 主要用於儲蓄，那麼這些標籤可能在未來數十年都不會對您有用。因此，請確保標籤清晰、精確且全面。

重要的是，如果有一天您的親人需要存取您的投資組合，他們可以很容易地確定資金的來源。如果他們需要向當局證明資金的來源，這將有助於他們的保密和法律目的。

標籤上最需要注意的是 UTXO 的來源。您只需說明硬幣是如何出現在您的 Wallet 中的。它是在 Exchange 平台上購買的結果嗎？客戶的 Invoice 付款？點對點的 Exchange？還是它代表了一項支出的 Exchange？例如，您可以指定：


- 移除 Exchange.com` ；
- 客戶付款 David` ；
- 購買 P2P Charles` ；
- 更換沙發

![BTC204](assets/fr/072.webp)

為了微調您的 UTXO 管理，並尊重您投資組合內的基金分離策略，您可以在標籤中加入反映這些分離的額外指標。如果您的投資組合包含兩種您不希望混雜的 UTXO 類別，您可以在標籤中加入標記，以清楚區分這些組別。這些區分標記取決於您自己的標準，例如區分涉及 KYC 的收購過程所產生的 UTXO，或區分專業基金與個人基金。以上述標籤範例為例，這可以轉換為


- `KYC-提款 Exchange.com` ；
- KYC - 客戶付款 David `；
- `NO KYC - 購買 P2P Charles` ；
- 沒有 KYC - 變更沙發購買

![BTC204](assets/fr/073.webp)

此外，建議在交易過程中永久標示某個部分。例如，將 UTXO no-KYC 合併時，請務必在合併後的 UTXO 上標示「合併」，並特別標示「合併 no-KYC」，以便清楚記錄硬幣的來源。

最後，並不是一定要在標籤上標示日期。大多數的 Wallet 軟體已經會顯示交易日期，而且由於有 txid 的關係，總能在 Block explorer 上找到此資訊。

### 如何選擇正確的零件？

當您執行交易時，硬幣控制可讓您特別選擇消耗哪些 UTXO 作為輸入，以滿足付款輸出。這個選擇有兩方面：


- 收款人有可能將您的部分身份與輸入中使用的 UTXO 連結起來；
- 外部觀察者在所有作為輸入消耗的 UTXO 之間建立連結的能力。

為了說明第一點，讓我們舉一個具體的例子。假設您用比特幣向麵包師傅買了一根法棍。您使用您持有的一個或多個 UTXO 作為輸入，至少滿足了法棍的價格輸出，以及交易費用。您的麵包師傅可能會將您的臉，或他知道的您身份的任何其他部分，與作為輸入的硬幣聯繫起來。知道這個連結的存在後，您在付款時可能會選擇特定的 UTXO 而非其他。

![BTC204](assets/fr/074.webp)

例如，如果您的其中一個 UTXO 來自 Exchange 平台，而您希望烘焙師不知道您在該平台上的帳戶，您會避免使用該 UTXO 付款。如果您有一個高價值的 UTXO，顯示了大量的比特幣，您也可能會選擇不使用它，以避免烘焙師知道您的 BTC 財富。

因此，選擇哪些 UTXO 用於第一點是個人的決定，會受到您是否願意透露資訊的影響。當您收到 UTXO 時，您為其指定的標籤將可協助您選擇那些一旦使用後，只會揭露您願意透露給接收者的資訊。

除了可能透露給接收者的資訊之外，輸入的選擇也會影響您透露給 Blockchain 所有觀察者的資訊。事實上，根據 CIOH 啟發式 (_Common Input Ownership Heuristic_)，使用數個 UTXOs 作為交易的輸入，您就會透露這些 UTXOs 屬於同一個實體。

![BTC204](assets/fr/075.webp)

因此，在選擇零件時，您必須注意您要廣播的交易會在所有使用的 UTXOs 之間建立連結。此連結可能會對您的個人隱私造成問題，尤其是當 UTXO 來自不同來源時。

![BTC204](assets/fr/076.webp)

以我從 Bisq 購買的無 KYC UTXO 為例，我希望避免將它與知道我身份的受監管 Exchange 平台的 UTXO 結合。事實上，如果我使用這兩個 UTXO 作為同一筆交易的輸入，受監管的平台將能夠把我的身份與我在 Bisq 上購買的 UTXO 連結起來，而 UTXO 之前並未與我的身份連結。

![BTC204](assets/fr/077.webp)

最後，在選擇使用哪些 UTXO 作為交易的輸入時，最重要的是避免使用多個 UTXO。如果可以的話，最多選擇一個夠大的硬幣來滿足您的支付。這樣，您就完全避免了與 CIOH 相關的風險。但是，如果沒有一個 UTXO 足夠支付，而您需要消耗多個 UTXO，請確保它們來自相似的來源，以減少不必要的連結風險。同時請記住，收件人可能會將他們所持有的您的資訊與投入時所使用的硬幣歷史相關聯。

### 瞭解自動零件選擇

在前幾節中，我們討論了手動選擇要用於交易的 UTXO。但當 Wallet 軟體自動執行此選擇時會發生什麼情況？有幾種方法可以決定消耗哪些硬幣，而選擇 UTXO 構成了 Bitcoin 名副其實的研究領域。這個自動過程的主要目的通常是為了使用戶的交易成本最小化。

UTXO 選擇方法如 FIFO（*先入先出*）和 LIFO（*後入先出*）是最簡單的方法，但也是效率最低的方法。使用 FIFO 時，先使用投資組合中最舊的部分。除了使用相對時間鎖且需要定期更新的情況外，這種方法對於交易成本最小化和保密性而言通常都是低效的。相反，後進先出 (LIFO) 會優先使用最近的 UTXO。這兩種方法雖然都很簡單，但經常被證明是無效的。

更進階的方法是 *Knapsack Solver*。在 0.17 版之前，Bitcoin Core Wallet 一直使用此方法。它包括反覆隨機地從 Wallet 中選擇 UTXO，將它們以子集的形式相加，並保留盡可能降低交易權重的解決方案，以降低使用者的成本。

分支與邊界* (BNB)，常因其發明者而被暱稱為 「Murch 演算法」，自 0.17 版起已取代 Bitcoin Core 中的*Knapsack Solver*。這種更先進的方法旨在找到一組與滿足交易輸出所需金額完全對應的 UTXO。BNB 的目標是藉由減少所謂的浪費準則 (waste criterion)，將 Exchange 的數額以及費用降至最低，此浪費準則同時考慮到 Exchange 的即時成本以及預期的未來成本。此方法源自 Ailsa Land 和 Alison Harcourt 於 1960 年構思的 *Branch-and-Bound* 原始概念，提供比 *Knapsack Solver* 更精確的費用最佳化。

所有這些自動 UTXO 選擇方法都可能有效降低交易成本，但卻往往無法有效保護使用者機密。事實上，這些演算法可以將多個 UTXO 合併為輸入，從而揭露這些 UTXO 因 CIOH 而產生的共同屬性。顯然，這些方法無法考慮到貼在 UTXOs 上的標籤，而這些標籤對於有意識地選擇向交易接收者揭露哪些部分是至關重要的。目前，選擇硬幣時優化保密性的唯一方法就是手動操作。

### UTXO 標籤教程

如果您想瞭解如何標記您的 UTXO，我們已經在主要的 Bitcoin Wallet 軟體上做了全面的教學：

https://planb.network/tutorials/privacy/on-chain/utxo-labelling-d997f80f-8a96-45b5-8a4e-a3e1b7788c52
## KYC 和關鍵識別

<chapterId>cec6b9d9-0eed-4f85-bc4e-1e9aa59ca605</chapterId>

KYC 代表「認識您的客戶」。這是某些在 Bitcoin 部門營運的公司所執行的監管程序。此程序的目的是核實和登記其客戶的身份，其聲明的目的是打擊洗錢和恐怖主義融資活動。

實際上，KYC 涉及收集客戶的各種個人資料，這些資料可能因司法管轄區而異，但一般包括身份證、照片和 Address 證明。然後，這些資訊會被核實和儲存，以供日後使用。

此程序已成為大多數西方國家所有受監管 Exchange 平台的強制性規定。這意味著任何希望通過這些平台以 Exchange 國家貨幣進行 Bitcoin 的人都必須遵守 KYC 要求。

此程序對於使用者的隱私權和安全性並非沒有風險。在本章中，我們將詳細研究這些風險，並分析 KYC 和識別程序對 Bitcoin 使用者隱私權的具體影響。

### 促進鏈上追蹤

與 KYC 相關的第一個風險是，它為 Blockchain 分析提供了一個優越的切入點。正如我們在上一節所看到的，分析師可以使用交易模式和啟發式方法來聚類和追蹤 Blockchain 上的活動。一旦他們成功聚類使用者的 onchain 活動，他們所需要做的就是在他所有的交易和金鑰中找到一個單一的切入點，以完全洩露他的機密性。

![BTC204](assets/fr/078.webp)

當您執行 KYC 時，您提供了一個高品質的 Blockchain 分析切入點，因為您將您從 Exchange 平台提取比特幣時使用的接收地址與您的完整、經過驗證的身份相聯繫。理論上，只有您提供資訊的公司知道這些資訊，但正如我們將在下面看到的，資料洩漏的風險是真實存在的。更重要的是，即使公司不分享這些資訊，單是公司持有這些資訊的事實就可能會造成問題。

因此，如果您不採取其他步驟來限制您在 Blockchain 上活動的彙總，任何知道此 KYC 入口點的人都有可能將您在 Bitcoin 上的所有活動與您的身份聯繫起來。從該公司的觀點來看，您使用 Bitcoin 就失去了所有的保密性。

![BTC204](assets/fr/079.webp)

用比較來說明這一點，就好像您在 *Bank X* 的銀行家不僅可以存取您在 *Bank X* 的所有交易，也可以觀察您在 *Bank Y* 的交易，以及您所有的現金交易。

還記得本訓練課程的第一部分嗎？Bitcoin 的保密模型，正如 Satoshi Nakamoto 所構想的，是基於使用者的身分和他的金鑰對之間的分離。雖然這種 Layer 的保密性在今日已不再足夠，但盡可能限制其退化仍是謹慎的做法。

### 受到國家監視

KYC 的第二個主要問題是，它會向國家透露您曾在某個時間擁有 Bitcoin。當您透過受監管的行為人購買比特幣時，國家就有可能知道您擁有這筆錢。目前，這似乎微不足道，但重要的是要記住，您國家的政治和經濟未來不在您的手中。

首先，國家可以迅速採取專制立場。歷史上有很多政策突然改變的例子。今天，在歐洲，比特幣玩家可以撰寫關於Bitcoin的文章，參加會議，並自行管理他們的錢包。但是誰能說明天會發生什麼呢？如果Bitcoin突然成為頭號公敵，在政府檔案中與之相關可能會產生問題。

那麼，面對嚴重的經濟危機，國家可能會考慮扣押公民持有的比特幣。也許明天，比特幣持有者會被視為危機中的暴發戶，面對法幣貶值，他們的資本收益會被徵收過高的稅收。

您可能認為這不是問題，因為您的比特幣是混合的，因此無法追蹤。然而，追蹤並不是這裡的問題。真正的問題是國家知道您擁有過 Bitcoin。僅這個信息就足以將您入罪或追究您的責任。你可以嘗試聲稱你花掉了你的比特幣，但這必須反映在你的納稅申報單上，你就會被抓到。你也可以說你在一次划船事故中丟了鑰匙，但除了 Twitter 上的笑話之外，你真的認為這足以為你開脫罪責嗎？

因此，重要的是要考慮到國家知道您擁有 BTC 的風險，無論這種風險今天看起來有多渺茫。

KYC 在國家監管方面造成的另一個問題是受監管平台的強制報告。雖然我不熟悉其他司法管轄區的法規，但在法國，*Prestataires de Services sur Actifs Numériques* (PSAN) 有義務向金融監督機構報告任何他們認為可疑的資金動向。

在2023年的法國，PSAN報告了1,449起可疑行為。就目前而言，這些行為大多與犯罪有關。但是，當局也要求受監管的平台僅根據交易結構來報告任何可疑的 Bitcoin 交易。如果您進行的是合作交易，甚至只是模式稍有異常的交易，而且此交易發生的地點與您從這些平台提取比特幣的地點相距不遠，您可能會發現自己被舉報到當局。即使沒有瀆職行為，即使是合法行使您的權利，這樣的舉報也可能導致檢查和監控的增加，而如果沒有 KYC，這些不便是可以避免的。

### 個人資料外洩的風險

KYC 的另一個問題是，它要求您的所有個人資料都儲存在私人公司的伺服器上。

最近發生的事件提醒我們，沒有人能避免財務或 IT 故障。2022 年，Celsius 的客戶就承受了這樣的後果。公司破產後，美國法院在行政訴訟程序中公開了債權人的姓名和資產金額。

就在兩年多前，它是加密貨幣網絡安全的旗艦，其客戶的個人資料被盜。雖然這次事件與購買比特幣沒有直接關係，但對 Exchange 平台來說，這樣的風險同樣存在。因此，與個人資料相關的風險確實存在。

誠然，我們已經把許多個人資料託付給私人公司。但是，這裡的風險是雙重的，因為這些資料不僅能識別您的身份，還與 Bitcoin 上的活動相關聯。事實上，當駭客取得 Exchange 平台的客戶資料時，他可以合理地假設這些客戶擁有比特幣。Bitcoin 和其他任何有價值的資產一樣，會吸引盜賊的注意，因此這種風險更大。

如果發生資料洩漏，最壞的情況是您可能成為目標性網路釣魚嘗試的目標。在最壞的情況下，您可能會發現自己成為家中受到實體威脅的中心。

除了與 Bitcoin 相關的特定風險外，還有與傳輸身分證明文件相關的危險。事實上，一旦資料外洩，就有可能成為身份盜竊的受害者。因此，利害關係不僅限於保護交易的機密性，還關係到每個人的個人安全。

### 關於 KYC 的一些先入為主的想法

重要的是要解構一些關於 KYC 的先入為主的觀念，我們經常在 Twitter 上或比特幣玩家之間的交流中遇到這些觀念。

首先，認為保護通過 KYC 獲得的比特幣的隱私是沒有意義的是不準確的。Bitcoin上的隱私保護工具和方法是多種多樣的，服務於不同的目的。例如，在通過 KYC 獲得的比特幣上使用 CoinJoin 交易不是一個壞主意。當然，使用受監管的 Exchange 平台時需要小心，以免帳戶被凍結或封禁，但從嚴格的技術角度來看，這些做法並不是互不相容的。CoinJoin 具有打破代幣歷史的效果，因此可以幫助您挫敗某些與 KYC 相關的連鎖分析風險。儘管它並不能消除所有的風險，但它確實代表了一個顯著的好處。

![BTC204](assets/fr/080.webp)

Bitcoin 上的保密性不應該以二元對立的方式來看待，將其視為 「匿名 」比特幣與其他非匿名比特幣之間的區別。擁有透過 KYC 獲得的比特幣並不意味著一切都完了；相反地，使用保密工具可以證明更加有益。

相反，透過非 KYC 方式取得 Bitcoin 並不保證完全保密，也不能免除您採取其他保護措施的需要。如果您持有非 KYC Bitcoin，但多次重複使用接收地址，您的交易可能會被追蹤和彙總。與 Bitcoin 以外世界的最微小連結，都可能危及您僅有的 Layer 機密性。因此，將 Bitcoin 上的所有加強隱私權的工具和方法視為互補是很重要的。每種技術都能解決特定的風險，並能增加額外的 Layer 保護。因此，擁有非 KYC Bitcoin 並不表示您不需要採取其他預防措施。

### KYC 可以取消嗎？

有時候我會被問到在執行 KYC 之後是否可以 「回頭」，從前面的段落可以想像，答案是很細微的。避免 KYC 相關風險的最簡單方法就是在取得比特幣時不要使用它。我們會在下一章更深入的探討這個主題。但是，如果已經進行了 KYC 並購買了比特幣，有沒有辦法減輕所涉及的風險呢？

說到交易被追蹤的風險，使用 CoinJoin 是一個解決方法。我們稍後會在課程中詳細介紹這種方法，但您應該知道 CoinJoin 可以讓您打破硬幣的歷史，防止被追蹤到過去-現在和現在-過去。即使是通過監管平台獲得的 BTC，此技術也可以防止其被追蹤。

然而，CoinJoin 並未消除與 KYC 相關的第二個風險：國家可能會獲知您擁有比特幣的事實。事實上，即使您的比特幣不再可追蹤，國家（取決於司法管轄區）也可能獲得您的加密資產轉移聲明。由於這種風險不是技術性的，而是行政性的，所以除了一開始就不要讓自己暴露在 KYC 的風險之外，沒有 Bitcoin 專用的解決方案來消除這種風險。降低此風險的唯一合法方法是在受監管的平台上出售您透過受監管平台獲得的比特幣，然後再透過無需 KYC 的方式回購。通過出售並聲明轉移，當局應該會發現您不再擁有它們。

至於洩露您個人資料和身分證明文件的風險，這是 Bitcoin 外在的危險，沒有任何技術解決方案可以避免。一旦您的資料被洩露，就很難撤銷操作。您可以嘗試關閉您在平台上的帳戶，但這並不能保證刪除您的 KYC 資料，尤其是在身份驗證外包的情況下。驗證完全刪除您的資料是不可能的。因此，沒有任何解決方案可完全防止此風險，並確保此風險不再存在。

### KYC 與關鍵識別的差異

有時候，一些比特幣玩家傾向於將 "KYC "這個詞延伸到任何涉及電匯或信用卡支付的BTC Exchange，因為這些手段也可以像KYC一樣揭示支付的來源。但是，KYC 不應該與密鑰識別混為一談。就我個人而言，我必須承認，我對這個主題的看法隨著時間的推移而演變。

KYC 特指某些公司為了驗證和登記客戶身份而實施的監管程序。這是一件二元對立的事情：在獲取比特幣時，要麼做 KYC，要麼不做。然而，關鍵識別涉及用戶身份的某個方面與上鏈活動之間的聯繫，它不像二進制那樣，而是代表一個連續體。事實上，在 Bitcoin 獲取或轉移的情況下，這種識別在不同程度上總是可能的。

例如，如果您在瑞士的監管平台上購買比特幣，則不需要 KYC。但是，您的鑰匙可能會被識別出來，因為購買是通過您的銀行帳戶進行的。這時，與 KYC 相關的前兩個風險 - 促進鏈上追蹤和暴露於國家監控 - 也會在沒有 KYC 的 Exchange 中體現。如果瑞士實體向您所在國家的當局報告可疑交易，他們只需檢查用於購買的銀行帳戶即可發現您的身份。因此，在受監管的平台上不經 KYC 購買，在關鍵識別的風險等級上相當高。

![BTC204](assets/fr/081.webp)

然而，避開受監管的平台並選擇 P2P 購買方式並不能完全消除鑰匙識別的風險，而只是降低了風險。讓我們以在 Bisq 或其他 P2P 平台上購買為例。要付款給交易對手，您可能會使用您的銀行帳戶。如果當局詢問與您交易的人，並問出您的姓名，我們又回到風險 1 和 2。儘管這些風險比在沒有 KYC 的平台上購買時低得多，甚至比在有 KYC 的平台上購買時更低，但它們在較小程度上仍然存在。

![BTC204](assets/fr/082.webp)

最後，即使您透過實體 Exchange 以現金取得比特幣，您也不是完全匿名的。與您交換的人看到了您的臉，這是您身份的一部分。雖然在這個例子中微乎其微，但仍有可能被鑰匙識別。

![BTC204](assets/fr/083.webp)

總之，當比特幣與其他資產交換時，無論是以國家貨幣購買或以實物兌換，總會有某種形式的鑰匙識別。根據所選擇的 Exchange 方法，這種識別的強度可能會有所不同。重要的是，不要將這種識別與 KYC 混為一談，KYC 是一個明確的監管流程。然而，KYC 與識別頻譜之間是有關連的，因為 KYC 屬於頻譜的高端，因為它有系統地促進了主管機關對使用者金鑰的識別。

## 銷售和採購方法

<chapterId>756598af-95aa-4c77-ac48-243c7ad89530</chapterId>

閱讀完上一章之後，您可能會想知道，為了避免與 KYC 相關的風險，您該如何在無需進行身份驗證程序的情況下買入或賣出 Bitcoin。交易 Bitcoin 有幾種方式。

### P2P 現金交換

正如我們所見，就保密性而言，最好的方法仍然是 P2P（人對人）Exchange 與現金結算。這種方法可以讓您盡量減少留下的蛛絲馬跡，無論是買入還是賣出，都大大降低了鑰匙被識別的可能性。

![BTC204](assets/fr/084.webp)

然而，個人安全也存在風險。主要的危險在於，在 Exchange 期間，交易對方會知道您持有大筆現金或比特幣。這些資訊會引起惡意人士的注意。事實上，一般建議您對 Bitcoin 的持有量保持謹慎。此建議也可適用於現金。然而，當面交換時，不可避免地會透露您擁有比特幣，這可能會引起不愉快的注意。

![BTC204](assets/fr/085.webp)

為了限制此風險，我建議您傾向與可信賴的人進行現金交易，例如家人或親密朋友。另外，您也可以考慮在 [當地 Bitcoin 聚會](https://btcmap.org/communities/map) 進行交易，在參加幾次之後。這樣可以讓您更了解其他參與者，在進行實體交換時也不會感到孤單。然而，重要的是要認識到，P2P 現金交換對您的個人安全固有風險，而通過受監管的平台和您的銀行帳戶購買則不存在這些風險。

更重要的是，視您居住的地方而定，不論是 Bitcoin 或現金，運送和儲存大筆資金都可能有風險。

兌換現金也可能在警察或其他檢查時造成法律風險。雖然大多數國家對您攜帶現金的數量沒有限制，但過量的現金可能會引起懷疑。因此請務必謹慎，尤其是當您必須長途旅行時，並避免一次進行太多大額交易，以免您必須證明持有大筆現金的合理性。

最後，P2P 購買的另一個缺點是價格通常高於受監管的平台。賣家通常會加價 1%，有時甚至超過 10%。造成這種價格差異的原因有幾個。首先，這是 P2P 賣家的普遍做法，隨著時間的推移已經形成。其次，賣家有相關的交易費用，將資金寄給買家。與平台交易相比，P2P 的銷售也增加了盜竊的風險，因此有理由對所承擔的風險進行補償。最後，額外成本可能與 Exchange 在保密性方面的需求和品質有關。作為買方，保密性的增益是有價格的，這反映在賣方的加價上。一些比特幣玩家也認為，在P2P上購買的BTC的加價價格反映了它的真實價格，並認為在受監管的平台上較低的價格是您的個人資料保密性受損的結果。

![BTC204](assets/fr/086.webp)

### 透過撮合平台進行 P2P 交換

就個人安全而言，風險較低的選擇是透過 PayPal、銀行轉帳或 Revolut 等電子付款方式，完全在線上進行 P2P 兌換。

![BTC204](assets/fr/087.webp)

這種方式避免了許多與現金交易相關的風險。但是，在線上 Exchange 交易中，交易對方違約的風險較大。事實上，在實體的 Exchange 交易中，如果您把錢交給賣家，但他沒有把比特幣寄給您作為回報，您可以立即要求他負責，因為他就站在您面前。另一方面，在網路上，往往無法追蹤到偷你錢的人。

![BTC204](assets/fr/088.webp)

為了降低此風險，可以使用專門的平台進行 P2P 交換。這些平台使用衝突解決機制來保護受委屈的使用者。一般而言，這些平台會提供託管系統，在賣方確認以法定貨幣付款之前，比特幣都會存放在託管系統。

![BTC204](assets/fr/089.webp)

就個人安全而言，這種購買方式比實體現金 Exchange 安全得多。然而，如上所述，線上 P2P 交換會比實體 Exchange 留下更多的痕跡，這可能會對 Bitcoin 的隱私造成損害。透過使用銀行等線上法幣付款方式，您會暴露更多可能有助於鎖碼辨識的資訊。

![BTC204](assets/fr/090.webp)

再次重申，我不建議在這些平台的單筆交易中進行過多的大額交易。透過分割交易，您可以分散交易對手盜用的風險。

再說一次，P2P 購買的另一個缺點是價格通常高於受監管平台的價格。賣家通常會加價 1%，有時甚至超過 10%。造成這種價格差異的原因有幾個。首先，這是 P2P 賣家的常見做法，隨著時間的推移已經形成。其次，賣家需要支付相關的交易費用，才能將資金寄送給買家。與平台交易相比，P2P 銷售中的盜竊風險也會增加，因此有理由對所承擔的風險進行補償。最後，額外成本可能與 Exchange 在保密性方面的需求和品質有關。作為買方，保密性的收益是有價格的，這反映在賣方的加價上。一些比特幣玩家也認為，在 P2P 上購買的 BTC 的加價價格反映了其真實的價格，並認為監管平台上較低的價格是您個人資料保密性受損的結果。

![BTC204](assets/fr/086.webp)

就解決方案而言，我個人一直使用 [Bisq](https://bisq.network/)，而且非常滿意。他們的系統經過測試，看起來很可靠。不過，Bisq 只能在 PC 上使用，而且它的 Interface 對初學者來說可能太複雜。另一個缺點是，Bisq 僅使用 onchain 交易，這在 Bitcoin 交易費用高昂的時期可能變得昂貴。

-> 請參閱我們的 Bisq 教學。

https://planb.network/tutorials/exchange/peer-to-peer/bisq-fe244bfa-dcc4-4522-8ec7-92223373ed04
若要更簡單的選擇，您可以試試 [Peach](https://peachbitcoin.com/)，這是一個連接買家和賣家的行動應用程式，內建解決衝突的系統。過程比 Bisq 更直覺。

-> 請參閱我們的 Peach 教學。

https://planb.network/tutorials/exchange/peer-to-peer/peach-c6143241-d900-4047-9b73-1caba5e1f874
另一個線上選擇是 [HodlHodl](https://hodlhodl.com/)，這是一個完善的平台，提供良好的流動性，雖然我沒有親自測試過。

-> 請參閱我們的 HodlHodl 教學。

https://planb.network/tutorials/exchange/peer-to-peer/hodlhodl-d7344cd5-6b18-40f5-8e78-2574a93a3879
關於基於 Lightning Network 的解決方案，請嘗試 [RoboSats](https://learn.robosats.com/) 和 [LNP2PBot](https://lnp2pbot.com/)。RoboSats 可透過網站存取，使用相對簡單。LNP2PBot 則較為非典型，因為它是透過 Telegram 訊息應用程式上的 Exchange 系統運作。

-> 請參閱我們的 RoboSats 教學。

-> 請參閱我們的 LNP2PBot 教學。

https://planb.network/tutorials/exchange/peer-to-peer/robosats-b60e4f7c-533a-4295-9f6d-5368152e8c06
https://planb.network/tutorials/exchange/peer-to-peer/lnp2pbot-v2-e6bcb210-610b-487d-970c-7cce85273e3c
![BTC204](assets/fr/091.webp)

### 沒有 KYC 的受監管平台

根據您所居住的國家，您可以使用不需要 KYC 程序的受監管平台來買賣比特幣。例如，在瑞士，您可以使用 [Relai](https://relai.app/) 和 [MtPelerin](https://www.mtpelerin.com/) 等平台。

-> 請參閱我們關於 Relai 的教學。

https://planb.network/tutorials/exchange/centralized/relai-v2-30a9671d-e407-459d-9203-4c3eae15b30e
正如我們在前一章所看到的，這類平台可讓您免於 KYC 程序所帶來的風險，但它們的鑰匙識別風險確實較高。因此，就 Bitcoin 的保密性而言，這些平台提供的保護比有 KYC 的購買方式更好，但它們的吸引力仍比不上 P2P 交易所。

不過，就個人安全而言，使用這些平台的風險遠低於 P2P 交換平台。它們通常也比 P2P 平台簡單易用。

### 自動櫃員機

另一個無需 KYC 即可買賣比特幣的選擇是加密貨幣 ATM。就我個人而言，我從來沒有機會測試這種解決方案，因為在我的國家裡沒有。但這種方法可能非常有趣，這取決於你住在哪裡。

![BTC204](assets/fr/092.webp)

自動櫃員機的問題在於，有些國家禁止使用自動櫃員機，有些國家則高度管制自動櫃員機。如果自動提款機需要身份驗證程序，那麼它所面臨的風險與受 KYC 監管的平台所固有的風險相同。另一方面，如果自動提款機允許進行小額交易而無需身份驗證，那麼使用自動提款機可以提供與 P2P 現金 Exchange 相當的保密性，同時避免了與這類 Exchange 相關的大部分風險。

自動櫃員機的主要缺點是 Exchange 費用通常很高，從兌換金額的幾個百分點到有時 15%。

### 禮品卡

最後，我還想向您介紹一個解決方案，對於那些想要每天使用比特幣進行採購，而不是將比特幣出售兌換法定貨幣的人來說，這個方案非常好用。

花費 BTC 的最佳方式當然是直接使用 Bitcoin 或 Lightning Network 購買商品或服務。但是，在許多國家，接受 Bitcoin 的商家數量仍然有限。一個實用的替代方法是使用禮品卡。

有幾個不需要 KYC 程序的平台提供將比特幣兌換成禮品卡的可能性，這些禮品卡可以在主要零售商處使用。這些平台包括 [CoinsBee](https://www.coinsbee.com/), [The Bitcoin Company](https://thebitcoincompany.com/) 和 [Bitrefill](https://www.bitrefill.com/)。這些平台讓比特幣的日常使用變得更加容易，讓您可以使用各種產品和服務，而無需將其轉換為法定貨幣。

https://planb.network/tutorials/exchange/centralized/bitrefill-8c588412-1bfc-465b-9bca-e647a647fbc1
![BTC204](assets/fr/093.webp)

### 其他獲取方法

在保護您隱私的同時，其他獲取比特幣的方式當然還包括 Mining。要啟動 Mining Sats，您不需要透露身份，只需找到有效的 Proof of Work 並提交給網絡即可。如果您選擇 Mining 池，有些池需要某些形式的身份證明，例如 KYC，而有些則不需要。

另一種方法是在 Exchange 中進行比特幣的工作。這種獲取方法可能很有趣，但所需的識別程度因環境不同而有很大差異。

*為了撰寫本章，我使用 [@pivi___](https://x.com/pivi___) 所提供的 Plan ₿ Network BTC205 訓練課程 (目前只有法文版)

## 整合、UTXO 管理和 CIOH

<chapterId>d0486c8f-332d-402b-ae2e-949416752b9c</chapterId>

經營自我託管投資組合最複雜的方面之一就是整合。您應該整合嗎？有什麼意義？UTXO 應該尊重什麼規模？在機密性方面有哪些妥協？這就是我們本節要探討的問題。

### 何謂整合？

Bitcoin 的運作方式類似拍賣市場，礦工會優先考慮提供最低費用的交易。但是，每個區塊都有最大權重，這限制了可包含的交易數量。由於平均每 10 分鐘就會產生一個區塊，因此每個區塊的可用空間是稀缺資源。

礦工的活動 generate 在電力、固定資產和維護方面的成本很高，自然會尋求最大利潤。因此，他們傾向於青睞 generate 相對於其重量而言費用最高的交易。

並非所有的 Bitcoin 交易都具有相同的權重。那些有更多輸入和輸出的交易會有更高的權重。例如，讓我們想像 2 個交易：


- 交易 A 包含 1 個輸入和 1 個輸出。它分配了 1,994 Sats 的費用，權重為 141 vB；
- 交易 B 是更複雜的交易，有 2 個輸入和 2 個輸出，分配 2,640 Sats 的費用，重量為 220 vB。

![BTC204](assets/fr/094.webp)

在這個範例中，雖然交易 B 提供較高的總費用，但礦工會偏好交易 A，因為它在費用和權重之間提供較好的比率。以下是每筆交易的計算方式，以每虛擬位元組 (sat/vB) 的 Sats 表示：

```text
TXA : 1994 / 141 = 14 sats/vB
TXB : 2640 / 220 = 12 sats / vB
```

這表示對於每單位重量，交易 A 提供的成本比交易 B 高，即使交易 B 提供的絕對成本較高。

![BTC204](assets/fr/095.webp)

因此，對使用者來說，在交易中消耗盡可能少的輸入總是比較有趣的。但是，您需要消耗足夠的數量才能滿足輸出付款。在管理投資組合時，您需要有足夠大的 UTXO。

合併的原則正是利用 Bitcoin 費用低廉的時期，將較小的 UTXO 合併為單一較大的 UTXO。如此一來，當 Bitcoin 上的費用上升時，您就能以最少的投入進行交易，因此絕對花費較少。因此，我們的目標是預測在高費用期間必須進行的交易。

![BTC204](assets/fr/096.webp)

除了節省交易成本之外，整合 UTXO 也有助於防止「Dust」的形成。Dust "指的是在 Sats 中價值低到不足以支付花費所需交易成本的 UTXO。只要交易成本居高不下，使用這些 UTXO 在經濟上就是不合理的。透過主動匯集您的 UTXOs，您可以防止它們變成 Dust，確保您所有的資金仍然可用。

### 您的 UTXOs 的最小尺寸是多少？

有時有人會問我，UTXO 的建議最低值是多少。不幸的是，這並沒有一個通用的答案，因為這取決於您的喜好和收費市場的條件。不過，這裡有一個公式，可以幫助您決定適合您需求的門檻：

$$
\frac {P \times F}T = M
$$

在哪裡？


- p$ 是交易權重；
- $F$ 代表您對沖的最大費率，單位為每 vbyte (Sats/vB) 的飽和度；
- t$ 是您願意支付的交易費佔 UTXO 總值的百分比；
- m$ 是每個 UTXO 的最低金額（以梭子為單位）。

假設您打算為一筆有 1 個輸入和 2 個輸出、重量為 141 vB 的標準 SegWit 交易支付費用。如果您要對沖高達 800 Sats/vB，而您最多只願意花費 UTXO 價值的 12% 作為費用，那麼計算方式如下：

$$
\frac{141 \times 800}{0.12} = 940\ 000
$$

因此，在本範例中，明智的做法是在您的投資組合中為 UTXOs 保留最低值 940,000 Sats。

### 整合與 CIOH

Blockchain 分析中最廣泛使用的啟發式之一是 CIOH（*共同輸入 Ownership 啟發式*），它假定 Bitcoin 交易的所有輸入都屬於同一個實體。合併的原理就是消耗數個 UTXO 作為輸入，並建立單一 UTXO 作為輸出。因此，整合可以應用 ICOH。

![BTC204](assets/fr/097.webp)

實際上，這表示外部觀察者可以推斷所有合併的 UTXO 很可能屬於同一個人，而產生的唯一輸出也屬於他或她。這種情況會將不同的交易歷史聯繫起來，危及您的機密性。例如，假設我將透過 P2P 取得的 3 個 UTXO 與透過需要 KYC 的平台取得的 1 個 UTXO 合併：

![BTC204](assets/fr/098.webp)

這樣一來，任何可以存取 Exchange 平台資料的實體（可能包括政府機構），都可以識別出我擁有其他數量的 BTC。在此之前，這些 UTXOs 與我的身份沒有直接關聯，現在則有了。更重要的是，它會向所有來源透露我擁有一定數量的比特幣。

在管理 UTXOs 時，經濟考量驅使合併以降低成本，但卻與良好的隱私權實務有所衝突，因為良好的隱私權實務建議絕對不要合併 UTXOs。因此，在經濟性與機密性之間的選擇取決於每位使用者的優先順序。

如果您可以避免合併，同時維持可觀的 UTXOs，那就最理想不過了。要做到這一點，請優化您的購買方法。如果您在 DCA 購買您的比特幣，請儘量縮短一次性購買的時間，將價值整合到較少的 UTXOs 上。每兩個月一次性購買 1000 歐元，比每星期購買 120 歐元更容易管理。這可將產生的 UTXOs 數量降至最低，並簡化您的投資組合管理，同時為您保密。

如果您發現您必須合併您的 bitcoins，請優先合併來自同一來源的 UTXOs。例如，合併來自單一平台的 10 個 UTXO 對您的保密性的影響會比混合來自平台 A 的 5 個 UTXO 和來自平台 B 的 5 個 UTXO 要小。例如，將透過 KYC 取得的 UTXO 集中在一筆交易中，而將透過 P2P 取得的 UTXO 集中在另一筆交易中。

無論如何，請不要忘記任何合併都不可避免地會造成機密性的損失。因此，請仔細評估這項作業的必要性以及對您隱私的潛在影響，並考慮到 CIOH。

## 其他最佳實踐

<chapterId>b5216965-7d13-4ea1-9b7c-e292966a487b</chapterId>

讓我們來看看其他幾個優化 Bitcoin 隱私權的最佳做法。

### 完整的結

擁有自己保管的 bitcoins 固然很好，但使用自己完整的節點則更好！以下是為什麼擁有自己的節點對於完全主權使用 Bitcoin 是至關重要的：


- 抵抗審查**：任何人都無法阻止您的交易；
- 獨立於第三方**：您不再依賴任何外部服務驗證 Blockchain 資料；
- 主動參與**：您可以定義自己的驗證規則，並直接參與共識；
- 網路貢獻**：藉由執行一個節點，您可以幫助強化和分散 Bitcoin 網路；
- 技術教育**：管理完整的節點是加深 Bitcoin 技術知識的好方法。

除了這些好處之外，使用完整的節點還可以提高您在廣播交易時的機密性。當您發佈交易時，它會先透過您的 Wallet 建立並簽署。若要在 Bitcoin 網路上廣播，必須至少有一個節點知道它。透過使用您自己的節點，您可以直接控制此分發，從而加強您的機密性，並限制資料外洩的風險。

![BTC204](assets/fr/099.webp)

如果您沒有自己的 Bitcoin 節點，您將不得不使用第三方節點，例如您的 Wallet 軟體供應商所提供的節點。除了廣播交易之外，您的 Wallet 還需要存取各種資訊，例如待處理的交易、與您地址相關的餘額，以及交易確認的次數。若要存取所有這些資料，您需要查詢節點。

![BTC204](assets/fr/100.webp)

當您不是使用自己的 Bitcoin 節點時，主要的風險是第三方節點的操作者可能會觀察到您在 Blockchain 上的活動，甚至與其他實體分享這些資訊。為了限制此風險，一個中間解決方案是使用 Wallet 軟體，透過 Tor 隱藏您的連線。這可以減少您的資料曝光。然而，最佳的解決方案是擁有自己的 Bitcoin 節點，並使用它來廣播您的交易。當然，您也需要小心不要透過您的節點洩漏任何資訊，但這也是我們稍後會討論的另一個主題。

除了對您的隱私有明顯的好處之外，擁有自己完整的節點也能確保 Blockchain 上的資料真實性，保護您免受審查，並讓您積極參與 Bitcoin 的治理。通過使用自己的節點，您可以為自己選擇的鏈貢獻自己的經濟份量，這在社區內部衝突期間非常重要，例如在 2015 年至 2017 年的 Blocksize War 期間。在 Fork 的情況下，使用第三方節點可能會讓您支持您不想支持的鏈，因為節點運營商會為您做出選擇。

正如您所看到的，為了保密和個人主權，運行和使用自己的完整節點是非常必要的！

### 欺騙性分析啟發法

更廣泛來說，了解我們在上一節談到的啟發式，以便更好地避免或欺騙它們是很重要的。採用一系列的最佳實務，即使不是必要的，也是有益的。它們提供了額外的 Layer 保護，在使用 Bitcoin 時對於維護機密可能很重要。

我可以給的第一個建議是融入最密集的人群。在 Bitcoin 上，這意味著使用最廣泛採用的腳本範本。例如，常用於 SegWit V0 Multisig 配置的 P2WSH 腳本就非常不常用。它們無法讓您隱藏在大型匿名集中。P2PKH 或 P2SH 等較舊的模式也是一樣。雖然它們廣泛存在於 UTXO 設定中，但在新的交易中使用得越來越少。

一般而言，只要最新的腳本標準已被充分採用，選擇最新的腳本標準會比較明智。因此，如果在 2022 年，我會建議不要使用 P2TR (Taproot)，因為它的採用率很低，那麼到了 2024 年，我會建議改用這類腳本，如果不行，也可以使用 SegWit V0 腳本，因為使用 P2TR 的交易數量已經開始佔相當大的比例。

![BTC204](assets/fr/101.webp)

來源 : [txstats.com](https://txstats.com/d/000000054/UTXO-set-repartition-by-output-type)

另一個保密技巧是嘗試繞過內部交易啟發式處理。例如，在付款時，您可以嘗試避免建立金額為整數的輸出，因為這可能是其他輸出代表外國 Exchange 的訊號。如果您需要傳送 100 k Sats 給朋友，可以考慮傳送稍微高一點的金額來逃避這個啟發式。同樣地，儘量不要建立與所付金額不成比例的外國 Exchange 輸出，因為這也可能透露出哪一個輸出代表外國 Exchange。

![BTC204](assets/fr/102.webp)

最後，如果您定期執行 Bitcoin 交易，請確保不要總是在相同的時間播送。將交易的廣播時間分散在一天或一週之內，就可以避免讓外部觀察者有機會偵測到以時區為基礎的時間模式，進而強化他們的分析。

除了這些每天都要採取的良好作法之外，還有更有效的方法可以徹底破壞比特幣的可追蹤性。這些當然包括 CoinJoin 交易，我們會在下一節深入探討。

# 瞭解 CoinJoin 交易

<partId>6d0bbf16-3714-4db1-9897-2d45019f6bdc</partId>

## 什麼是 CoinJoin 交易？

<chapterId>0862bc6b-1c48-4aa4-b76d-4f547b469008</chapterId>

在學習了隱私權保護的基本知識之後，我們現在要來看看更複雜的技巧，目的在於主動捍衛您的機密性，尤其是透過解除您的 Bitcoin 歷史。在下一部分中，我們將探討一大堆小技巧，但首先，我想告訴您 CoinJoin。

CoinJoin 通常被認為是保護 Bitcoin 使用者隱私的最有效方法。但究竟什麼是 CoinJoin 交易呢？讓我們一探究竟。

### CoinJoin 的基本原則

CoinJoin 是一種在 Blockchain 上破解 Bitcoin 追蹤的技術。它以具備同名特定結構的協同交易為基礎：CoinJoin 交易。

正如我們在本課程的前半部分所看到的，Bitcoin 的交易是所有使用者透過他們的節點所知道的。因此很容易檢查每個硬幣的電子簽章鏈，並觀察其歷史。這表示所有使用者都可以嘗試分析其他使用者的交易。因此，交易層級的匿名性是不可能的。但是，匿名性在個人識別層面上得以保留。在傳統銀行系統中，每個帳戶都與個人身份相關聯，而 Bitcoin 與此不同，資金與密碼鑰匙對（或腳本）相關聯，為使用者提供了密碼識別符背後的一種假名形式。

![BTC204](assets/fr/103.webp)

當外部觀察者能將特定的 UTXOs 與已識別的使用者聯繫起來時，Bitcoin 的機密性就會受到破壞。一旦建立關聯，就有可能追蹤他們的交易並分析他們的 Bitcoin 歷史。CoinJoin 正是為了破解 UTXOs 的可追蹤性而開發的技術，以便在交易層級上為 Bitcoin 使用者提供一定的 Layer 保密性。

Coinjoins 可讓外部觀察者更複雜地進行連鎖分析，從而加強 Bitcoin 使用者的機密性。其結構允許將來自不同使用者的多個硬幣合併為單一交易，模糊了交易界線，使輸入與輸出地址之間的連結難以確定。

重要的是要了解 CoinJoin 交易的目的是打破硬幣的歷史。此技術不會賦予永久匿名性或完全阻止 Bitcoin 追蹤，這與您可能的想法相反。CoinJoin 只會在進行 CoinJoin 交易時破壞歷史記錄。然而，在此操作之前和之後，硬幣在保密性方面仍然面臨相同的風險。

![BTC204](assets/fr/104.webp)

### 共同接合如何運作？

CoinJoin 原則是以合作方式為基礎：多位希望混合比特幣的使用者將相同金額的比特幣存入同一筆交易作為輸入。這些金額會以等值的輸出重新分配給每個使用者。

![BTC204](assets/fr/105.webp)

在交易結束時，就無法將特定的輸出與稱為輸入的使用者聯繫起來。輸入與輸出之間沒有直接連結，這就打破了使用者與其 UTXOs 之間的關聯，也打破了每個零件的歷史。

![BTC204](assets/fr/106.webp)

讓我們以 Alice 為例。她想寄約 100,000 Sats 給她的妹妹 Eve 作為生日禮物。然而，Alice 不希望 Eve 可以追蹤她的交易歷史，因為她不想透露她有多少比特幣，或是她是如何得到這些比特幣的。為此，Alice 決定用 CoinJoin 交易來打破她的 UTXO 歷史。她組織了 Bob、Charles、David 和 Frank 進行合作交易：


- Alice、Bob、Charles、David 和 Frank 各承諾 105,000 UTXO Sats（其中 5,000 Sats 為 Mining 費用）作為交易的輸入：

![BTC204](assets/fr/107.webp)


- 作為消耗這些輸入的回報，每個人都會產生空白的 Address，以建立五個相同的輸出，每個輸出 100,000 Sats。每個取回一個輸出：

![BTC204](assets/fr/108.webp)


- Alice 發現自己有一筆 UTXO 的 100,000 Sats，其歷史被搞混了。她在新的交易中使用此 UTXO 將這筆金額寄給 Eve 作為生日禮物：

![BTC204](assets/fr/109.webp)


- 如果 Eve 嘗試分析這筆交易來擷取資訊，她會面對涉及 Alice、Bob、Charles、David 和 Frank 的 CoinJoin 交易。由於金額的一致性，Eve 無法區分哪些輸入是屬於誰的，因此無法追蹤 Alice 的 UTXO 歷史，也無法確定她妹妹擁有多少比特幣，或她是如何取得這些比特幣的：

![BTC204](assets/fr/110.webp)

在這個案例中，Alice 使用 CoinJoin 技術來增加回溯分析的保密性。實際上，Alice 是在保護自己不受 Eve 可能的分析，因為 Eve 會從特定的交易開始，並透過 UTXO 的歷史回溯分析。這種防止從現在到過去的分析，稱為回溯性保密。我們會在本節的最後幾章更詳細地探討這個概念。

然而，CoinJoin 也提供了面對從過去到現在的分析來強化保密性的可能性，也就是所謂的 prospective anonset。讓我們回到 Alice 送給 Eve 98,000 Sats 作為生日禮物的範例，但角色反轉。現在我們假設是 Eve 在擔心她的隱私權。事實上，Alice 可能會想追蹤她寄給 Eve 的硬幣，以便從中擷取資訊。Eve 很可能會將她剛收到的這個 UTXO 與她所有其他的 UTXO 整合在一起，這可能會向 Alice 透露她的 Wallet 中的比特幣數量。為了避免這種情況，Eve 也可以破解她剛收到的硬幣的歷史記錄：


- Eve, Grace, Mallory, Oscar 和 Victor 各自投入 98,000 Sats 的 UTXO，作為 Bitcoin 交易的輸入：

![BTC204](assets/fr/111.webp)


- 作為消耗這些輸入的回報，每個使用者都會提供一個空白的 Address，用來建立 5 個 97,500 個完全相等的 Sats 輸出。每位使用者得到一個輸出：

![BTC204](assets/fr/112.webp)


- Eve 現在持有 97,500 Sats 的 UTXO，其歷史已被打破。她可以放心地用它來進行未來的交易。事實上，如果 Alice 試著追蹤她寄給 Eve 的 bitcoins，她會遇到 CoinJoin 交易。她將無法判斷哪一個寄出的 UTXO 屬於 Eve。分析變得不可能：

![BTC204](assets/fr/113.webp)

在第一個範例中，我們看到 CoinJoin 如何保護與房間過去相關的隱私，而在第二個範例中，我們也看到 CoinJoin 如何保護與房間未來相關的歷史。這就是為什麼我提到 CoinJoin 應該被視為一個一次性的事件，它在兩個方向上都分割了一部分歷史：

![BTC204](assets/fr/104.webp)

### 攪拌器、CoinJoin、攪拌器...有什麼不同？

Coinjoins 有時被描述為 "mixers"，一些比特幣玩家拒絕使用這個詞，擔心它會與保管混合器混淆。然而，我相信這種憂慮是沒有根據的，因為在數學背景下，CoinJoin 體現的正是混合的概念。

在一般的數學領域中，混合是指動力系統的一種特性，在經過一段時間後，理論上初始空間的所有部分都可以與其他任何部分混合。混合意味著粒子的位置或系統的狀態會以這樣的方式演變：它的未來分佈與它的初始分佈無關，從而達到初始狀態的特性均勻地分佈在整個系統空間的狀態。這正是比特幣在 CoinJoin 中發生的情況。所以，在我看來，CoinJoin 是真正的混幣方法。

![BTC204](assets/fr/114.webp)

另一方面，將 CoinJoin 與 shuffler 區分開來是很重要的。洗幣機是一種服務，用戶將他們的比特幣送去洗幣。這些服務在 2010 年代很流行，但由於與 CoinJoin 相比有兩大缺點，其使用量已經下降：


- 它們要求使用者在混合過程中放棄對其資金的保管，這使他們面臨被盜的風險；
- 無法保證混音器不會記錄交易詳細資訊，甚至將這些資訊賣給連鎖分析公司。

![BTC204](assets/fr/115.webp)

因此，現今的使用者偏好 CoinJoin，因為 CoinJoin 可讓他們在整個過程中保留對其資金的完全控制。CoinJoin 的參與者不會有比特幣被其他參與方盜取的風險。讓我們在下一章看看這一切是如何實現的。

## Zerolink 和 chaumian 匯合

<chapterId>326c9654-b359-4906-b23d-d6518dd5dc3e</chapterId>

CoinJoin 所提供的隱密性是由我們的作品所隱藏的群體大小來贏得的。這意味著要找到盡可能多的參與者。我們完全可以利用自己找到的使用者，手動建立 CoinJoin，但這是一個複雜的過程，而且不會為您贏得任何大獎。

這就是 CoinJoin 協調員在 Bitcoin 上發展的原因。他們的角色是讓不同的使用者互相聯繫，並傳送完成協同交易所需的資訊。

![BTC204](assets/fr/116.webp)

但我們如何能確保協調人永遠不會染指使用者的比特幣，儘管他是建置 CoinJoin 交易的人，我們如何能確保他無法連結使用者的輸入和輸出，這可能會構成機密洩漏？

### Chaum 的盲簽名

現代的 CoinJoin 實作使用 David Chaum 的盲簽章來避免洩漏資訊。讓我們快速瞭解這些盲簽章是如何運作的。

Chaum 的盲簽章是數位簽章的一種形式，簽章的簽發者不知道他要簽章的訊息內容。但是簽章可以根據原始訊息進行驗證。此技術由密碼學家 David Chaum 於 1983 年開發。

![BTC204](assets/fr/117.webp)

讓我們以一家公司為例，該公司希望在不洩露機密文件（如 Contract）內容的情況下對其進行認證。該公司採用一種遮蔽程序，以可逆方式對原始文件進行加密轉換。此修改後的文件會傳送給認證機構，認證機構會在不知道基本內容的情況下貼上盲簽章。公司收到已簽署的文件後，就會鬆開簽署。結果是一份原始文件經由認證機關的簽名認證，而認證機關從未看過原始內容。

因此，Chaum 的盲簽章可以在不知道文件內容的情況下認證文件的真實性，從而保證使用者資料的機密性和簽章文件的完整性。

### Chaumian 合併

所謂的「Chaumian」coinjoins 結合了 Tor 和 David Chaum 的盲簽名，以確保協調者無法知道哪個輸出是屬於哪個使用者的。

CoinJoin 交易建構過程包含 3 個主要階段：輸入登記、輸出登記和交易簽章。讓我們以 CoinJoin 參與者之一的 Alice 為例，來看看這個過程。所有其他參與者都各自遵循與 Alice 相同的步驟。

**步驟 1：輸入註冊


- Alice 傳送 UTXO 到協調器，她希望使用 UTXO 作為交易的輸入，以及她希望使用遮罩的接收 Address 作為輸出來接收她的 bitcoins。因此，協調器無法知道 Alice 的 Address。它只能看到她的遮罩版本：

![BTC204](assets/fr/118.webp)


- 協調員檢查輸入的有效性，然後用他的私人金鑰簽署 Alice 的遮蔽 Address。他會將盲簽章回傳給 Alice：

![BTC204](assets/fr/119.webp)

**步驟 2：輸出登錄**


- Alice 可以解除她的 Address，現在已經由協調者的私人金鑰簽署。她會以不同的 Tor 身分建立新的連線。協調者無法識別出以這個新身分連線的是 Alice：

![BTC204](assets/fr/120.webp)


- Alice 將解除遮罩的 Address 和簽章傳送給協調者 (協調者仍不知道是 Alice)：

![BTC204](assets/fr/121.webp)

**步驟 3：簽署交易**


- 以同樣的方式，協調員從所有參與者擷取未被遮蔽的輸出。由於有相關的簽章，他可以檢查每個匿名提交的輸出都事先經由他的私人金鑰簽章，因此保證了它們的合法性。然後，他就可以建立 CoinJoin 交易，並發送給參與者簽署：

![BTC204](assets/fr/122.webp)


- Alice 和其他參與者一樣，會檢查她的輸入和輸出是否正確地包含在協調者建構的交易中。如果一切都令人滿意，她就會將解鎖輸入腳本的簽章傳送給協調者：

![BTC204](assets/fr/123.webp)


- 收集所有 CoinJoin 參與者的簽名後，協調器就可以在 Bitcoin 網路上廣播交易，以便將交易加入區塊中。

在此系統中，協調員無法將某一輸入連結至特定輸出。更重要的是，他無法挪用參與者的資金，因為他從來無法取得解鎖參與者的 UTXO 所需的私人密碼鑰匙。在整個過程中，直到步驟 3 結束前，他也無法存取簽名。當 Alice 和其他參與者簽署全局交易後，在檢查一切無誤後，協調者就無法再修改交易，包括輸出，而不會使其失效。這可以防止協調者竊取比特幣。

最後，CoinJoin 使用者在交易中註冊其產出時，希望得到類似公民在選舉中投票的保證。這些動作的公開與隱私方面存在二元性。一方面，是你想要保持隱私的東西：對於選民而言，他不希望他的選票與他的身分有任何關聯；對於 CoinJoin 使用者而言，他不希望他的輸出與他的輸入有任何關聯。事實上，如果協調者或其他任何一方成功在輸入與輸出之間建立連結，CoinJoin 就會失去所有興趣。如上文所述，CoinJoin 必須發揮硬幣歷史中斷的功能。這種停止發生的原因，正是因為在 CoinJoin 的交易中，不可能將特定的輸入與特定的輸出連結起來 (prospective anonset) ，反之亦然 (retrospective anonset)。

另一方面，還有公開性：選民希望確定他的選票包含在投票箱中；同樣地，CoinJoin 使用者也希望確定他的輸出包含在 CoinJoin 交易中。事實上，CoinJoin 的參與者絕對必須能夠在簽署交易前驗證其輸出是否存在，否則協調者可能會盜取資金。

正是由於使用了 David Chaum 的盲簽名，這兩個公共和私人的方面，保證了Chaumian Coinjoins 的參與者，他們的比特幣不會被盜，他們的資金也不會被追蹤。

### 誰發明了 CoinJoin 概念？

是Hard可以確定是誰最先將CoinJoin的想法介紹給Bitcoin，以及是誰想出在這種情況下使用David Chaum的盲簽名。通常認為是 Gregory Maxwell 在 [2013 年 BitcoinTalk 上的一則消息](https://bitcointalk.org/index.php?topic=279249.0) 中最先提到的：

> *"使用 Chaum 的盲簽名：使用者登入並提供輸入 (和 Exchange 位址) 以及他們希望傳送其私人部分的加密 blinded 版本；伺服器簽署令牌並傳送回來。使用者以匿名方式重新連線，解除其輸出位址的遮罩，並傳送回伺服器。伺服器可以看到所有的輸出都經由它簽署，因此所有的輸出都來自有效的參與者。之後，人們重新連線並登入
Maxwell, G. (2013, August 22)。 *CoinJoin：Bitcoin 現實世界的隱私*.BitcoinTalk 論壇. https://bitcointalk.org/index.php?topic=279249.0

![BTC204](assets/fr/124.webp)

然而，還有其他更早的提法，既有Chaum簽名作為混合的一部分，也有Coinjoins。[2011年6月，Duncan Townsend在BitcoinTalk](https://bitcointalk.org/index.php?topic=12751.0)上展示了一個混合器，它使用Chaum簽名的方式與現代的Chaumian Coinjoins非常相似。

在同一主題中，我們可以找到[hashcoin回應Duncan Townsend的訊息](https://bitcointalk.org/index.php?topic=12751.msg315793#msg315793)，以改善他的混音器。這則訊息所描述的過程正是coinjoins的目的。在 [Alex Mizrahi 在 2012 年的一則訊息](https://gist.github.com/killerstorm/6f843e1d3ffc38191aebca67d483bd88#file-laundry) 中也可以找到類似系統的提法，當時他正在為 Tenebrix 的創造者提供建議，Tenebrix 是最早的另類幣之一，也是後來創造 Litecoin 的基礎。甚至「CoinJoin」一詞本身據說也不是 Greg Maxwell 創造的，而是來自 Peter Todd 的想法。

![BTC204](assets/fr/125.webp)

### Zerolink

Zerolink 是一個全面的混合協定，它結合了 Chaumian coinjoins 和各種策略，以保護使用者的匿名性，防止幾種形式的鏈分析，特別是通過最小化與投資組合管理相關的錯誤。此協定 [由 nopara73 和 TDevD 於 2017 年推出](https://github.com/nopara73/ZeroLink/blob/master/README.md)。

![BTC204](assets/fr/126.webp)

顧名思義，Zerolink 背後的原理是建立 CoinJoin 交易，以確保無法追蹤輸入和輸出之間的連結。這是透過確保所有輸出的金額完全相同來達成的。

![BTC204](assets/fr/127.webp)

Zerolink 採取的一項重要預防措施，是使用獨立的密碼金鑰集，甚至是獨立的組合，將未混合的 UTXO 與混合的 UTXO 完全分開。這可以區分 「*預混合*」Wallet 與 "*post-mix*" 的區別。Wallet 的區別，Wallet 是預留給已混合的零件。

![BTC204](assets/fr/128.webp)

這種嚴格區分 UTXOs 的做法，首先是為了防止混合 UTXO 與未混合 UTXO 之間的意外連結。事實上，如果發生這樣的連結，CoinJoin 對於混合 UTXO 的效用就會在使用者不知情的情況下被取消，從而損害 UTXO 的機密性，而使用者還以為他已經破壞了 UTXO 的歷史。如果使用者將混合和未混合的 UTXOs 當作相同交易的輸入來消耗，這些連結可能會透過 Address 重複使用在混合 UTXO 與未混合 UTXO 的安全性上，或是透過 CIOH (_Common-Input-Ownership Heuristic_) 的應用而發生。透過分開混合前和混合後的組合，我們可以避免這種意外的關聯，並保護使用者免於無心之失。

![BTC204](assets/fr/129.webp)

這種分離也提供了在組合軟體層級上，在前混合組合與後混合組合之間應用不同規則的可能性。例如，在混合後組合中，軟體可以禁止將 UTXO 合併到輸入中，以防止應用 CIOH，因為這會損害使用者的 anonset。也可以將使用腳本和交易選項（例如 RBF 報告等）標準化，以防止被 Wallet 指紋識別。

目前，Whirlpool 是唯一嚴格應用 Zerolink 通訊協定的 CoinJoin 實作。在下一章中，我們會看看現有的各種 CoinJoin 實作，以及各種實作的優缺點。

## CoinJoin 實作

<chapterId>e37ed073-9498-4e4f-820b-30951e829596</chapterId>

*2024 年，我們見證了希望在 Bitcoin 上進行硬幣接合的使用者所能使用的工具發生了重大變化。我們目前正處於轉捩點，CoinJoin 市場正經歷重大的重整。本章一定會隨著時間更新

目前在 Bitcoin 上主要有 3 種不同的 CoinJoin 實作：


- Whirlpool；
- Wabisabi；
- JoinMarket.

這些實作的目的都是透過 CoinJoin 交易來打破 UTXO 的歷史。然而，它們的機制差異很大。因此，了解它們各自的運作方式是非常重要的，這樣您就可以選擇最適合您需求的方案。

### 加入市場

JoinMarket 由 Adam Gibson 和 Chris Belcher 於 2015 年創立，因其獨特的使用者連結模式，從其他 CoinJoin 實作中脫穎而出。該系統是以 P2P Exchange 市場為基礎，其中一些使用者，也就是「製造者」，提供他們的比特幣以供混合，而其他使用者，也就是「接受者」，則使用這些現金進行 Coinjoins，以換取一定的費用。

![BTC204](assets/fr/130.webp)

在此模式中，「製造者」將其比特幣提供給「接受者」，並收取服務費。交易者則付費使用製造者的比特幣進行自己的 CoinJoin 交易。服務費依所擔任的角色而有所不同："製造者」因提供流動性而累積費用，而「接受者」則支付費用。市場自由運作，沒有使用條件。

JoinMarket 的主要缺點之一是使用上的複雜性，需要對終端機有一定程度的熟悉才能有效操作。雖然這種複雜性對有經驗的使用者來說不是障礙，但可能會限制一般大眾的使用。不過，最近推出的網頁 Interface (稱為 JAM) 使其使用更為簡便。

![BTC204](assets/fr/131.webp)

來源 : [JAM](https://github.com/joinmarket-webui/jam/blob/devel/docs/assets/screenshot-dark.webp)

然而，技術障礙仍是一大障礙。在 CoinJoin 的生態系統中，參與者的數量強化了機密性，任何降低存取性的限制都會直接影響可用的流動性，而流動性是混合效率的關鍵因素。Bitcoin 已經是金融交易中的一個利基，將其使用的 Coinjoins 視為一個次利基，而 JoinMarket 則是其中更專門的一部分，因此限制了其增加使用者匿名性的潛力。

儘管 JoinMarket 有創新的 P2P 鏈結模型，對於 Coinjoiners 來說，JoinMarket 有一些顯著的缺點，特別是在交易結構方面。不像其他實作，例如 Whirlpool，JoinMarket 不保證輸出之間完全相等，而且有可能追蹤輸入與輸出之間的確定性連結。此外，它沒有工具防止已經混合在一起的部分再次混合，這可能會損害使用者所追求的保密性。

最後，雖然 JoinMarket 的概念很有趣，特別是對那些對動態流動性市場有興趣的人來說，但在我看來，它結構上的弱點和技術上的複雜性，讓它對尋找 CoinJoin 實作的新手和專家來說，都不太有趣。

### Wabisabi

Wabisabi 是另一個 CoinJoin 實作，採用集中交易協調的方式。這個模型是由 Ádám Ficsór (nopara73)、Yuval Kogman、Lucas Ontivero 和 István András Seres 在 2021 年構思的，並在翌年整合到 Wasabi 2.0 軟體中。Wabisabi 正是 2018 年推出的 Wasabi 軟體 CoinJoin 機型的進化版。

![BTC204](assets/fr/132.webp)

在 2010 年代末期，Wasabi 採用了與 Whirlpool 完全不同的 CoinJoin 交易結構。Wasabi 使用涉及數十個參與者的大型 CoinJoin 交易來增加參與者的 anonsets。相比之下，Whirlpool 選擇了多個小型交易，使 anonsets 在每個週期都呈指數級增長。

Exchange 的管理方法也區別了兩種實作。對於 Whirlpool，由於 TX0 的關係，外來 Exchange 在 CoinJoin 循環之前被排除並與 UTXOs 隔離，我將在下一章進一步解釋這個概念。另一方面，對於 Wasabi，外來 Exchange 形成 CoinJoin 交易的輸出之一，維持某些輸入和輸出之間的確定連結。

![BTC204](assets/fr/133.webp)

有了 Wabisabi，Wasabi 版本 2.0 已經調整了它的硬幣接合方式，以符合 Whirlpool 的方式。雖然 CoinJoin 交易仍然非常大，但現在可以依循 Whirlpool 模型，連續串接數個循環。Wabisabi 也特別注意 Exchange 的兌換率管理：Wasabi 1.0 版本直接將 Exchange 的兌換率與使用者的輸入掛鈎，而 Wabisabi 則不同，它試圖將 Exchange 的兌換率細分為數個小數目，並將所有參與者分成等額的面額。

讓我們以一個只涉及 2 位使用者的簡化範例來說明：Alice 希望混合 115,000 Sats，Bob 希望混合 210,000 Sats。忽略費用，在 Wasabi 1.0 中，CoinJoin 交易會產生 3 個 100,000 Sats 的輸出，加上 Alice 的 1 個 15,000 Sats 的 Exchange 和 Bob 的 1 個 10,000 Sats 的 Exchange。Exchange 的輸出仍會與輸入連結：

![BTC204](assets/fr/134.webp)

根據 Wabisabi，相同的交易會產生 3 筆 100,000 Sats 的輸出和 5 筆 5,000 Sats 的輸出，因此分散了 Exchange，使其無法與特定的輸入直接連結：

![BTC204](assets/fr/135.webp)

就我個人而言，我發現 Wabisabi 的外國 Exchange 管理存在數項風險，可能會影響其在保密性方面的成效：


- 當使用者貢獻的 UTXO 遠大於其他參與者的 UTXO 時，他最終不可避免地會得到與他的輸入相連的 Exchange 金額。這與協定的原始目的背道而馳，即消除所有可識別的交換；
- 以分散 Exchange 為目的的面額倍增可能會對混合效率造成損害。這個過程可能會導致某些產出的不安全性降低，因為它們變得更容易識別；
- 這種方法也會產生低價值的 UTXO，為使用者帶來管理上的問題。這些小的 UTXOs 如果與其價值相比，花費過高，就會變成 "Dust"。這種現象會導致用戶將數個 UTXOs 合併為未來交易的輸入，或將其合併。在這兩種情況下，由於 CIOH 的關係，這可能會減少所獲得的保密利益，或完全抵銷最初 CoinJoin 所獲得的保密利益。

Whirlpool 實現了 ZeroLink 協定，確保混合前和混合後的 UTXOs 嚴格分離，而 Wabisabi 則不同，它沒有保持這種嚴格的分離。此外，Wasabi 的某些客戶也曾出現 Address 重複使用的問題，這顯然對使用者非常不利。

在 Wasabi 版本 2.0 中，實施了新的 CoinJoin 費用政策。從現在開始，對於超過 0.01 Bitcoin 的 UTXOs，協調費設定為 0.3%，而對於較小的 UTXOs，則提供全額的協調費。此外，對於這些較小的 UTXOs，雖然 Mining 費用仍由用戶支付，但所有交易（包括重新混合）均免費。

這與 Whirlpool 的政策形成對比，在 Whirlpool 的政策中，無論獲得的 anonsets 大小如何，費用都是固定的。有了 Wasabi 2.0，儘管小規模的 UTXOs 可免除協調器費用，但使用者仍需為所有交易支付 Mining 費用，包括 remixes。

就在我寫這幾行字的時候，由於最近發生的事件，Wabisabi 的使用顯得更加複雜了。在 Samourai Wallet 的創始人被捕後，負責資助和管理Wasabi開發的公司 zkSNACKs 宣佈其 CoinJoin 協調器服務將於 2024 年 6 月 1 日停止使用。這個協調器是在Wasabi上預設設定的，負責絕大多數的流動性。

隨著這個主要協調器的停用，使用者現在必須連接到新的、獨立的協調器。這種改變會引起許多顧慮：一方面，新的協調者可能沒有足夠的流動性，從保密性的角度來看會降低硬幣接合的有效性。另一方面，有可能遇到惡意的協調者。這種情況為那些尋求使用 Wabisabi 的人增加了新的重大風險。

除了技術問題之外，Wasabi 背後的公司 zkSNACKs 決定使用字串分析公司的服務來過濾 CoinJoin 的參與者，也引起了嚴重的道德與策略問題。最初的想法是防止犯罪分子在 Wasabi 上使用 Coinjoins，此舉看似合法。然而，這引起了一個悖論：向一個以加強使用者機密性為主要任務的協調者支付費用，卻讓他資助一個以損害相同機密性為目的的公司。

更令人擔憂的是過濾原則，這與 Bitcoin 提供開放、不受審查的金融體系的理念形成強烈對比。儘管排除犯罪活動似乎是合理的，但這種過濾也可能影響個人的行為，儘管這些行為在某些情況下被歸類為非法，但在道德上卻是合理的或對社會有益的。Edward Snowden 的例子完美地說明了這種二分法：有些政府認為他的揭露行為是犯罪，但有些政府則認為他是為了公眾利益而採取行動的告密者。這種複雜性突顯了過濾的潛在危險，儘管用意良好，但最終會損害合法使用者的權利與安全。我也可以提到在某些專制政權下受到迫害的活動家和記者。

現在您應該知道了，我絕對偏好使用 Whirlpool 型號在 Bitcoin 上進行共同接合。此系統因其嚴謹性而脫穎而出，並提供絕佳的保密性保證。它也是唯一能提供在數學上被視為完美的組合的系統。在我看來，這個模型代表了 Bitcoin 上合併的未來。我邀請您在下一章更深入地探討這個模型。

## Whirlpool 如何運作

<chapterId>bdbd7109-e36d-4b4f-a3c6-928df4e9bfda</chapterId>

Whirlpool 與其他 CoinJoin 方法的不同之處在於使用「_ZeroLink_」交易，以確保所有輸入與輸出之間完全沒有可能的技術連結。這種完美的組合是透過一種結構來實現的，在這種結構中，每個參與者都提供相同數量的投入（Mining 費用除外），同時產生數量完全相等的輸出。

對於輸入的這種限制性方法使 Whirlpool 的 CoinJoin 交易具有一個獨特的特點：輸入和輸出之間完全沒有確定的聯繫。換句話說，相對於交易中的所有其他輸出，每項輸出歸屬於任何參與者的機率相同。

![BTC204](assets/fr/136.webp)

### Whirlpool 如何運作

最初，每個 Whirlpool CoinJoin 的參與者人數限制為 5 人，其中有 2 位新加入者和 3 位混音者（我們稍後會解釋這些概念）。然而，在 2023 年觀察到的 On-Chain 交易費用增加，促使 Samourai 的團隊重新思考其模式，以提高保密性，同時降低成本。因此，考慮到費用市場情況和參與者人數，協調員現在可以組織包括 6、7 或 8 位參與者的 Coinjoins。這些增強的環節被稱為 "Surge Cycles"。值得注意的是，無論是何種配置，Whirlpool 硬幣兌換總是只有 2 個新參與者。

因此，Whirlpool 交易的特點是輸入和輸出的數量相同，可以是 ：


- 5 組輸入和 5 組輸出 ；

![BTC204](assets/fr/137.webp)


- 6 組輸入和 6 組輸出 ；

![BTC204](assets/fr/138.webp)


- 7 輸入和 7 輸出 ；

![BTC204](assets/fr/139.webp)


- 8 組輸入和 8 組輸出。

![BTC204](assets/fr/140.webp)

Whirlpool 的模型是基於 CoinJoin 的小型交易。與 Wabisabi 和 JoinMarket 不同，Wabisabi 和 JoinMarket 的 anonsets 穩健性是基於單一週期 (或幾個週期) 的參與者數量，而 Whirlpool 則是依賴幾個小週期的順序。

在此模式中，使用者僅在首次加入池時支付費用，使他們能夠參與眾多混音，而無需支付額外費用。新加入者支付混音者的 Mining 費用。

每多一個 CoinJoin 參與的作品，以及過去遇到的同儕，anonsets 就會成倍增加。我們的目標是利用這些免費的混音，每次混音都會有助於強化與每件混音作品相關的 anonsets 密度。

![BTC204](assets/fr/141.webp)

Whirlpool 在設計時考慮到兩項重要需求：


- 由於 Samourai Wallet 首先是智慧型手機應用程式，因此可在行動裝置上輕鬆實作；
- 快速的再混合週期，以促進安裝量的顯著增加。

這些必要因素引導 Samourai Wallet 的開發人員在設計 Whirlpool 時做出選擇，導致他們限制每個週期的參與者人數。人數太少會影響 CoinJoin 的效率，大幅降低每個週期所產生的自動認證；人數太多則會對行動應用程式造成管理問題，妨礙週期流程。

最後，在 Whirlpool 上，每個 CoinJoin 不需要有太多的參與者，因為 anonsets 是在幾個 CoinJoin 循環的累積下產生的。這裡最重要的原則是所有參與者的 UTXO 都要同質，因為這可確保完美的混合，進而從混合與再混合循環中充分獲益。

### CoinJoin 游泳池和費用

為了讓這些多重週期能增加混合零件的anonsets，需要一定的架構來限制所使用的UTXOs數量。Whirlpool 定義了不同的池。

一個池代表一群希望混合在一起的使用者，他們同意使用的 UTXO 數量，以優化 CoinJoin 製程，同時維持完美的零件均質。每個池指定一個固定的 UTXO 數量，使用者必須遵守此數量才能參與。因此，要使用 Whirlpool 進行硬幣接合，您需要選擇一個池。目前可使用下列池：


- 0.5 比特幣 ；
- 0.05 Bitcoin ；
- 0.01 Bitcoin ；
- 0.001 Bitcoin (= 100,000 Sats)。

當您以您的比特幣進入一個池時，這些比特幣將被分割成與池中其他參與者完全同質的 generate UTXOs。每個池都有最高限額，因此如果金額超過此限額，您必須分兩次進入同一個池，或者轉到另一個金額更高的池：

| 儲存池 (Bitcoin) | 每筆最大金額 (Bitcoin) | 儲存池 (Bitcoin) | 每筆最大金額 (Bitcoin)

|----------------|--------------------------------------|

| 0,5 | 35 |

| 0,05 | 3,5 |

| 0,01 | 0,7 |

| 0,001 | 0,025 |

當 UTXO 可整合至 CoinJoin 時，即視為屬於一個池。但是，這並不表示使用者失去對它的擁有權。正如我們在本節前幾章所看到的，透過各種混合週期，您仍可完全控制您的金鑰，進而控制您的比特幣。這就是 CoinJoin 技術與其他集中式混合技術的不同之處。

若要加入 CoinJoin 池，您需要支付服務費和 Mining 費用。每個資料庫的服務費都是固定的，目的是酬謝負責開發和維護 Whirlpool 的團隊。

使用 Whirlpool 的服務費用只需在加入池時支付一次。加入之後，您就可以參加不限次數的混音，無需支付額外費用。以下是目前各音樂池的固定費用：

| 遊戲池 (Bitcoin) | 入場費 (Bitcoin) | 獎金 (Bitcoin)

|----------------|---------------------------------|

| 0,5 | 0,0175 |

| 0,05 | 0,00175 |

| 0.01 | 0.0005 (50,000 Sats) | | 0.0005 (50,000 Sats)

| 0.001 | 0.00005 (5,000 Sats) | 0.00005 (5,000 Sats) | 0.00005 (5,000 Sats)

無論您在 CoinJoin 中投入多少資金，這些費用基本上都是所選池的入場券。因此，無論您以 0.01 BTC 或 0.5 BTC 準確地進入 0.01 池，費用的絕對值都是相同的。

在進行 Whirlpool 硬幣接合之前，使用者可以選擇 2 種策略：


- 選擇較小的水池，以盡量降低服務成本，因為他知道他將得到數個較小的 UTXOs 作為回報；
- 或者選擇更大的池子，願意支付更高的費用，但最終只得到數量較少的高價值 UTXO。

通常不建議在 CoinJoin 循環之後合併數個混合 UTXO，因為這可能會危及獲取的機密性，特別是由於共用輸入 Ownership 啟發式 (CIOH：*Common-Input-Ownership-Heuristic*)。因此，為了避免在輸出中有太多的小值 UTXO，選擇較大的池可能是合理的，即使這意味著要付出更多。使用者必須評估這些權衡取捨，以選擇他偏好的池。

除了服務費之外，還必須考慮任何 Bitcoin 交易特有的 Mining 費用。作為 Whirlpool 用戶，您需要為準備交易 (`Tx0`)以及第一次 CoinJoin 支付 Mining 費用。由於 Whirlpool 基於向新加入者付費的模式，之後的所有混音都將免費。

事實上，在每個 Whirlpool CoinJoin 中，輸入的使用者中有 2 位是新加入者。其他投入來自混音者。因此，交易中所有參與者的 Mining 成本都由這 2 位新參與者承擔，他們也可以從免費的混音中獲益：

![BTC204](assets/fr/142.webp)

由于采用了这种收费系统，Whirlpool 真正从其他 CoinJoin 实现中脱颖而出，因为 UTXO 的匿名性与用户支付的价格不成正比。因此，只需支付 2 次交易（"Tx0 "和初始混合）的入池費和 Mining 費用，就有可能實現更高水平的匿名性。

值得注意的是，用戶在完成多幣兌換後，還需要支付 Mining 費用，才能從池中提取他的 UTXO，除非他選擇了 `mix to` 選項，該選項會提供一個外部 Address，直接從 CoinJoin 中接收資金，而無需任何額外交易。

### HD 組合帳戶

若要透過 Whirlpool 建立 CoinJoin，Wallet 必須 generate 幾個獨立的帳號。這就是 ZeroLink 協定背後的原理。在 HD (*Hierarchical Deterministic*) 組合的情況下，一個帳戶構成一個與其他帳戶完全隔離的區段，這種隔離發生在組合階層結構的第三個深度層級，即「xpub」層級。

![BTC204](assets/fr/143.webp)

理論上，一個 HD Wallet 最多可衍生出 `2^(32/2)` 不同的帳戶。所有 Bitcoin 錢包默認使用的初始帳戶與 `0'` 索引相對應。

對於適應 Whirlpool 的投資組合，使用 4 個帳戶來滿足 ZeroLink 流程的需求：


- 存款**帳戶，以索引 `0'` 識別；
- **壞銀行**（或 "doxxic change「）帳戶，以索引 」2,147,483,644'`"來識別；
- 以索引 `2 147 483 645'` ` 識別的 **premix** 帳戶 ；
- **postmix** 帳戶，以索引 `2 147 483 646'` 識別。

這些帳戶在 CoinJoin 流程中各司其職，我們將在以下各節中探討。

所有這些帳戶都連結到單一的 seed，使使用者可以使用他的復原短語以及（如適用）他的 passphrase 復原存取他所有的比特幣。然而，在復原作業中，軟體必須被告知所使用的各種帳戶索引。

讓我們來看看這些帳戶中 Whirlpool CoinJoin 的不同階段。

### TX0

任何 Whirlpool CoinJoin 的起始點都是**存款**帳戶。當您建立一個新的 Bitcoin Wallet 時，您會自動使用這個帳戶。這個帳戶需要存入您想要混合的比特幣。

Tx0" 是 Whirlpool 混合過程的第一步。其目的是為 CoinJoin 準備和均勻UTXOs，將其分成與所選池量相對應的單位，以確保均質混合。經此均勻後的 UTXOs 會被送至 **premix** 帳戶。至於無法進入池中的差額，則會被分到一個特定的帳戶中：**不良庫**（或稱為 「毒性變化」）。

這個初始的 `Tx0` 交易也用來支付 CoinJoin 協調者應得的服務費。與以下步驟不同的是，此交易不是協同交易，因此使用者必須承擔 Mining 的全部費用：

![BTC204](assets/fr/144.webp)

在這個 `Tx0` 交易的範例中，來自**存款**帳戶的 `372,000 Sats` 輸入被分割成幾個輸出 UTXO，細分如下：


- 5,000Sats`的金額為協調員的服務費，相對應的匯集條目為`100,000Sats`；
- 3 個準備混合的 UTXO，重新導向到我們的 **premix** 帳戶，並在協調員處註冊。這些 UTXOs 每個均等為 `108,000 Sats`，以支付其未來初始混合的 Mining 成本；
- 因數量太少而無法進入池中的盈餘會被視為有毒的外來 Exchange。它被送到其特定帳戶。在此，此 Exchange 為 `40,000 Sats` ；
- 最後，還剩下`3,000 Sats`，這並不構成輸出，而是確認`Tx0`所需的 Mining 成本。

例如，這裡有一個真實的 Whirlpool Tx0 (不是我的)：[edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46](https://Mempool.space/fr/tx/edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46)

![BTC204](assets/fr/145.webp)

### 毒性變化

無法整合到池中的盈餘（在此相當於`40,000 Sats`）會被轉移到**壞銀行**帳戶，也稱為 "doxxic Exchange"，以確保與投資組合中的其他 UTXO 嚴格分離。

這個 UTXO 對使用者的機密性而言是很危險的，因為它不只仍依附於它的過去，因此也可能依附於它的擁有者的身分，而且它也被記下來是屬於一個已經製作了 CoinJoin 的使用者。

![BTC204](assets/fr/146.webp)

如果將 UTXO 與混合輸出合併，後者將喪失在 CoinJoin 循環過程中獲得的所有機密性，這主要是由於 CIOH (*Common-Input-Ownership-Heuristic*) 所致。如果它與其他 doxxic 變更合併，使用者就有失去機密性的風險，因為它會連結各種 CoinJoin 週期項目。因此應該謹慎處理。我們會在本章最後一節詳細說明如何管理這些 UTXOs doxxic。

### 初始組合

在 `Tx0` 之後，均衡後的 UTXO 將傳送至我們組合的 **premix** 帳戶，準備進入其第一個 CoinJoin 週期，也稱為 「初始混合」。如果在我們的範例中，`Tx0`產生多個UTXO進行混合，每個UTXO都會被整合到單獨的初始混合中。

在這些第一次混合結束時，**premix** 帳戶將會是空的，而我們的錢幣在支付了這第一次 CoinJoin 的 Mining 費用後，將會完全調整為所選池所定義的金額。在我們的例子中，我們的初始 UTXOs `108,000 Sats` 將會正好減少到 `100,000 Sats`。

![BTC204](assets/fr/147.webp)

### 混音

初始混音之後，UTXOs 會被轉移到 **postmix** 帳戶。此帳戶收集已混音的 UTXO 和等待再混音的 UTXO。當 Whirlpool 客戶啟動時，位於 **postmix** 帳戶中的 UTXO 將自動可供重新混音，並會隨機抽取參與這些新週期。

提醒一下，混音是 100% 免費的：不需要額外的服務費或 Mining 費用。因此，將 UTXOs 保留在 ** 後混合 ** 帳戶中可保持其價值不變，並同時提高其匿名性。這就是為什麼允許這些錢幣參與多次 CoinJoin 循環的重要性。這完全不花您一分錢，而且還能提高它們的匿名等級。

當您決定使用混合的 UTXO 時，您可以直接從這個 **postmix** 帳戶使用。我們建議您將混合 UTXO 保留在此帳戶中，以享受免費混音，並防止其離開 Whirlpool 電路，從而降低其保密性。

### 您如何管理您的後混音？

在執行 CoinJoin 循環之後，最好的策略是將您的 UTXO 保留在 **postmix** 帳戶中，等待未來使用。甚至建議您讓它們無限期地再混合，直到您需要使用它們為止。

有些使用者可能會考慮將混合的 bitcoins 轉移到由 Hardware Wallet 保護的 Wallet。這是有可能的，但重要的是要嚴格遵循 Samourai Wallet 的建議，以免影響獲得的機密性。

合併 UTXOs 是最常見的錯誤。為了避免 CIOH（*Commun-Input-Ownership-Heuristic*），您必須避免在同一筆交易中將混合的 UTXO 與未混合的 UTXO 合併。這需要在您的投資組合內小心管理您的 UTXO，特別是在標籤方面。

![BTC204](assets/fr/148.webp)

在整合混合 UTXO 時也必須小心。如果您的混合 UTXOs 有顯著的異集，則可以進行適度的合併，但這將不可避免地降低零件的機密性。請確保合併既不要太廣泛，也不要在重新混合次數不足後進行，以免在 CoinJoin 循環之前和之後的 UTXO 之間建立可推斷的連結。如果對這些操作有疑問，最好的做法是不要合併混音後的 UTXO，而是將它們逐一轉移到 Hardware Wallet，每次都產生一個新的空白 Address。再次提醒您，請記得標示您收到的每個 UTXO。

此外，也不建議您使用未廣泛使用的腳本，將您的後混合 UTXOs 轉移到 Wallet。舉例來說，如果您使用 `P2WSH` 腳本從 Multisig Wallet 輸入 Whirlpool，您與其他原本擁有相同類型 Wallet 的使用者混合的機會就很小。如果您將您的postmixes重新混合到這個相同的Multisig Wallet，您混合後的比特幣的保密程度將會大大降低。除了腳本之外，還有許多其他的 Wallet 指紋可以在您身上做手腳。

與任何 Bitcoin 交易一樣，同樣重要的是不要重複使用接收的 Address。每筆新交易都必須使用新的、空白的 Address 來接收。

最簡單、最安全的解決方案是將混合後的 UTXOs 放在其 **postmix** 帳戶中休息，讓它們重新混合，只在花費時才碰觸它們。Samurai 和 Sparrow 錢包具有針對所有這些連鎖分析風險的額外保護功能。這些保護措施可協助您避免犯錯。

### 您如何管理毒性交流？

接下來，您需要小心管理有毒的 Exchange，也就是沒有進入 CoinJoin 池的 Exchange。這些因使用 Whirlpool 而產生的有毒 UTXOs 會對您的隱私造成風險，因為它們會在您和 CoinJoin 使用者之間建立連結。因此，必須小心管理，不要將它們與其他 UTXOs 結合，尤其是混合的 UTXOs。

以下是一些使用策略：


- 將其混合到較小的水池中：** 如果您的有毒 UTXO 夠大，可以單獨放入較小的水池中，請考慮將其混合。這通常是最好的選擇。但是，將幾個有毒的 UTXO 合併進入一個池子並不可取，因為這可能會將您的不同條目連結起來；
- 將它們標示為「不可花費」：** 另一種方法是停止使用，在專用帳戶中將它們標示為「不可花費」，並只使用 HODL。這樣可以確保您不會不小心花掉它們。如果 Bitcoin 的價值上升，可能會出現更適合您的有毒 UTXOs 的新池；
- 捐款：** 請考慮捐款給開發 Bitcoin 和相關軟體的開發人員，無論捐款多少。您也可以捐款給接受 BTC 的協會。如果管理您的有毒 UTXO 看起來太複雜，您可以直接丟掉它們，然後捐獻；
- 購買禮物卡：** [Bitrefill](https://www.bitrefill.com/) 等平台允許您用 Exchange 比特幣換取可在不同商家使用的禮物卡。這可以讓您在不損失相關價值的情況下，捨棄有毒的 UTXOs；
- 在 Monero 上整合它們：** Samourai Wallet 提供 BTC 和 XMR 之間的原子交換服務。這是管理有毒 UTXOs 的理想選擇，您可以將其整合到 Monero 上，而不會透過 CIOH 洩露您的機密性，然後再將其發送回 Bitcoin。然而，由於流動性的限制，此選項在 Mining 費用和溢價方面可能成本高昂；
- 傳送至Lightning Network:**將這些UTXO傳送至Lightning Network，以享受交易費用的降低，可能是一個很有吸引力的選擇。然而，此方法可能會透露某些資訊，這取決於您如何使用Lightning，因此應謹慎使用。

### 如何使用 Whirlpool？

在 Samourai Wallet 的創始人於 2024 年 4 月 24 日被捕並其伺服器被扣押之後，Whirlpool 工具已無法使用，即使是擁有自己道場的人也無法使用。在此之前，它可在 Samourai Wallet 和 Sparrow Wallet 上使用。

![BTC204](assets/fr/149.webp)

不過，視乎試驗結果，這項工具仍有可能在未來幾週內重新啟動，或以不同的方式重新推出。無論如何，我不認為 Bitcoin CoinJoin 市場會長期缺乏 Supply，因為需求是存在的。更重要的是，由於 Whirlpool 的機型在機密性方面是最先進的，因此未來一定會成為其他實作的首選機型。

我們正密切注意此案例及相關工具的發展。請放心，我們會在有新資訊時更新本訓練課程。

在下一章中，我們會瞭解什麼是「anonsets」、這些指標是如何計算出來的，以及它們如何幫助我們估計 CoinJoin 循環的效率。

https://planb.network/tutorials/privacy/on-chain/coinjoin-sparrow-wallet-84def86d-faf5-4589-807a-83be60720c8b
https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/tutorials/privacy/on-chain/coinjoin-dojo-c4b20263-5b30-4c74-ae59-dc8d0f8715c2
## 匿名套裝

<chapterId>be1093dc-1a74-40e5-9545-2b97a7d7d431</chapterId>

在研究了共同接合如何運作以及有效混合所涉及的問題後，我們現在要找出如何衡量其有效性。我們該如何判斷共同接合程序是否有效，以及某個部分所取得的匿名程度為何？這就是我們要在本章利用匿名集或 "anonsets "找出答案的地方。

### 提醒 CoinJoin 的效用

CoinJoin 的效用在於它能夠產生似是而非的隱匿性，將您的部分嵌入一群無法區分的部分中。這個動作的目的是要打破可追蹤性的連結，無論是從過去到現在，或是從現在到過去。

換句話說，知道您在 CoinJoin 循環進入時的初始交易 (`Tx0`)的分析師，應該無法確定您在 remix 循環退出時的 UTXO (循環進入到循環退出分析)。

![BTC204](assets/fr/150.webp)

反過來說，在 CoinJoin 週期的出口處知道您的 UTXO 的分析師一定無法確定在週期入口處的原始交易（週期出口到週期入口分析）。

![BTC204](assets/fr/151.webp)

要評估分析師將過去與現在聯繫起來的難度有多大，反之亦然，我們需要量化您的部分所隱藏的同質部分群組的大小。這個量度可以告訴我們有多少分析具有相同的機率。因此，如果正確的分析淹沒在其他 3 個機率相同的分析中，您的隱藏程度就非常低。另一方面，如果正確的分析在 20,000 個相同機率的分析群組中被發現，您的部分就隱藏得非常好。這些群組的大小代表稱為「anonsets」的指標。

### 瞭解不動產設定

Anonsets 可作為評估特定 UTXO 機密程度的指標。更明確地說，它們量測包含研究部分的集合中無法區分的 UTXOs 數量。對於同質 UTXOs 集的要求意味著，保密集通常以 CoinJoin 週期來計算。這些指標的使用對 Whirlpool 共同接合尤其相關，因為它們具有均一性。

如有必要，可以使用匿名集來判斷共同接合的品質。大的匿名集意味著高層級的匿名性，因為在同質集中很難分辨出特定的 UTXO。

存在 2 種類的 anonsets：


- 前瞻性的anonset ;**
- 回顧anonset.**

### 未來的不發作

前瞻度量指標 (forward-looking anonset) 表示在週期結束時所研究的 UTXO 在開始時的 UTXO 的基礎上，所隱藏的群組大小，也就是在這個群組中存在的不可區分部分的數量。此指標的名稱為 「前瞻性指標」。

此指標量度房間機密性對過去到現在（輸入到輸出）分析的抵抗力。

![BTC204](assets/fr/152.webp)

這個指標用來估計您的 UTXO 在多大程度上受到保護，不會有人試圖重建其從進入 CoinJoin 流程到退出 CoinJoin 流程的歷史。

例如，如果您的交易已經參與了第一個 CoinJoin 週期，並且已經完成了兩個遞減週期，那麼您的硬幣的潛在 anonset 將會是 `13` ：

![BTC204](assets/fr/153.webp)

舉例來說，假設我們的硬幣在 CoinJoin 週期的一開始，其預定的取消時間為 `86,871`。實際上，這表示它隱藏在 `86,871` 個無法區分的部分中。對於外部觀察者來說，如果他知道這枚硬幣在 CoinJoin 週期開始時的情況，並試圖追蹤它的出口，他將會面對 `86,871` 個可能的 UTXO，每個都有相同的機率是他要找的硬幣。

![BTC204](assets/fr/154.webp)

### 溯及既往

回溯保密性表示在週期結束時，UTXO 所知道的特定零件可能來源的數量。這個指標量度零件的保密性對現在到過去（輸出到輸入）分析的阻力，也就是在 CoinJoin 循環之前，分析師要追溯您的零件來源有多困難。這個指標的名稱是 "backward anonset「 或 」backward-looking metrics"。

![BTC204](assets/fr/155.webp)

藉由知道您在週期結束時的 UTXO，回溯溯算會決定可能構成您進入 CoinJoin 週期的潛在 Tx0 交易數量。在下圖中，這相當於所有橙色氣泡的總和。

![BTC204](assets/fr/156.webp)

舉例來說，假設我們的 CoinJoin 零件有`42,185`的追溯時效。實際上，這表示這枚 UTXO 有 `42,185` 個潛在來源。如果外部觀察者在週期結束時發現這枚硬幣，並試圖追溯其來源，他或她將會面對 `42,185` 個可能的來源，所有這些來源都有相同的可能性成為所尋找的來源。

![BTC204](assets/fr/157.webp)

### 如何計算 anonsets？

使用 Block explorer 人工計算小集合的 anonsets 是可行的。然而，對於較大的 anonsets，就必須使用專門的工具。據我所知，唯一能執行這項任務的軟體是 *Whirlpool Stats Tool*，這是由 Samourai 和 OXT 團隊開發的 Python 工具。不幸的是，在 Samourai 的創辦人被捕以及 OXT 中斷後，這個工具目前已停止使用，而 OXT 則是用來擷取 Blockchain 的資料。

![BTC204](assets/fr/158.webp)

正如我們在本章所看到的，只有在 CoinJoin 結構具有一定同质性的情況下，才能計算出 anonsets。在下一章中，我們將發現如何在 Bitcoin 交易上量化這種同質性，無論是 CoinJoin 還是更傳統的交易。

https://planb.network/tutorials/privacy/analysis/wst-anonsets-0354b793-c301-48af-af75-f87569756375
## 熵

<chapterId>e4fe289d-618b-49a2-84c9-68c562e708b4</chapterId>

正如我們在本節關於合併的部分所看到的，UTXOs 在輸入和輸出上的同質性對於提高 Bitcoin 交易的保密性起著重要的作用。這個參數在 Blockchain 分析面前創造了一個似是而非的可抵賴性。有幾種方法可以用來測量這種同質性，但我認為最有效的方法之一，是使用由 OXT 和 Samourai Wallet 團隊開發的 *Boltzmann* 工具所提供的指標，尤其是交易的熵。這就是我們在本章要詳細研究的內容。

與根據一組交易計算的 anonsets 不同，這裡提出的指標著重於單一交易，不論是 CoinJoin 或更傳統的交易。

### 解釋的數量

在 Bitcoin 交易上可以觀察到的第一個指標，是面對外部觀察者分析時可能的詮釋總數。考慮到交易中涉及的 UTXO 的值，這個指標顯示了輸入與輸出相關聯的方式的數量。換句話說，它決定了從外部觀察者分析的角度來看，交易在 Bitcoin 流量中可能引起的解釋數量。

例如，有 1 個輸入和 2 個輸出的簡單付款交易只有一種解釋，即輸入 #0 資助了輸出 #0 和輸出 #1。沒有其他可能的解釋：

![BTC204](assets/fr/159.webp)

另一方面，一個 Whirlpool 5x5 角有 $1\,496$ 的可能組合：

![BTC204](assets/fr/160.webp)

一個 Whirlpool Surge Cycle 8x8 CoinJoin 有 $9\,934\,563$ 的可能解釋：

![BTC204](assets/fr/161.webp)

### 熵

從 Bitcoin 交易的詮釋數量，我們可以計算出它的熵。

在密碼學和資訊的一般情況下，熵是一種量度與資料來源或隨機過程相關的不確定性或不可預測性的定量方法。換句話說，熵是量度一條資訊有多難以預測或猜測的一種方式。

在 Blockchain 分析的特定情況下，熵也是一個指標的名稱，源自香儂的熵，[由 LaurentMT 發明](https://gist.github.com/LaurentMT/e758767ca4038ac40aaf)，可以在 Bitcoin 交易上計算。

當交易出現大量可能的解釋時，參考其熵通常更有意义。這個指標量度分析師對交易的確切配置缺乏瞭解。換句話說，熵越高，分析師越難辨識比特幣在輸入和輸出之間的流動。

實際上，熵顯示了從外部觀察者的觀點來看，交易是否僅基於輸入和輸出金額，而沒有考慮其他外部或內部模式和啟發式方法，就提出了多種可能的解釋。因此，高熵等同於更高的交易保密性。

熵的定義為可能組合數的二進位對數。以下是使用的公式，其中 $E$ 是交易的熵，$C$ 是可能的解釋數：

$$
E = \log_2(C)
$$

在數學中，二進位對數 (base-2 logarithm) 是 2 的幂運算的逆運算。換句話說，$x$ 的二進位對數是為了得到 $x$，必須將 $2$ 提升到的指數。因此，這個指標是以位元來表示的。

讓我們以根據 Whirlpool 5x5 模型結構的 CoinJoin 交易的熵計算為例，如上一節所述，該交易的可能解釋數為 $1\,496$ ：

$$
\begin{align*}
C &= 1\,496 \\
E &= \log_2(1\,496) \\
E &= 10.5469 \text{ bits}
\end{align*}
$$

因此，這筆 CoinJoin 交易的熵值為 $10.5469$ 位元，相當令人滿意。此值越高，交易可接受的不同解釋就越多，從而加強了其保密性。

對於有 $9,934\,563$ 詮釋的 CoinJoin 8x8 交易，熵為 ：

$$
\begin{align*}
C &= 9\,934\,563 \\
E &= \log_2(9\,934\,563) \\
E &= 23.244 \text{ bits}
\end{align*}
$$

讓我們以另一個典型的付款交易為例，有 1 個輸入和 2 個輸出：[1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce](https://Mempool.space/tx/1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce)

![BTC204](assets/fr/162.webp)

對於這個交易，唯一可能的解釋是：`(In.0) > (Out.0 ; Out.1)`。因此，其熵為 $0$ ：

$$
\begin{align*}
C &= 1 \\
E &= \log_2(1) \\
E &= 0 \text{ bits}
\end{align*}
$$

### 效率

根據交易的熵，我們也可以計算其保密效率。此指標可將交易與相同配置下的最佳交易進行比較，從而評估交易的效率。

這帶給我們最大熵的概念，它對應於特定交易結構理論上可以達到的最高熵。然後透過比較此最大熵與所分析交易的實際熵來計算交易效率。

使用的公式如下，其中 ：


- e_R$：交易的實際熵，以位元表示；
- e_M$：交易結構的最大可能熵，也以位元表示；
- $Ef$：交易效率，以位元為單位 ：

$$
Ef = E_R - E_M
$$

例如，對於 Whirlpool 5x5 CoinJoin 結構，最大熵為 $10.5469$ ：

$$
\begin{align*}
E_R &= 10.5469 \\
E_M &= 10.5469 \\
Ef &= E_R - E_M \\
Ef &= 10.5469 - 10.5469 \\
Ef &= 0 \text{ bits}
\end{align*}
$$

此指標也以百分比表示。使用的公式如下：:


- c_R$ : 可能的實數解釋數 ；
- c_M$：同一結構可能的最大解釋數；
- $Ef$：以百分比表示的效率：

$$
\begin{align*}
E_f &= \frac{C_R}{C_M} \\
E_f &= \frac{1\,496}{1\,496} \\
E_f &= 100 \%
\end{align*}
$$

效率達到 100 美元，表示交易已充分發揮其保密潛力，視其結構而定。

### 熵密度

熵是衡量交易保密性的良好指標，但它部分取決於交易中的輸入和輸出數量。若要比較具有不同輸入和輸出數量的 2 個不同交易的熵，我們可以計算熵密度。此指標可讓我們透視相對於交易中每個輸入或輸出的熵。密度有助於評估和比較不同規模的交易效率。

要計算它，我們只需將交易的總熵除以交易中涉及的輸入和輸出總數：


- e_D$：以位元表示的熵密度；
- e$：交易的熵，以位元表示；
- t$：交易中輸入和輸出的總數：

$$
E_D = \frac{E}{T}
$$

讓我們以 Whirlpool 5x5 CoinJoin 為例：

$$
\begin{align*}
T &= 5 + 5 = 10 \\
E &= 10.5469 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{10.5469}{10} \\
E_D &= 1.054 \text{ bits}
\end{align*}
$$

我們也來計算一下 8x8 Whirlpool CoinJoin 的熵密度：

$$
\begin{align*}
T &= 8 + 8 = 16 \\
E &= 23.244 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{23.244}{16} \\
E_D &= 1.453 \text{ bits}
\end{align*}
$$

透過分析這兩種類型的 CoinJoin 的熵密度，我們可以清楚地看出，即使將熵以 Elements 的數量歸一化，「Surge Cycle 8x8」的 CoinJoin 也會為分析帶來更多的不確定性。

### 波爾茲曼分數

交易中分析的另一項資訊是每個元素相對於另一個元素的 Boltzmann 分數。這是輸入和輸出之間的匹配概率表。這個表格透過 Boltzmann 分數顯示特定輸入與特定輸出連結的條件概率。因此，它是交易中輸入和輸出之間發生關聯的條件概率的定量測量，其基礎是在一組詮釋中，此事件的有利發生次數與可能發生的總次數的比率。

以 Whirlpool CoinJoin 為例，條件概率表會強調每個輸入和輸出之間的連結機會，提供交易中關聯模糊性的定量測量：

| 輸出 0 輸出 1 輸出 2 輸出 3 輸出 4

| ------- | -------- | -------- | -------- | -------- | -------- |

| 輸入 0 | | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% |

| 輸入 1 | 34% | 34% | 34% | 34% | 34% | 34% | 輸入 1

| 輸入 2 | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34

| 輸入 3 | 34% | 34% | 34% | 34% | 34% | 34% | 輸入 3

| 輸入 4 | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34% | 34

很明顯，每項輸入都有同等機會與任何輸出相關聯，這加強了交易的機密性。

Boltzmann 分數的計算方式是將發生特定事件的詮釋數目除以可用的詮釋總數。因此，若要確定輸入 #0 與輸出 #3（事件出現在 512$ 種解釋中）相關的分數，我們的步驟如下：

$$
\begin{align*}
\text{Interpretations (IN.0 > OUT.3)} &= 512 \\
\text{Interpretations totales} &= 1496 \\
\text{Score} &= \frac{512}{1496} \\
\text{Score} &= 34 \%
\end{align*}
$$

如果我們以 Whirlpool 8x8 Surge Cycle CoinJoin 為例，Boltzmann 表會如下所示：

| 輸出.0 | 輸出.1 | 輸出.2 | 輸出.3 | 輸出.4 | 輸出.5 | 輸出.6 | 輸出.7 |

|-------|-------|-------|-------|-------|-------|-------|-------|-------|

| in.0 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| in.1 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| in.2 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| in.3 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| in.4 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| in.5 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| in.6 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| in.7 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

但是，如果是單一輸入和 2 個輸出的簡單交易，情況就不同了：

| 輸出 0 輸出 1

|---------|----------|----------|

| 輸入 0 | 100% | 100% |

在這裡，我們可以看到每項輸出源自輸入 #0 的機率是 100%。因此，較低的機率反映了較高的機密性，淡化了輸入和輸出之間的直接關聯。

### 確定連結

我們也可以計算交易中確定性連結的數量。這個指標顯示在分析的交易中，有多少輸入和輸出之間的連結是無庸置疑的，機率是 100% 。這個指標可以透過計算確定性連結的比率來完成。這個比率提供了這些確定性連結在交易總連結中的比重。

例如，Whirlpool CoinJoin 交易的輸入和輸出之間沒有確定的連結，因此顯示的指標是 0 連結和 0% 的比率。相反地，在我們檢查的第二個簡單付款交易（有一個輸入和兩個輸出）中，指標告訴我們有兩個確定連結，比率達到 100%。換句話說，由於輸入和輸出之間沒有直接且無可爭議的連結，指標為 0 表示保密性極佳。

### 如何計算這些指標？

使用我提供的公式手動計算這些指標相對簡單。困難主要在於確定交易的可能詮釋數量。對於傳統的交易，這個計算可以手動完成。但對於 CoinJoin，這項任務就複雜得多。

在此之前，有一個由 OXT 和 Samourai 團隊開發的 Python 工具 _Boltzmann Calculator_，可以自動計算 Bitcoin 交易的所有這些指標：

![BTC204](assets/fr/163.webp)

也可以使用 KYCP.org 網站進行這些分析：

![BTC204](assets/fr/164.webp)

不幸的是，在 Samourai 的創辦人被捕後，這些工具已無法運作。

現在我們已經詳細介紹了硬幣接合，在課程的最後一部分，我們將探討 Bitcoin 上的其他隱私技術。我們將探討 payjoins、特定的偽 CoinJoin 交易類型、靜態 Address 協定，以及不是在交易本身層級，而是在節點網路層級強化機密性的措施。

https://planb.network/tutorials/privacy/analysis/boltzmann-entropy-738e45af-18a6-4ce6-af1a-1bf58e15f1fe
# 瞭解其他先進保密技術的挑戰

<partId>19989ae6-d608-4acf-b698-2cf1e7e5e6ae</partId>

## PayJoin 交易

<chapterId>c1e90b95-f709-4574-837b-2ec26b11286f</chapterId>

CoinJoin 是目前在連鎖分析中，將不確定性導入零件追蹤的最有效方法。正如我們在前幾章所看到的，要獲得高效能的組合，輸入和輸出必須盡可能的同質。此外，重要的是零件要整合成盡可能大的群組，以最大化共集。因此，為了讓共同接合有效，它們必須涉及大量統一的零件。如此多的要求意味著 CoinJoin 交易有一個非常嚴格的結構：金額是事先固定好的，所有參與者都必須遵守，以保證過程的一致性。此外，在交易建構過程中，coinjoins 需要所有參與者與協調者同步。

這些要求使得 CoinJoin 不適合直接支付。例如，如果您在 CoinJoin 池中有 100 萬個 Sats 硬幣，直接用它來付款會很複雜。它需要與其他參與者和協調器同步，在您需要付款的那一刻精確地建立協作交易，而且購買金額必須與您的錢幣價值完全對應，這幾乎是不可行的。因此，CoinJoin 交易就其本質而言是一種協同掃描交易，也就是通常我們在輸出中找到的輸入的所有者是相同的。

然而，如果交易結構能夠以實用的方式進行支付，同時又能在連鎖分析中引入疑點，那將是一件非常有趣的事情。這正是我們在本章和下一章所要探討的。

### 什麼是 PayJoin 交易？

PayJoin 是特定的 Bitcoin 交易結構，可透過與付款收款人合作，加強使用者消費時的隱私權。

LaurentMT 在 2015 年首次將這種方法稱為「*steganographic transactions*」，根據一份可存取 [here](https://gist.githubusercontent.com/LaurentMT/e758767ca4038ac40aaf/raw/c8125f6a3c3d0e90246dc96d3b603690ab6f1dcc/gistfile1.txt) 的文件。該技術隨後被 Samourai Wallet 採用，並於 2018 年成為第一個使用 Stowaway 工具實現該技術的客戶。PayJoin 的概念也可以在 [BIP79](https://github.com/Bitcoin/bips/blob/master/bip-0079.mediawiki) 和 [BIP78](https://github.com/Bitcoin/bips/blob/master/bip-0078.mediawiki) 中找到。有幾個詞語用來指定 PayJoin：


- PayJoin ；
- 偷渡者
- P2EP（*付費到終點*） ；
- 隱藏交易。

PayJoin 的特點在於它能夠 generate 一種乍看之下很普通的交易，但實際上是兩個人之間的迷你 CoinJoin。為了達到這個目的，交易結構讓收款人與實際寄款人一起參與輸入。因此，收款人在交易中間包含了對自己的付款，這本身就使他能夠得到付款。

讓我們舉一個例子來更好地理解這個過程。Alice 用 10,000 Sats 的 UTXO 買了一根 4,000 Sats 的法棍，並選擇了 PayJoin。她的麵包師傅包博將屬於他的 15,000 Sats 的 UTXO 作為輸入，除了愛麗絲的 4,000 Sats 外，他還將這些 UTXO 全數收回作為輸出。

![BTC204](assets/fr/165.webp)

在這個例子中，麵包師鮑勃輸入 15,000 Sats，輸出 19,000 Sats，差額正好是 4,000 Sats，也就是長棍麵包的價格。在 Alice 這邊，她輸入 10,000 Sats，最後輸出 6,000 Sats，餘額為-4,000 Sats，也就是長棍的價格。為了簡化範例，我刻意省略了這筆交易中的 Mining 成本。

### PayJoin 用來做什麼？

PayJoin 交易可達成兩個目標，讓使用者加強付款的保密性。

首先，PayJoin 旨在透過在連鎖分析中製造誘惑來誤導外部觀察者。這是由 CIOH 啟發式 (*Common Input Ownership Heuristic*) 所促成的。正如我們在第三部分所看到的，通常，當 Blockchain 上的交易有幾個輸入時，會假定所有這些輸入都屬於同一個實體或使用者。

因此，當分析師檢查 PayJoin 交易時，他或她會相信所有的輸入都是來自同一個人。然而，這種觀念是錯誤的，因為收款人也與實際付款人一起參與了輸入。因此，連鎖分析會轉向錯誤的詮釋。

讓我們以支付長棍麵包的 PayJoin 交易為例：

![BTC204](assets/fr/166.webp)

看到 Blockchain 上的這筆交易，外部觀察者按照 Blockchain 分析的一般啟發式方法會做出以下解釋：「*Alice 合併了 2 個 UTXO 作為交易的輸入，以支付 19,000 Sats 給 Bob*」。

![BTC204](assets/fr/167.webp)

這個解釋顯然是錯誤的，因為您已經知道，輸入中的兩個 UTXO 並不屬於同一個人。一個來自法棍買主 Alice，另一個來自麵包師 Bob。

![BTC204](assets/fr/168.webp)

如此一來，外部觀察者的分析就會被導向錯誤的結論，確保利益相關者的機密性。

### 隱藏交易

PayJoin 的第二個目的是誤導外部觀察者，讓他們不知道實際支付的金額。透過檢查交易的結構，分析師可能會相信付款等於其中一項輸出的金額。

如果我們回到購買法棍的例子，分析師會認為付款金額對應於 6,000 Sats 的 UTXO 或 19,000 Sats 的 UTXO。在這種情況下，分析師寧願認為付款金額是 19,000 Sats，因為輸出中有 2 個 UTXO，其中至少有一個大於 6,000 Sats（沒有邏輯理由使用 2 個 UTXO 來支付 6,000 Sats，因為單單一個 UTXO 就足以滿足這筆付款）。

![BTC204](assets/fr/169.webp)

但實際上，這種分析是有缺陷的。支付金額與任何產出都不對應。它實際上是收款人的 UTXO 產出與收款人的 UTXO 投入之間的差額。

![BTC204](assets/fr/170.webp)

在這方面，PayJoin 交易屬於隱藏術的範疇。它可以將交易的真實金額隱藏在作為誘餌的偽造交易中。

隱含技術（Steganography）是一種將資訊隱藏在其他資料或物件中，使人無法察覺隱藏資訊存在的技術。例如，可以將秘密訊息隱藏在不相關的文字中的一個點中，使肉眼無法察覺（這就是 [microdot](https://fr.wikipedia.org/wiki/Micropoint)技術）。

加密技術會在沒有解密金鑰的情況下使資訊變得難以理解，而隱匿技術則不同，它不會修改資訊。它仍然以明文顯示。相反，它的目的是隱藏秘密訊息的存在，而加密則明顯揭示了隱藏資訊的存在，儘管沒有密鑰是無法獲取的。這就是為什麼 PayJoin 的原名是「隱藏交易」。

我們可以將密碼學與 CoinJoin 相提並論，也可以將隱匿學與 PayJoin 相提並論。CoinJoin 具有類似加密的屬性：方法是可辨認的，但資訊是無法破譯的。相反地，PayJoin 則類似於隱藏術：理論上資訊是可以取得的，但由於隱藏的方法無法辨認，因此資訊變得無法取得。

### 如何使用 PayJoin？

支援 PayJoin 的知名軟體程式包括 Sparrow Wallet、Wasabi Wallet、Mutiny、BitMask、BlueWallet 和 JoinMarket，以及支付處理商 BTCPay。

![BTC204](assets/fr/171.webp)

最先進的 PayJoin 實作只有 Samourai Wallet 上的 Stowaway。不過，自從軟體創辦人被捕後，這個工具現在只剩下部分功能。Stowaway 的優點在於它是一個全面、易用的協定，同時支援接收和傳送 payjoins。部分簽章交易可透過掃描幾個 QR 代碼手動交換，或透過 Soroban 由 Tor 自動交換。後一種通訊方式目前已停止服務。

![BTC204](assets/fr/172.webp)

使用 PayJoin 的困難在於它依賴商家的參與。作為客戶，如果商家不支持 PayJoin，您就無法使用。這就給購買過程增加了更多的困難：不僅很難找到接受 Bitcoin 的商家，如果還要找那些支持 payjoins 的商家，那就更複雜了。

其中一個解決方案是使用交易結構，在不需要收款人合作的情況下，將模糊性引入連鎖分析。這將使我們能夠提高支付的保密性，而無需依賴商家的積極參與。這正是我們在下一章要探討的。

https://planb.network/tutorials/privacy/on-chain/payjoin-sparrow-wallet-087a0e49-61cd-41f5-8440-ac7b157bdd62
https://planb.network/tutorials/privacy/on-chain/payjoin-samourai-wallet-48a5c711-ee3d-44db-b812-c55913080eab
## 付款 mini-CoinJoin

<chapterId>300777ee-30ae-43d7-ab00-479dac3522c1</chapterId>

當您想要進行付款交易，同時又要保持一定的機密性時，PayJoin 是一個不錯的選擇。但正如我們剛才所見，PayJoin 需要收款人的參與。如果收款人拒絕參與 PayJoin，或者您根本不想讓他們參與，該怎麼辦？一種替代方法是使用石牆或石牆 x2 交易。讓我們仔細看看這兩種交易。

### 石牆交易

Stonewall 是一種特殊形式的 Bitcoin 交易，旨在透過模仿兩個人之間的偽 CoinJoin 來增加使用者消費時的機密性，但實際上卻不是兩個人。事實上，這種交易不是協作性的。使用者可以自己建立，只使用自己擁有的 UTXO 作為輸入。因此，您可以在任何場合建立石牆交易，而不需要與其他使用者或收件人同步。

石牆交易的運作方式如下：作為交易的輸入，發行者使用 2 個屬於他的 UTXO。輸出時，交易產生 4 個 UTXO，其中 2 個的金額完全相同。另外 2 個 UTXO 將構成外幣 Exchange。在 2 個相同金額的輸出中，只有一個會實際到達收款人手中。

所以在石牆交易中只有 2 個角色：


- 發卡機構，進行支付......；
- 收件人可能不知道交易的具體性質，只是期望從寄件人處付款。

讓我們舉一個例子來了解這種交易結構。Alice 去麵包師傅 Bob 處買她的法棍，價格是 4,000 Sats。她想用比特币支付，同时对她的付款保持某种形式的保密。所以她決定建立一個石牆交易來支付。

![BTC204](assets/fr/173.webp)

透過分析這筆交易，我們可以看到麵包師傅 Bob 實際收到 4,000 Sats 的長棍付款。Alice 使用 2 個 UTXO 作為輸入：一個 10,000 Sats 和一個 15,000 Sats。在輸出中，她收回了 3 個 UTXO：一個 4,000 Sats，一個 6,000 Sats 和一個 11,000 Sats。因此，Alice 在這筆交易中的淨餘額為 -4,000 Sats，相當於長棍麵包的價格。

在這個例子中，我刻意忽略了 Mining 的費用，以方便理解。實際上，交易費用完全由發行商承擔。

### 石牆交易的目標是什麼？

石牆結構為交易增加了大量的熵，模糊了鏈式分析的界限。從外觀來看，這樣的交易可能會被解釋為兩個人之間的迷你 CoinJoin。但實際上，這是一種付款。因此，這種方法會造成連鎖分析的不確定性，甚至導致錯誤的線索。

讓我們以 Alice 在麵包師傅 Bob 家為例。Blockchain 上的交易會是這樣的：

![BTC204](assets/fr/174.webp)

外部觀察者依賴一般的連鎖分析啟發式可能會錯誤地得出「*兩個人做了一個小型的 CoinJoin，輸入各為一個 UTXO，輸出各為兩個 UTXO*」的結論。從外部分析這筆交易並不會導致 CIOH 的應用，因為兩筆相同金額的輸出的存在顯示出 CoinJoin 的模式。因此，從外部觀點來看，CIOH 不適用於此特定情況。

![BTC204](assets/fr/175.webp)

這個解釋並不準確，因為大家都知道，有一個 UTXO 傳送給鮑勃，2 個 UTXO 輸入來自愛麗絲，而她恢復了 3 個 Exchange 輸出。

![BTC204](assets/fr/176.webp)

而石牆交易結構中特別有趣的是，從外部觀察者的角度來看，它在各方面都與石牆 x2 交易相似。

### 石牆交易 x2

石牆 x2 是另一種特定形式的 Bitcoin 交易，其目的也是在進行消費時增加使用者的機密性，但這次是透過與不參與該消費的第三人合作。這種方法就像兩個參與者之間的偽 CoinJoin，同時向第三者付款。

石牆 x2 交易的操作相對簡單：我們使用自己擁有的 UTXO 來付款，並尋求第三方的協助，而第三方也使用屬於自己的 UTXO 來付款。交易最後會有四個輸出：其中兩個是等額的，一個是給收款人的 Address，另一個是給屬於合作者的 Address。第三個 UTXO 返回到屬於合作者的另一個 Address，使他能夠收回初始金額（對他來說是一個中性行為，模擬 Mining 成本），最後一個 UTXO 返回到屬於我們的 Address，構成付款 Exchange。

石牆 x2 交易中因此定義了三種不同的角色：


- 實際付款的發行人 ；
- 收件人可能不知道交易的具體性質，只是期望從寄件人處付款；
- 合作者，提供比特幣以對交易分析提出懷疑，同時在交易結束時全額收回其資金（對他而言是中性行為，模擬 Mining 成本）。

讓我們回到愛麗絲的例子，她在鮑勃麵包店買了一個長棍麵包，花了 4,000 Sats。她想用比特币支付，同时对她的付款保持一定的保密性。所以她找來了她的朋友 Charles，Charles 會在這個過程中幫助她。

![BTC204](assets/fr/177.webp)

分析這筆交易，我們可以看到麵包師鮑勃實際收到 4,000 Sats 的長棍付款。Alice 使用了 10,000 Sats 作為輸入，並收回了 6,000 Sats 作為輸出，也就是淨餘額為 -4,000 Sats，相當於長棍的價格。至於 Charles，他提供了 15,000 Sats 的輸入，並收到兩筆輸出：一筆是 4,000 Sats，另一筆是 11,000 Sats，因此餘額為 0。

在這個範例中，為了讓大家更容易理解，我故意省略了費用。實際上，Mining 費用通常由付款發行者和供款人平分。

### 石牆 x2 交易的目標是什麼？

和石牆結構一樣，石牆 x2 結構也為交易增加了大量的熵，混淆了鏈式分析。從外面看，這樣的交易可以解釋為兩個人之間的小 CoinJoin。但實際上，這是一種付款。因此，這種方法會造成連鎖分析的不確定性，甚至導致錯誤的線索。

讓我們以 Alice、Bob the Baker 和 Charles 為例。Blockchain 上的交易會是這樣的：

![BTC204](assets/fr/178.webp)

外部觀察者依賴一般的連鎖分析啟發式可能會得出錯誤的結論：「*Alice 和 Charles 進行了一次小型的 CoinJoin，輸入端各有一個 UTXO，輸出端各有兩個 UTXO*」。同樣地，從外部分析這筆交易並不會導致 ICOH 的應用，因為兩筆相同金額的輸出的存在顯示了 CoinJoin 的模式。因此，從外部觀點來看，CIOH 不適用於此特定情況。

![BTC204](assets/fr/179.webp)

這個解釋是不對的，因為大家都知道，有一個 UTXO 已經傳送給鮑勃，愛麗絲只有一個 Exchange 輸出，而查爾斯有兩個。

![BTC204](assets/fr/180.webp)

再一次，石牆 x2 交易結構特別有趣的地方是，從外部觀察者的角度來看，它在各方面都與石牆交易相似。

### 石牆和石牆 x2 有什麼不同？

StonewallX2 交易的工作原理與 Stonewall 交易完全相同，只是前者是協作式的，而後者不是。正如我們所看到的，Stonewall X2 交易涉及到第三方（Charles）的參與，他是支付的外部參與者，他將提供自己的比特幣來加強交易的保密性。在典型的石牆交易中，合作者的角色由發送者擔當。

![BTC204](assets/fr/181.webp)

從外部觀點來看，交易模式完全相同。

![BTC204](assets/fr/182.webp)

這兩種交易結構具有完全相同的模式，這意味著即使外部觀察者成功識別出 "Stonewall(x2) "模式，他也無法掌握所有資訊。他無法確定兩筆相同金額的 UTXO 中，哪一筆與付款相符。此外，他也無法確定這兩個有輸入的 UTXO 是否來自兩個不同的人（Stonewall x2），或這兩個 UTXO 是否屬於一個人，而這個人合併了這兩個 UTXO（Stonewall）。

最後一點是因為石牆 x2 交易與石牆交易的模式完全相同。從外觀來看，如果沒有額外的上下文資訊，就不可能區分石牆交易和石牆 x2 交易。前者不是合作交易，而後者則是。這讓其中一項交易的分析更添疑點。

### 石牆和石牆 x2 交易應在何時使用？

當您想要使用保密工具來處理某項支出時，邏輯應該如下：


- 作為優先順序，我們可以選擇製作 PayJoin；
- 如果商家不支援 payjoins，則可以使用石牆 x2 結構與付款之外的其他人進行協同交易；
- 如果您找不到人進行石牆 x2 交易，您可以只進行石牆交易，這會模仿石牆 x2 交易的行為。

### 如何使用石牆和石牆 x2 交易？

Stonewall 和 Stonewall x2 交易可在 Samourai Wallet 應用程式和 Sparrow Wallet 軟體上使用。

![BTC204](assets/fr/183.webp)

然而，與 payjoins 一樣，在 Samourai 的創始人被捕後，Stonewall x2 交易現在只能透過相關各方之間手動交換 PSBT 來進行。不幸的是，透過 Soroban 的自動 Exchange 已經無法使用。

也可以從任何 Bitcoin Wallet 軟體手動執行此類交易。

在下一章中，我們將介紹另一種相對陌生的保密技術，但作為我們已學過的知識的補充，它非常有用。

https://planb.network/tutorials/privacy/on-chain/stonewall-033daa45-d42c-40e1-9511-cea89751c3d4
https://planb.network/tutorials/privacy/on-chain/stonewall-x2-05120280-f6f9-4e14-9fb8-c9e603f73e5b
## 跳彈

<chapterId>db9a20ac-a149-443d-884b-ea6c03f28499</chapterId>

使用 Bitcoin 交易結構會增加連鎖分析的模糊性，例如 CoinJoin，特別有利於隱私權保護。然而，正如我們在 payjoins 章節所討論的，CoinJoin 交易在交易鏈上是自然可識別的。請記住我們在加密與硬幣接合之間所做的類比：當一個檔案被加密時，發現加密檔案的第三方無法存取其內容，但卻可以清楚地辨識出該檔案已被修改以隱藏其內容。這也適用於 CoinJoin：當分析師檢查 CoinJoin 交易時，雖然無法在輸入與輸出之間建立直接連結 (反之亦然)，但仍可辨識出所觀察到的交易是 CoinJoin。

根據您打算在 CoinJoin 循環之後如何使用您的零件，它已經過此程序的事實可能會造成問題。例如，如果您打算在受監管的 Exchange 平台上出售您的錢幣，但它最近經歷了一次 CoinJoin，則該平台的鏈分析工具將偵測到這一事實。這時平台可能會拒絕接受您的錢幣連鎖 UTXO，甚至要求您做出解釋，您的帳戶有可能被暫停或資金被凍結。在某些情況下，平台也可能會將您的行為上報給國家機關（例如 TRACFIN 對法國 PSAN 的要求就是如此）。

![BTC204](assets/fr/184.webp)

為了避免這種情況，我們需要一種工具，能夠模糊 Bitcoin 錢幣過去的痕跡，以恢復某種形式的可替代性。這正是回彈的目的。

![BTC204](assets/fr/185.webp)

### 什麼是跳彈？

回彈是一種技術，包括對自己執行幾個虛構的交易（掃描），以模擬 Bitcoin Ownership 的轉移。此工具與我們討論過的其他交易結構不同，它不是獲得前瞻性匿名，而是一種回溯性匿名。實際上，Ricochet 模糊了 Bitcoin 硬幣因其過去而可能損害其可替代性的特殊性。

為了撫平過去事件在硬幣上留下的印記，例如 CoinJoin 循環，ricochet 會執行四次連續交易，讓使用者在不同的地址將資金轉移給自己。

![BTC204](assets/fr/186.webp)

經過這一連串的交易後，蓖麻工具最後會將比特幣傳送到最終目的地，例如 Exchange 平台。

![BTC204](assets/fr/187.webp)

這樣做的目的是要建立影響硬幣可替代性的距離，例如 CoinJoin 的交易，以及最終的支出行為，可能會因為硬幣的過去而拒絕這枚硬幣。因此，連鎖分析工具可能會得出結論，在事件發生後，Ownership 可能有變更，並認為這枚錢幣是可替代的。在 CoinJoin 的情況下，Blockchain 分析工具就可以假設寄送比特幣和執行 CoinJoin 的不是同一人，因此對寄送者採取行動是沒有意義的。

![BTC204](assets/fr/188.webp)

### 為什麼會有效？

面對這種跳彈方法，我們可以想像，連鎖分析軟體會深入檢測四次跳彈以上的情況。然而，這些平台在最佳化偵測臨界值時卻面臨兩難的局面。它們必須設定跳躍次數的限制，在此限制之後，它們才會接受可能已經發生了屬性改變，並且應該忽略與先前事件（例如 CoinJoin）的連結。

![BTC204](assets/fr/189.webp)

然而，設定這個臨界值是有風險的：觀察到的跳轉數量每增加一次，假陽性的數量就會以指數方式增加，也就是個人被錯誤標示為事件的參與者，但事實上該作業是由其他人執行的。這種情況會對這些公司構成重大風險，因為誤判會導致客戶不滿，進而使受影響的客戶轉投競爭對手的懷抱。長期而言，過高的偵測門檻會導致平台失去比競爭對手更多的客戶，這可能會威脅到平台的生存空間。因此，對這些平台來說，增加觀察到的跳票數量是很複雜的，而 4 通常是足以反擊其分析的數量。

這裡觀察到的現象有點類似於六度分離的理論。

六度分離理論指出，地球上的每個人都是透過一連串的關係連結起來的，其中最多包含六個中介人。因此，只要經過一連串的六個人，每個人都認識下一個人，就可以接觸到世界上任何一個人。

在 Bitcoin 交易的案例中，我們發現類似現象。透過追蹤足夠數量的 Bitcoin 交易，我們不可避免地會遇到一個 CoinJoin。跳彈法利用這個原理，使用比 Exchange 平台可合理追蹤的跳數更多的跳數。如果平台決定追蹤更多的交易，那麼就可以簡單地多加一跳來規避這項措施。

### 何時及如何使用 ricochet？

跳票最常見的用例發生在有必要在自己擁有的 UTXO 上隱藏之前參與過 CoinJoin 的情況。理想情況下，最好避免將經過 CoinJoin 的比特幣轉移至受監管的實體。儘管如此，如果您發現自己沒有其他選擇，特別是在急需以國家貨幣清算比特幣的情況下，ricochet 提供了一個有效的解決方案。

此方法不僅對於共同接合有效，對於任何其他可能影響零件可替代性的標記也同樣有效。

這種跳彈方法的構想最初來自 Samourai Wallet 團隊，他們將此方法整合到應用程式中，使流程自動化。這項服務在 Samourai 並不是免費的，因為轉帳需要支付 100,000 Sats 的服務費，再加上 Mining 的費用。因此，建議金額龐大的轉帳使用。

![BTC204](assets/fr/190.webp)

Samurai 應用程式提供兩種跳彈變體：


- 強化回彈，或稱「交錯交割」，其優點在於可將 Samurai 服務費分散到五次連續交易中。此選項還可確保每筆交易都在不同的時間進行廣播，並記錄在不同的區塊中，盡可能模仿物主變更的行為。雖然速度較慢，但對於那些不急著趕時間的人來說，這種方法更為可取，因為它透過強化回彈對連鎖分析的抵抗力，最大化了回彈的效率；

![BTC204](assets/fr/191.webp)


- 經典的跳字，是為了快速執行操作，在縮短的時間間隔內廣播所有交易。因此，與強化方法相比，此方法的保密性和抗分析能力較低。它只能用於緊急出貨。

![BTC204](assets/fr/192.webp)

跳轉僅表示將比特幣發送給自己。您完全可以在任何 Wallet 軟體上手動轉送比特幣，而不需要使用專門的工具。您所要做的就是連續傳送相同的硬幣給自己，每次都使用新的、空白的 Address。

在下一章中，我們將探討 Ownership 秘密傳輸的不同技術。這些方法無論在操作上或結果上，都與我們目前所研究的方法截然不同。

https://planb.network/tutorials/privacy/on-chain/ricochet-e0bb1afe-becd-44a6-a940-88a463756589
## Ownership 的秘密轉移

<chapterId>a2067036-849c-4d6b-87d2-44235cfae7a1</chapterId>

Bitcoin 的另一項保密技術是 Ownership 的秘密轉移。這種方法的目的是將 Ownership 的比特幣從一個人轉移至另一個人，反之亦然，而不會在 Blockchain 上明顯看到交易。讓我們來看看各種不同的技術，以及它們的優缺點。

### 硬幣交換

Coinwap 是基於一個相對簡單的概念：它使用智慧契約來促進兩個使用者之間的 Bitcoin Ownership 轉移，不需要信任，也不需要在 Blockchain 上明確顯示此轉移。

![BTC204](assets/fr/193.webp)

讓我們想像一個天真的例子，Alice 和 Bob。Alice 持有 1 個以私人密碼匙 $A$ 加密的 BTC，Bob 也持有 1 個以私人密碼匙 $B$ 加密的 BTC。理論上，他們可以透過外部通訊管道 Exchange 他們的私人密碼匙來進行秘密轉移。

![BTC204](assets/fr/194.webp)

然而，這種天真的方法在信任方面有很高的風險。沒有什麼可以阻止 Alice 在 Exchange 之後保留一份 $A$ 私密金鑰的副本，並在金鑰落入 Bob 手中之後使用它來竊取 bitcoins。

![BTC204](assets/fr/195.webp)

此外，在Exchange中，無法保證Alice不會收到Bob的私人密碼匙$B$，也絕不會傳送她的私人密碼匙$A$。因此，這個 Exchange 依賴雙方之間過度的信任，無法有效確保 Ownership 的安全秘密傳輸。

![BTC204](assets/fr/196.webp)

為了解決這些問題，並讓互不信任的雙方進行交換，我們要改用 Smart contract 系統。Smart contract 是一種在符合預先定義條件時自動執行的程式。在我們的案例中，這可確保財產的 Exchange 自動進行，而不需要相互信任。

這可以使用 HTLC (*Hash Time-Locked Contracts*) 或 PTLC (*Point Time-Locked Contracts*) 來實現。這兩種通訊協定的運作方式類似，使用時間鎖定系統，可確保 Exchange 成功完成或完全取消，從而保護雙方資金的完整性。HTLC 與 PTLC 的主要差異在於 HTLC 使用哈希值與預先影像來確保交易安全，而 PTLC 則使用 Adaptor Signatures。

在 Alice 和 Bob 使用 HTLC 或 PTLC 進行換錢的情況下，Exchange 會安全地進行：要不成功，雙方都會收到對方的 BTC，要不失敗，雙方都會保留自己的 BTC。這使得任何一方都無法欺騙或竊取對方的 BTC。

> *HTLC 也是用來透過 Lightning Network 的雙向通道安全路由付款的機制*。
在此情況下，適配器簽章的使用尤其有趣，因為它使免除傳統腳本成為可能（這種機制有時被稱為"_scriptless scripts_"）。此功能可降低與 Exchange 相關的成本。Adaptor Signatures 的另一大優點是不需要交易雙方使用共用的 Hash，因此可避免在某些類型的 Exchange 中揭露雙方之間的直接連結。

### 適配器簽名

適配器簽章是一種加密方法，它將有效簽章與稱為「_適配器簽章_」的附加簽章整合在一起，以揭示秘密資料。此機制的設計方式是，只要知道以下 3 個 Elements 中的 2 個：有效簽章、適配器簽章和秘密，就可以推斷出缺失的第三個元素。此方法的一個有趣特性是，如果我們知道對等人的適配器簽章，以及與用於計算該適配器簽章的秘密相關的橢圓曲線上的特定點，我們就可以推導出我們自己的適配器簽章，該簽章將與相同的秘密相容，而無需直接存取秘密本身。

在換幣過程中，使用 Adaptor Signatures 可以在參與者之間同時披露兩項敏感資訊，從而避免了相互信任的需要。讓我們以 Alice 和 Bob 為例說明這個過程，他們希望 Exchange 各擁有 1 BTC，但彼此不信任。他們使用 Adaptor Signatures 來消除 Exchange 中相互信任的需要。他們是這樣做的：


- Alice 通過創建一個 $m_A$ 交易向 Bob 發送 1 BTC 來啟動 Exchange。她使用她的私人密鑰 $p_A$ ($P_A = p_A \cdot G$), Nonce $n_A$ ($N_A = n_A \cdot G$) 和秘密 $t$ ($T = t \cdot G$) 產生一個簽章 $s_A$，用來驗證此交易：

$$s_A = n_A + t + H(N_A + T \parallel P_A \parallel m_A) \cdot p_A$$


- Alice 通過從其真實簽名 $s_A$ 中減去秘密 $t$ 來計算適配器簽名 $s_A'$ ：

$$s_A' = s_A - t$$


- Alice 送給 Bob 她的簽名適配器 $s'_A$、她的未簽名交易 $m_A$、對應於密碼的點 ($T$) 以及對應於 Nonce 的點 ($N_A$)。這些 Elements 構成了所謂的「適配器」。值得注意的是，僅憑這些資訊，Bob 無法恢復 Alice 的 BTC。
- 然而，Bob可以檢查Alice是否試圖竊取他的資料。為了做到這一點，他會檢查Alice的適配器簽名$s_A'$是否實際對應於建議的交易$m_A$。如果下面的等式是正確的，那麼他就可以確定 Alice 的簽名適配器是有效的：

$$s_A' \cdot G = N_A + H(N_A + T \parallel P_A \parallel m_A) \cdot P_A$$


- 這個驗證為 Bob 提供了充分的保證，讓他可以完全放心地繼續 Exchange。然後，他建立自己的交易 $m_B$，打算傳送 1 BTC 給 Alice，並產生他的適配器簽章 $s_B'$，這個簽章也會連結到相同的秘密 $t$。在此階段，只有 Alice 知道 $t$ 的值；Bob 只知道 Alice 傳送給他的相應點 $T$：

$$s_B' = n_B + H(N_B + T \parallel P_B \parallel m_B) \cdot p_B$$


- 鮑勃傳送給愛麗絲他的適配器簽章 $s_B'$、他未簽署的交易 $m_B$，以及對應於秘密的點 ($T$) 和對應於 Nonce 的點 ($N_B$)。知道秘密 $t$ 的 Alice 現在可以將 Bob 的適配器簽章 $s_B'$ 與此秘密結合，為交易 $m_B$ 製作 generate 的有效簽章 $s_B$，將 Bob 的 BTC 轉移給她：

$$s_B = s_B' + t$$

$$(s_B' + t) \cdot G = N_B + T + H(N_B + T \parallel P_B \parallel m_B) \cdot P_B$$


- Alice 在 Bitcoin Blockchain 上廣播此簽署的 $m_B$ 交易，以取回 Bob 承諾的 BTC。當 Bob 在 Blockchain 上看到此交易時，他可以提取簽名 $s_B = s_B' + t$。有了這些資訊，Bob 就能隔離他所需要的著名秘密 $t$：

$$t = (s_B' + t) - s_B' = s_B - s_B'$$


- 而這個秘密 $t$ 是 Bob 從 Alice 的適配器簽章 $s_A'$ 中 generate 得到有效簽章 $s_A$ 所缺少的唯一元素。這個簽章驗證了 $m_A$ 交易，從 Alice 傳送一個 BTC 到 Bob。鮑勃隨後計算 $s_A$ 並在 Blockchain 上廣播 $m_A$ 交易：

$$s_A = s_A' + t$$

$$(s_A' + t) \cdot G = N_A + T + H(N_A + T \parallel P_A \parallel m_A) \cdot P_A$$

讓我們總結一下適配器簽章在換幣中是如何運作的。一開始，Alice 傳送一個未簽署的交易給 Bob，並附上一個適配器，讓 Bob 可以驗證稍後揭露的秘密是否能讓他取得比特幣。作為回報，Bob 向 Alice 傳送他自己的未簽署交易和適配器。Alice 然後可以完成 Bob 的交易，並透過廣播一個有效的交易來取回比特幣。當這筆交易在 Blockchain 上公佈時，Bob 就有能力提取這個秘密，從而解鎖 Alice 的交易。因此，如果 Alice 對 Bob 的 Bitcoin 進行轉移，Bob 也可以反過來存取 Alice 的 Bitcoin，而無需相互信任。

請注意，換幣最早是由 [Gregory Maxwell 於 2013 年 10 月在 BitcoinTalk](https://bitcointalk.org/index.php?topic=321228.0) 提出的。

### 原子交換

與 Coinswap 相似，使用相同類型的智慧契約，也可以進行原子交換。原子交換可讓兩個使用者之間直接進行不同加密貨幣（如 BTC 和 XMR）的 Exchange 交換，而無需信任或中介介入。這些交換之所以稱為「原子交換」，是因為它們只有兩種可能的結果：交換成功，雙方都滿意；交換失敗，雙方都保留自己原有的加密貨幣，不需要信任對方。

![BTC204](assets/fr/197.webp)

原子交換和硬幣交換有類似的操作方法，在保密性方面有相同的優缺點。事實上，從 Bitcoin 的角度來看，原子交換相當於分兩個階段進行的換幣。首先，我們 Exchange 將我們的 BTC 兌換成另一種加密貨幣，然後此加密貨幣可以兌換成其他 BTC。最後，我們收回另一位使用者的 BTC。這就是為什麼在分析保密性問題時，我將這兩個協定歸類為專屬秘密交換的原因。

![BTC204](assets/fr/198.webp)

但是請注意，與換幣不同，原子交換在可用流動性方面可能存在不平衡，特別是在 BTC/XMR 交易所。一般來說，將比特幣兌換成其他代幣比較容易，因為比特幣的需求強勁，這使得這種兌換方向的溢價保持在低位。然而，由於需求較低，將altcoins兌換成BTC可能會比較複雜，往往會導致非常高的溢價。

最後，當原子交換涉及到鏈上的比特幣和 Lightning Network 上的比特幣時，我們稱之為 「海底交換」。

### 它真的有用嗎？

Ownership 的秘密轉移，例如換幣和原子交換，具有欺騙連鎖分析啟發法的優點。這些方法可顯示交易涉及同一使用者，而實際上 Ownership 已易手。然而，這些方法的主要缺點是，如果不使用額外的技術來破壞硬幣的歷史，風險非常大。

事實上，當 Alice 與 Bob 執行換幣或原子交換時，她將自己擁有的比特幣與 Bob 的比特幣交換。在原子交換的情況下，Exchange 包括一個 Altcoin，但原理是一樣的。因此，Alice 最後擁有 $B$ 硬幣，而 Bob 則擁有 $A$ 硬幣。這增加了鏈分析的疑點，但硬幣的歷史仍然是可追溯的。如果分析師檢查$A$部分，他或她可以追蹤Alice之前的活動，反之亦然。

![BTC204](assets/fr/199.webp)

從 Alice 的角度來看，其風險是 $B$ 硬幣的歷史可能會被某些實體認為是可疑的。例如，如果鮑勃是通過黑客等犯罪行為獲得$B$硬幣的，該硬幣就會與他的非法活動聯繫在一起。Alice可能會發現自己擁有的硬幣無法轉移到受監管的Exchange平台，而不會冒著資金被凍結的風險，甚至被指控牽涉Bob的犯罪，即使她與這些犯罪毫無關係。

![BTC204](assets/fr/200.webp)

無可避免地，資金受到當局監控的罪犯會偏愛諸如換幣或原子交換等保密方式。這些協定使他們能夠在 Exchange 中處置他們被監控的比特幣，以換取完全可替代的比特幣。這也讓他們可以將當局引向其他用戶，從而達到聲東擊西的目的。所以這些人有雙重目的.

有了 CoinJoin，即使您的硬幣混入了被監控的比特幣，硬幣的歷史也會被打破，提供了一種似是而非的可抵賴性，這在秘密的 Ownership 傳輸協議中是不存在的，例如 Coinswap 或 atomic swap。

![BTC204](assets/fr/201.webp)

如果 Alice 希望避免任何風險，她必然要使用一種方法來破解 $B$ 硬幣的歷史，例如透過硬幣接合 (coinjoins) 來傳遞。這就產生了一個問題，結合 Ownership 和 CoinJoin 的秘密傳輸是否有用。CoinJoin通過破壞硬幣的歷史，已經為Alice提供了足夠的保密性。因此，我的看法是，如果 Alice 想要保護她的隱私，直接進行 CoinJoin 會比先進行硬幣交換再進行 CoinJoin 更為明智。

要使秘密的Ownership轉移方法真正有效，並避免將$A$用戶的歷史與$B$用戶的歷史聯繫起來的風險，自相矛盾的是，其使用必須廣為人知。如果coinswap被大量使用，而當局又知道這種普遍的做法，那麼就可以建立一種可信的拒絕形式。然而，只要這些轉移的使用仍然是微不足道的，我認為這些方法對使用者來說仍然風險太大。

到目前為止，我們主要研究交易本身層級的保密方法。在下一章中，我們將探討網路層級和交易散佈層級的問題。

## P2P 網路上的隱私權

<chapterId>04a2467b-db84-4076-a9ff-919be5135106</chapterId>

在第四部分中，我們討論了使用完整節點來保護您的交易機密性的重要性。然而，重要的是要了解您的節點本身也可能受到攻擊，試圖擷取您的活動資訊。因此，在本章中，我們將探討您可以採取的各種措施來保護您的隱私，這些措施不是在交易本身或 Bitcoin 流量層級，而是在網路層級。

### 蒲公英

避免各種去匿名化攻擊的方法之一是使用 Dandelion 提案。此廣播通訊協定在 BIP156 中正式提出，但從未在 Bitcoin 上實作。

Dandelion 背後的理念是改善 Bitcoin 網路中交易路由的機密性，以對抗各種形式的攻擊。其主要目的是隱藏最初在網路上廣播交易的來源節點。洩露此節點可將 Bitcoin 交易連結至特定 IP Address（若該節點在 Clearnet 上運作），從而提供連鎖分析的切入點。

Bitcoin 上的活動與 IP Address 之間的關係對使用者的機密性造成相當大的風險。事實上，許多實體都可以輕易地將 IP Address 與個人身分相連結。這包括政府和網際網路服務供應商。更重要的是，這些資訊可能會被公開，例如當網站的資料庫被駭客入侵時，您的 IP Address 和個人資料就會外洩。

在傳統的 Bitcoin 作業中，使用者在其 Wallet 軟體上建立的交易會傳送到他的個人節點。這個節點會立即將新的交易廣播給它所連結的所有對等體。

![BTC204](assets/fr/202.webp)

然後，這些對等人會檢查交易，以確保它符合共識和當地標準化規則。一旦確認無誤，每個對等者就會依次將交易轉發給他或她的對等者，如此類推。

![BTC204](assets/fr/203.webp)

等待整合成區塊的交易分佈相當均衡，在統計學上也是可預測的。共謀的間諜節點可以利用這個弱點，協力監控和分析網路，以找出第一個廣播交易的節點。如果觀察者成功找到來源節點，就可以假設交易是來自該節點的操作者。這種觀察方式可用來將通常匿名的交易與特定的 IP 位址連結起來。

![BTC204](assets/fr/204.webp)

BIP156 的目的是解決 Address 這個問題。為了做到這一點，它在新交易的傳播中引入了一個額外的階段，以便在廣泛公開傳播之前保持匿名性。Dandelion 首先使用「莖」(stem) 階段，在此階段交易會經由節點的隨機路徑傳送。

![BTC204](assets/fr/205.webp)

然後在「投降」階段將交易分發給整個網路。

![BTC204](assets/fr/206.webp)

莖和花頭是指交易在網路中傳播的行為，其形狀類似蒲公英。

因此，間諜節點有可能將交易追溯到啟動投降階段 (大量廣播) 的節點，但這個節點不是第一次廣播交易的節點，因為它是從莖幹上的最後一個節點接收交易的。如果間諜節點無法追蹤莖幹，也就無法識別源節點。

![BTC204](assets/fr/207.webp)

即使在幹線階段有間諜節點的存在，疑點始終存在，因為只要在擴散圖中遇到誠實的節點，間諜就無法判斷這個節點是原始來源，還是只是一個中介。

![BTC204](assets/fr/208.webp)

這種路由方法會模糊追溯到來源節點的痕跡，使交易難以透過網路追溯到其源頭。因此，Dandelion 限制了對手對網路進行去匿名化的能力，從而提高了保密性。當交易在「莖化」(stemming) 階段穿越加密網路通訊的節點 (如 Tor 或 P2P Transport V2)時，此方法就更為有效。

BIP156 尚未整合至 Bitcoin Core，目前被歸類為 「拒絕」。此通訊協定的主要問題之一是，在幹線階段，交易必須先經由中間節點中繼，然後再進行驗證。正如我們所見，在正常的 Bitcoin 模型中，每個節點都會先驗證交易，然後再將其廣播給對等節點。如果交易不符合節點的共識規則或當地標準化規則，節點就會忽略該交易，並且不進行分發。這個過程對於對抗 DoS 攻擊非常重要，因為只有有效的交易才會廣播到整個網路。無效的交易可能會大量產生，使網路負荷過重，因此會在遇到的第一個節點停止，不會傳播。Dandelion 的主要風險在於，此新通訊協定可能會允許在部分網路中廣播無效交易，從而引入 DoS 攻擊的新媒介。

### P2P 傳輸 V2

P2P 傳輸 V2 是 BIP324 中提出的另一個網路通訊協定。它是 Bitcoin P2P 傳輸通訊協定的新版本，結合了機會性加密功能，以提高節點間通訊的機密性和安全性。

此增強功能旨在解決 P2P 通訊協定基本版本的幾個問題。一方面，它使交換的資料對於被動的觀察者而言，與網際網路上流通的其他類型資料無異。主要目的是防止政府、互聯網服務供應商和 VPN 供應商大量監控 Bitcoin 用戶。這也使得這些實體更難判斷網際網路使用者是否也是 Bitcoin 使用者，也就是他或她是否在操作一個完整的節點。

P2P V2 還能偵測資料封包中的特定模式，有助於降低審查和攻擊的風險。它使在網路層級執行各類 Sybil 攻擊變得更複雜、成本更高。Sybil 攻擊是指行為者為了獲得不公平的優勢而創造多個虛假身份。在 Bitcoin 網路的情況下，這通常會表現為行動者控制大量完整節點，並積極利用這些節點來倍增連線。Sybil 攻擊可以是被動式的，用來收集資訊並損害使用者的機密性；也可以是主動式的，以 Eclipse 攻擊的形式出現。後者會將特定節點與網路的其他部分隔離，審查使用者或改變其接收的資料。最後，P2P V2 也使 *Man-In-The-Middle* (MITM) 攻擊的代價更高且更容易偵測。

P2P V2 所實作的加密並不包括驗證，以免增加不必要的複雜性，或損害與網路連線仍然無須允許的事實。儘管如此，這個新的 P2P 傳輸通訊協定提供了更好的安全性來對抗被動式攻擊，並使主動式攻擊的代價更高且更容易被偵測到。在網路訊息中引入偽隨機資料流，讓攻擊者更難審查或竄改通訊。

P2P V2 傳輸在 2023 年 12 月部署的 Bitcoin Core 版本 26.0 中被列為選項 (預設停用)。之後在 2024 年 4 月的 27.0 版中預設啟用。可使用設定檔中的 `v2transport=` 選項修改。

### Tor

另一個避免網路節點失密風險的簡單解決方案，就是完全在 Tor 下執行。

Tor 是一個由中繼伺服器 (節點) 組成的網路，可將網際網路上 TCP 連線的來源匿名化。它的工作原理是將資料封裝在數層加密中。每個中繼節點都會移除一個 Layer 來顯示下一個節點的 Address，直到抵達最終目的地為止。Tor 網路透過防止中介節點知道資料的來源和目的地來確保匿名性，使得觀察者很難追蹤使用者的活動。

![BTC204](assets/fr/209.webp)

Tor 不僅會加密資料，還會隱藏通訊的來源和目的地。透過使用 Tor 從您的個人節點進行通訊，您可以加強交易的機密性：您的 ISP 無法解密通訊，Bitcoin 網路中的其他節點也無法識別源節點的 IP Address。更重要的是，Tor 也會向您的 ISP 隱藏您使用 Bitcoin 的情況。

此方法的主要風險在於 Tor 是獨立於 Bitcoin 的通訊協定。如果您的 Bitcoin 節點在 Tor 下執行，而 Tor 停止運作，那麼您的 Bitcoin 節點將無法再進行通訊。

此外，需要注意的是 Tor 上的通訊速度較慢。這種延遲在節點初始啟動時尤其惱人，因為 IBD（*初始區塊下載*）需要大量的通訊。因此，使用 Tor 時，您與 Bitcoin 網路的初始同步時間可能會大幅延長。也可以先在 Clearnet 上執行 IBD，然後再啟動 Tor 作為第二步驟。雖然這個方法會向您的 ISP 透露您的 Bitcoin 節點的存在，但一旦您轉換到 Tor，它就會保護您的個人交易資訊。

在探討了網路層級的各種保密方法之後，在接下來的幾個章節中，我還想向您介紹兩種避免 Address 重複使用的優雅解決方案：BIP47 和 Silent Payments。

## BIP47 和可重複使用的付款代碼

<chapterId>ad88e076-a04b-4aec-b3b2-7b4760175504</chapterId>

正如我們在第三部分所看到的，Address 重複使用是 Bitcoin 通訊協定上使用者保密性的嚴重障礙。為了降低這些風險，強烈建議在 Wallet 收到每筆新付款時，都要 generate 產生一個空白的收款 Address。儘管現代軟體和分層確定式錢包的使用已經簡化了生成新 Address 的過程，但這種做法看起來可能有違直覺。

![BTC204](assets/fr/210.webp)

舉例來說，在傳統的銀行系統中，我們習慣分享 IBAN，而 IBAN 永遠保持不變。一旦我們將 IBAN 給了別人，他們就可以向我們發送多筆付款，而無需再次與我們互動。新式銀行也提供了更多現代化的可能性，例如 PayPal 使用獨特的電子郵件地址，或 Revolut 使用 RevTags。即使在金融領域之外，我們的日常識別符號，例如郵政 Address、電話號碼和電子郵件 Address 也是唯一且永久的。我們不必為每次新的互動更新它們。

![BTC204](assets/fr/211.webp)

然而，Bitcoin 的運作方式不同：每筆傳入的交易都必須產生新的接收 Address。這種易用性與機密性之間的折衷，可以追溯到 Bitcoin 白皮書的起源。早在 2008 年底發表第一版文件時，Satoshi Nakamoto 就已經提醒我們注意這個風險：

**作為額外的防火牆，每筆交易都可以使用新的金鑰對，以保持它們與共同擁有者無關。

有許多方法可以在單一識別碼上接收多筆付款，而無需重複使用 Address。每種方法都有自己的取捨和缺點。在這些方法中，BIP47 是由 Justus Ranvier 提出並於 2015 年發表的提案。該提案旨在創建可重複使用的付款代碼，使同一人可進行多筆交易，同時避免重複使用 Address。簡而言之，BIP47 旨在提供像唯一識別碼一樣直觀的支付系統，同時保護交易的機密性。

![BTC204](assets/fr/212.webp)

BIP47 並不會直接提高使用者的機密性，因為 BIP47 付款提供的機密性等級與使用空白位址的傳統 Bitcoin 交易相同。但是，它確實使 Bitcoin 的使用更方便、更直觀，這種方便性通常會影響保密性。有了 BIP47，這種易用性達到了與傳統交易相同的保密性。這就是為什麼 BIP47 是保護隱私的重要工具。

最初，BIP47 被建議整合到 Bitcoin Core 中，但實際上從未實作。然而，有些軟體應用程式選擇自行實作。例如，Samourai Wallet 團隊開發了自己的 BIP47 實作，稱為「PayNym」。

### BIP47 和 PayNym 的一般原則

BIP47 的目的是在不重複使用地址的情況下，使接收大量付款成為可能。它是以使用可重複使用的付款代碼為基礎，讓不同的發卡機構可以向屬於其他使用者的單一代碼發送數筆付款。因此，收款人不必為每筆交易提供新的、空白的 Address，這大大方便了交換，同時又能保密。

![BTC204](assets/fr/213.webp)

因此，使用者可以完全自由地分享自己的付款代碼，無論是在社交網路或自己的網站上，都不會有任何失密的風險，這與傳統的收款人 Address 或公開金鑰不同。

若要進行交易，雙方都需要一個具備 BIP47 實作的 Bitcoin Wallet，例如 Samurai Wallet 或 Sparrow Wallet 上的 PayNym。共同使用他們的付款代碼會在他們之間建立一個秘密通道。為了有效建立此通道，發卡機構必須在 Bitcoin Blockchain 上執行特定交易，稱為「通知交易」（稍後詳細說明）。

結合兩個使用者的付款代碼會產生共用的秘密，進而產生大量獨特的 Bitcoin 收件地址 (正好 2^32 或約 40 億個)。如此一來，透過 BIP47 進行的付款實際上並不是寄往付款代碼本身，而是寄往由相關使用者的付款代碼所衍生的經典收款位址。

因此，付款代碼是從 seed 組合衍生出來的虛擬識別碼。在組合的階層式衍生結構中，付款代碼位於第 3 層，即帳戶層級。

![BTC204](assets/fr/214.webp)

BIP47 的衍生目標由索引 `47'` (`0x8000002F`) 識別，指的是 BIP47。可重複使用的付款代碼的衍生路徑範例如下：

```plaintext
m/47'/0'/0'/
```

為了讓您了解付款代碼的樣子，以下是我的付款代碼：

```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

此代碼也可編碼為 QR 代碼，讓通訊更方便，就像傳統的接收器 Address。

至於 PayNym Bots，也就是有時在 Twitter 上看到的機器人，這些都是付款代碼的視覺呈現，由 Samourai Wallet 所製作。它們是使用 Hash 函式產生的，因此幾乎是唯一的。它們的形式是以 `+` 開頭的一小串字元：

```plaintext
+throbbingpond8B1
+twilightresonance487
+billowingfire340
```

這些化身也可以用影像來表示：

![BTC204](assets/fr/215.webp)

雖然這些機器人在 BIP47 架構中沒有特定的技術功能，但它們提供了容易辨識的視覺形象，在促進使用者互動方面確實扮演了一定的角色。

---
*在本章專門介紹 BIP47 的以下幾節中，我們將詳細介紹其工作原理，並特別強調所使用的加密方法。要完全掌握這些有點技術性的解釋，必須先瞭解 HD 錢包的結構、金鑰推演程序和橢圓曲線加密學的基本原理。如果您想深入瞭解這些概念，Plan ₿ Network 上還有另一個免費的訓練課程：*。

https://planb.network/courses/46b0ced2-9028-4a61-8fbc-3b005ee8d70f
*我仍然建議您遵循這些建議，因為瞭解 BIP47 的技術運作，將使您更容易理解其他類似的提案，我們將在以下章節中討論這些提案*。

---
### 可重複使用的付款代碼

如前所述，可重複使用的付款代碼位於 HD Wallet 的深度 3，因此無論是在 Wallet 結構中的位置或作用，都可與 `xpub` 相提並論。

80 位元組的付款代碼細分如下：


- 位元組 `0`：版本**。對於 BIP47 的第一個版本，此位元組設為 `0x01` ；
- 位元組 `1`：位元欄位**。此空間保留用於整合特定用途的附加指示。對於傳統的 PayNym 用途，此位元組設為 `0x00` ；
- `2` 位元組：y`** 的奇偶校驗。此位元組為 `0x02` 或 `0x03`，表示公開金鑰的序數是偶數或奇數，因為使用的是壓縮公開金鑰；
- 從位元組 `3` 到位元組 `34`：`x`** 的值。這些位元組代表公開金鑰的餘數。`x` 和 `y` 的奇偶校驗的串接，形成完整的壓縮公開金鑰；
- 從 byte `35` 到 byte `66`：字串代碼**。此空間包含與公開金鑰相關的字串代碼；
- 從位元組 `67` 到位元組 `79`：填充**。這個空間是為了未來可能的演進而設。對於目前的版本，我們只需在此處放置零，即可達到 `OP_RETURN` 輸出所需的 80 位元組大小。

以下是我在上一節中已經介紹過的可重複使用的付款代碼的十六進位表示：

```plaintext
0x010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

![BTC204](assets/fr/216.webp)

接下來，必須在開頭加上 `P` 前綴位元組，以清楚表示這是付款代碼。這個位元組用 `0x47` 表示：

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

最後，為了確保付款代碼的完整性，會使用 `HASH256` 執行校驗和計算，它由使用 `SHA256` 功能的雙重 Hash 組成。然後將此 Hash 的前四個位元組串接在付款代碼的末端：

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4
```

![BTC204](assets/fr/217.webp)

完成這些步驟後，付款代碼就準備好了。剩下的工作就是將它轉換為基數 58，以獲得最終版本：

```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

在建立付款代碼的過程中，我們使用壓縮的公開金鑰和字串代碼。這兩者都是由 Wallet seed 以確定性和分層方式衍生出來的。用來達到這個目的的衍生路徑是 ：

```plaintext
m/47'/0'/0'/
```

具體來說，為了 generate 與可重複使用的付款代碼相關的壓縮公開金鑰和字串代碼，我們先從 Wallet seed 開始計算主私密金鑰。接著，我們使用索引 `47 + 2^31` 來推導出一對子金鑰 (強化推導)。接著再連續推導出兩個子鑰匙對，每個都使用索引 `2^31` (強化推導)。

![BTC204](assets/fr/218.webp)

### 橢圓曲線 (ECDH) 上的 Diffie-Hellman 金鑰 Exchange

BIP47 核心的加密協定以縮寫 ECDH 而聞名，即 *Elliptic-Curve Diffie-Hellman*。此方法是原始 Diffie-Hellman 密鑰 Exchange 的變體。

Diffie-Hellman 於 1976 年推出，是一種金鑰協定通訊協定，可讓各自配備金鑰對（公開金鑰和私人金鑰）的雙方，即使僅透過公開、不安全的頻道通訊，也能就共同的秘密達成協議。

![BTC204](assets/fr/219.webp)

此共用秘密 (在本例中為藍色金鑰) 隨後可用於其他操作。一般而言，此共用秘密可用於在不安全的網路中加密和解密通訊：

![BTC204](assets/fr/220.webp)

為了達到這個目的，Diffie-Hellman 使用模組運算來計算共享秘密。以下是通俗易懂的工作原理：


- Alice 和 Bob 協定了一個共同的顏色，在本例中為黃色，這是公開資料 (攻擊者知道這個顏色)；
- Alice 選擇一個秘密顏色，在這個例子中是紅色，然後將兩者混合得到橙色；
- 鮑勃也選擇了一種秘密顏色，在本例中是藍色，並將其與黃色混合，得到 Green；
- 然後他們 Exchange 產生的顏色，橙色和 Green。此 Exchange 可在不安全的網路中進行，並會被攻擊者觀察到；
- 將 Bob 的 Green 與她自己的秘密顏色混合後，Alice 會產生棕色；
- Bob 用 Alice 的橙色和秘密藍色做同樣的動作，也會得到棕色。

![BTC204](assets/fr/221.webp)

在此普及中，褐色代表 Alice 和 Bob 分享的秘密。想像一下，在現實中，攻擊者不可能分開橘色和 Green 的顏色，以找出 Alice 或 Bob 的秘密顏色。

現在讓我們來看看這個協定實際上是如何運作的，不是使用顏色類比，而是使用實數和模數運算！

在我們進入 Diffie-Hellman 機制之前，讓我簡單提醒您兩個我們需要的基本數學概念：


- 一個**素數**是只有兩個除數的自然數：1$ 和它本身。例如，$7$ 是一個質數，因為它只能被 $1$ 和 $7$整除。另一方面，$8$ 不是質數，因為它可以被 $1$、$2$、$4$ 和 $8$整除。因此它有四個正整數除數，而不是兩個；
- **modulo**（注：$mod$ 或 $/%$）是一種數學運算，在兩個整數之間，返回前一個整數除以後一個整數的餘數。例如，$16\bmod 5 = $1$。

*** Alice 和 Bob 之間的 Diffie-Hellman 金鑰 Exchange 發生如下：**


- Alice和Bob同意兩個共同的數字：$p$和$g$。$p$是一個素數，數字越大，Diffie-Hellman就越安全。$g$ 是 $p$ 的原始根。這兩個數字可以在不安全的網絡上進行明確的通信。它們相當於之前普及的**黃色**。因此，Alice 和 Bob 使用完全相同的 $p$ 和 $g$ 值是非常重要的。
- 一旦定義了這些參數，Alice 和 Bob 會各自選擇一個秘密隨機數。Alice 將她的秘密隨機數命名為 $a$（相當於**紅色**），Bob 將他的秘密隨機數命名為 $b$（相當於**藍色**）。這些數字必須保密。
- 每一方不直接交換數字 $a$ 和 $b$，而是如下計算 $A$ 和 $B$：

$A$ 等於 $g$ 遞增至幂 $a$ modulo $p$ ：

$$
A = g^a \bmod p
$$

$B$ 等於 $g$ 遞增至幂 $b$ modulo $p$ ：

$$
B = g^b \bmod p
$$


- 雙方會交換 $A$（相當於**顏色的橙色**）和 $B$（相當於**顏色的 Green**）。此 Exchange 可以在不安全的網路中以明碼進行；
- Alice 收到 $B$ 後，計算 $z$ 的值如下：

$z$ 等於 $B$ 遞增至幂 $a$ modulo $p$ ：

$$
z = B^a \bmod p
$$

提醒您：

$$
B = g^b \bmod p
$$

結果是 ：

$$
z = B^a \bmod p
$$

$$
z = (g^b)^a \bmod p
$$

通過應用電源規則 ：

$$
(x^n)^m = x^{nm}
$$

結果是 ：

$$
z = g^{ba} \bmod p
$$


- Bob 收到 $A$ 後，也會計算 $z$ 的值，如下所示：

$z$ 等於 $A$ 遞增至幂 $b$ modulo $p$ ：

$$
z = A^b \bmod p
$$

結果是 ：

$$
z = (g^a)^b \bmod p
$$

$$
z = g^{ab} \bmod p
$$

$$
z = g^{ba} \bmod p
$$

由於 modulo 運算子的分配性，Alice 和 Bob 得到完全相同的值 $z$。這個數字代表他們的共同秘密，等同於之前用油漆罐普及的**棕色**。現在他們可以使用這個共同秘密，在不安全的網路中對稱加密他們的通訊。

![BTC204](assets/fr/222.webp)

即使攻擊者擁有 $p$、$g$、$A$ 和 $B$（公共值），也無法計算 $a$、$b$ 或 $z$（私人值）。為了達到這個目的，幂级数必須反轉，這個操作如果不逐一嘗試所有的可能性是不可能的，因為它等於計算離散對數，也就是有限循環群中幂级数的倒數。

因此，只要 $a$、$b$ 和 $p$ 的值夠大，Diffie-Hellman 協定就是安全的。通常，如果參數為 2048 位元 (十進制的 600 位元)，測試 $a$ 和 $b$ 的所有可能性是不切實際的。迄今為止，對於這樣的數字，這種演算法被認為是安全的。

這就是 Diffie-Hellman 協定的主要缺點。為了安全起見，演算法必須使用大數字。這就是為什麼現在我們更喜歡使用 ECDH (*Elliptic Curve Diffie-Hellman*) 演算法，這是 Diffie-Hellman 基於代數曲線 (更準確的說是橢圓曲線) 的變體。這種方法可以使用小得多的數字，同時保持同等的安全性，從而減少計算和儲存所需的資源。

演算法的一般原則維持不變。然而，我們不再使用隨機數 $a$ 和由 $a$ 經模幂運算得出的數字 $A$，而是使用一對建立在橢圓曲線上的鑰匙。我們不再依賴模運算子的可分配性，而是使用橢圓曲線上的群法則，更精確地說是此法則的關聯性。

簡單解釋一下橢圓曲線加密的原理，私人密碼匙是由一個介於 $1$ 和 $n-1$ 之間的隨機數表示，其中 $n$ 代表曲線的階次。而公開密碼匙則是此曲線上的一個特定點，由私密密碼匙經由與產生點的點數相加並加倍而得到，其公式為 ：

$$
K = k \cdot G
$$

在此公式中，$K$ 表示公開金鑰，$k$ 表示私人金鑰，$G$ 表示產生點。

這些鑰匙的一個基本特徵是 $K$ 可以很容易地從 $k$ 和 $G$ 計算出來, 而要從 $K$ 和 $G$ 找出 $k$ 幾乎是不可能的.這種不對稱性創造了一個單向函數。換句話說，如果您知道私人密碼匙，就很容易計算出公開密碼匙，但是從公開密碼匙找回私人密碼匙是不可能的。離散對數的計算難度進一步強化了這種安全性。

我們將運用此特性來調整我們的 Diffie-Hellman 演算法。 **ECDH 的運作原理如下：**


- Alice 和 Bob 就加密安全的橢圓曲線及其參數達成協議。此資訊是公開的；
- Alice 產生一個隨機數 $ka$，作為她的私人密碼匙。此私人密碼匙必須保密。她通過在所選的橢圓曲線上增加和加倍點來決定她的公開密鑰 $Ka$：

$$
K_a = k_a \cdot G
$$


- Bob 也會產生一個隨機數 $kb$，作為他的私人密碼匙。他計算出相關的公開金鑰 $Kb$ ：

$$
K_b = k_b \cdot G
$$


- Alice 和 Bob 在不安全的公共網路中 Exchange 他們的公開金鑰 $Ka$ 和 $Kb$。
- Alice 透過將她的私人密碼匙 $ka$ 應用於 Bob 的公開密碼匙 $Kb$ 來計算曲線上的一個點 $(x,y)$：

$$
(x,y) = k_a \cdot K_b
$$


- Bob 將他的私人密碼匙 $kb$ 應用在 Alice 的公開密碼匙 $Ka$ 上，計算出曲線上的一個點 $(x,y)$ ：

$$
(x,y) = k_b \cdot K_a
$$


- Alice 和 Bob 在橢圓曲線上得到相同的點。共用的秘密就是這個點的餘值 $x$。

它們獲得相同的共用秘密，因為 ：

$$
(x,y) = k_a \cdot K_b = k_a \cdot (k_b \cdot G) = (k_a \cdot k_b) \cdot G = (k_b \cdot k_a) \cdot G = k_b \cdot (k_a \cdot G) = k_b \cdot K_a
$$

潛在的攻擊者在觀察不安全的公共網路時，只能取得每個人的公開金鑰以及所選橢圓曲線的參數。如上所述，單靠這些資訊並不足以確定私人密碼匙。因此，攻擊者無法找到 Alice 和 Bob 分享的秘密。

因此，ECDH 是一種關鍵的 Exchange 演算法。它經常與其他加密方法一起使用，以建立完整的通訊協定。例如，ECDH 是 TLS (*Transport Layer Security*) 的核心，TLS 是用於網際網路傳輸 Layer 的加密和認證通訊協定。TLS 使用 ECDHE 作為金鑰 Exchange，這是 ECDH 的變體，其中的金鑰是短暫的，以提供持久的機密性。此外，TLS 還使用 ECDSA 等認證演算法、AES 等加密演算法以及 SHA256 等 Hash 函數。

TLS 是 `https` 中的 `s` 和瀏覽器 Address 欄中的掛鎖 - 加密通訊的象徵。透過學習本課程，您將會使用 ECDH，而且很有可能您每天都在不知不覺中使用它。

### 通知交易

正如我們在上一節所看到的，ECDH 是 Diffie-Hellman Exchange 的變體，使用在橢圓曲線上建立的金鑰對。好在我們的 Bitcoin 錢包中已經有很多符合這個標準的金鑰對！BIP47 的構想是使用雙方分層確定的 Bitcoin 錢包中的金鑰對來建立雙方共享的短暫秘密。BIP47 使用 ECDHE (*Elliptic Curve Diffie-Hellman **Ephemeral***) 來代替。

![BTC204](assets/fr/223.webp)

ECDHE 首先用於 BIP47，將付款代碼從寄件者傳送給收件者。這就是著名的**通知交易**。這個步驟非常重要，因為 BIP47 要有效運作，相關的雙方 (寄件者和收件者) 都需要知道彼此的付款代碼。有了這些知識，就能衍生出短暫公開金鑰，進而衍生出相關的空白接收位址。

在此 Exchange 之前，寄件者邏輯上已經知道收件者的付款代碼，例如從他或她的網站、Invoice 或社交網路取得 off-chain。但是，收件人不一定知道發件人的付款代碼。但是，該代碼必須傳送給他，否則，他將無法獲得所需的短暫密鑰，以識別其比特幣存放的地址，或存取其資金。雖然這種寄件者代碼的傳輸在技術上可以透過其他通訊方式來進行 off-chain，但如果只從 seed 擷取 Wallet 就會造成問題。

這是因為，與傳統地址不同，BIP47 地址不是直接從收件人的 seed 獲取的 - 在這種情況下使用 `xpub` 會比較簡單 - 而是結合了兩個付款代碼的計算結果：發貨人的付款代碼和收件人的付款代碼。因此，如果收件人丟失了他的 Wallet，並嘗試從他的 seed 恢復它，他將恢復他自己的付款代碼，這是直接從他的 seed 派生的。但是，要恢復短暫地址，他還需要所有通過 BIP47 向他發送比特幣的人的支付代碼。因此，通知交易非常重要，它可以將這些資訊保存在 Bitcoin Blockchain 上，同時還可以非常容易地找到它，而無需在 2009 年推出以來執行的十億筆交易中搜尋。

![BTC204](assets/fr/224.webp)

因此，只要每個使用者都備份其對等使用者的付款代碼，就可以不使用通知交易來實現 BIP47。然而，在開發出簡單、穩健且有效的備份、儲存和更新解決方案之前，這種方法的管理會很複雜。就目前情況而言，通知交易幾乎是不可避免的。

不過，在接下來的幾章中，我們會看看其他目標與 BIP47 相似，但不需要通知交易的通訊協定。不過，這些替代方案也有自己的取捨。

除了儲存付款代碼的功能外，如其名稱所示，通知交易還具有通知收款人的功能。它會提醒收款人的客戶新的付款通道已經建立，並建議他或她留意由此產生的短暫地址。

### BIP47 保密模式

在詳細說明通知交易的技術操作之前，必須先討論與 BIP47 相關的保密模式，這也是在建立此初始交易時採取某些措施的理由。

付款代碼本身並不會對機密性構成直接風險。傳統的 Bitcoin 模式旨在透過保留金鑰和位址的匿名性來打破使用者身份與其交易（交易是公開的）之間的連結，與此不同的是，付款代碼可以公開地與身份相關聯，而不會構成威脅。

這是因為付款代碼不是用來直接產生接收 BIP47 付款的地址。相反，這些地址是透過 ECDH 應用程式，在相關雙方的付款代碼所產生的金鑰之間產生的。

因此，付款代碼本身不會直接導致失密，因為只有通知書 Address 是從付款代碼衍生出來的。雖然這個 Address 可以透露某些資訊，但通常不會透露交易對方，除非進行徹底的連鎖分析。事實上，如果發件人使用可連結到其身份的 UTXO 來進行通知交易，那麼就有可能推斷出他的身份很可能與 BIP47 付款連結到您的付款代碼。這不會揭露基本交易，但會顯示其可能存在。

因此，保持使用者付款代碼之間的嚴格區隔是非常重要的。有鑒於此，最初的付款代碼通訊是付款保密的關鍵時刻，但也是協定正常運作的關鍵時刻。如果其中一個付款代碼可以公開取得 (例如在網站上)，則第二個代碼，也就是寄件者的代碼，在任何情況下都不得與第一個代碼連結。

讓我們舉一個具體的例子：我想要透過 BIP47 捐款給一個政治運動：


- 該組織已在其網站上或透過其社交網路公開其付款代碼；
- 因此，本守則與政治運動有關；
- 我收到這個付款代碼 ；
- 在發送之前，我必須確定他們知道我自己的付款代碼，因為我在社交網路中接受交易時也會用到這個代碼，所以這個代碼也與我的身份有關。

我如何才能毫無風險地傳遞我的代碼？使用傳統的通訊方式可能會導致資訊洩漏，進而將我與這項政治運動聯繫起來。通知交易提供了一個解決方案，這要歸功於加密的 Layer，它可以防止兩個代碼之間產生這樣的聯繫。雖然這不是秘密傳送寄件者付款代碼的唯一方法，但卻是非常有效的方法。

在下圖中，橘色線表示資訊流必須中斷的點位，黑色箭頭表示第三方可能觀察到的連線：

![BTC204](assets/fr/225.webp)

實際上，在 Bitcoin 的傳統保密模式中，要完全分離金鑰對與使用者之間的資訊流通常是很複雜的，尤其是在遠端交易中。舉例來說，在捐款活動中，收款人無可避免地必須透過他或她的網站或社交網路公開 Address 或公開金鑰。正確使用 BIP47，尤其是通知交易，就可以繞過這個問題，這要歸功於 ECDHE 和我們稍後將會介紹的加密 Layer。

當然，Bitcoin 的經典保密模式仍然適用於短暫公開金鑰，它是由兩個付款代碼的組合所衍生出來的。這兩種模式其實是相輔相成的。在此我要強調的是，與一般使用公開金鑰來接收比特幣不同的是，付款代碼可以連結到特定的身分，因為「_Alice 正在和 Bob 交易_」這個資訊是在另一個階段被破解的。付款代碼用於 generate 付款地址，但僅根據對 Blockchain 的觀察，不可能將 BIP47 付款交易與用於執行該交易的付款代碼聯繫起來，除非所涉及的 UTXO 之前已經與某個身份聯繫起來，並且使用者將其付款代碼與各自的身份聯繫起來。

總而言之，BIP47 支付所提供的保密模式可以說是優於 Bitcoin 的基本模式，雖然這並不代表它有魔力。

### 建立通知交易

現在讓我們看看這個通知交易是如何運作的。讓我們想像一下，Alice 希望使用 BIP47 將資金寄給 Bob。在我的例子中，Alice 是寄款人，Bob 是收款人。Bob 已經在他的網站上公佈了他的付款代碼。因此 Alice 已經知道 Bob 的付款代碼。

**1- Alice 使用 ECDH 計算共用秘密 :**


- 她從她的 HD Wallet 中選擇一個與她的付款代碼不同分支的金鑰對。請注意，這個金鑰對不能輕易與 Alice 的通知 Address 相關聯，也不能與 Alice 的身分相關聯 (請參閱上一節)；
- Alice 選擇這對鑰匙的私人密碼匙。我們稱之為 $a$（小寫）；

$$
a
$$


- Alice 擷取與 Bob 的通知 Address 相關的公開金鑰。這個金鑰是從 Bob 的付款代碼 (索引 $/0$)衍生出來的第一個子金鑰。我們稱此公開金鑰為 $B$（大寫）。與此公開金鑰相關的私人金鑰命名為 $b$（小寫）。$B$是由$G$(產生點)與$b$(私人密碼匙)在橢圓曲線上的加倍點所決定：

$$ B = b \cdot G $$


- Alice 運用她的私人密碼匙 $a$ 和 Bob 的公開密碼匙 $B$，在橢圓曲線上透過加點和倍點來計算一個秘密點 $S$（大寫）。

$$ S = a \cdot B $$


- Alice 計算將用於加密其付款代碼的致盲因子 $f$。為此，她使用 HMAC-SHA512 函式來確定一個偽隨機數。這個函數的第二個輸入是一個只有 Bob 才能找到的值：$x$，即上面計算出的秘密點的餘值。第一個輸入為：$o$，即作為此交易（出點）輸入而消耗的 UTXO。

$$ f = \text{HMAC-SHA512}(o, x) $$

**2 - Alice 將個人付款代碼轉換為基 2 (二進制) **

**3- 它使用此致盲因子作為鑰匙，對其支付代碼的有效載荷執行對稱加密。** 使用的加密算法僅為 `XOR`。所執行的運算相當於 Vernam 密碼，也稱為 "One-Time Pad"。


- Alice 首先將她的致盲因子一分為二：前 32 位元組名為 $f1$，後 32 位元組名為 $f2$。這樣我們就得到 ：

$$ f = f1 || f2 $$


- Alice 分別計算她的付款密碼的公開密鑰 $x$ 的餘數的密碼 $x「$，以及她的字串密碼 $c$ 的密碼 $c」$。$f1$ 和 $f2$ 分別作為密碼鑰匙。使用的操作是 `XOR` (或排他性)。

$$ x' = x \oplus f1 $$

$$ c' = c \oplus f2 $$


- Alice 在她的付款代碼中，將公開金鑰尾數 $x$ 和字串代碼 $c$ 的真實值置換為加密值 $x「$ 和 $c」$。

**4-** 因此 Alice 目前有她的付款代碼與加密的有效負載。她將建構並廣播一筆交易，包含她的公開金鑰 $A$ 作為輸入，輸出至鮑勃的通知 Address，以及由她的付款代碼與加密負載組成的輸出`OP_RETURN`。 **此交易為通知交易**。

OP_RETURN」是一個操作碼，將 Bitcoin 交易的輸出標記為無效。如今，它用於在 Bitcoin Blockchain 上廣播或 Anchor 資訊。它最多可儲存 80 位元組的資料，然後將這些資料寫入鏈中，並讓所有其他使用者看見。

正如我們在前幾節所看到的，ECDH 是用來 generate 在不安全的網路中通訊的兩個使用者之間的共用秘密，並且有可能被攻擊者觀察到。在 BIP47 中，ECDH 用於在 Bitcoin 網路上通訊，而 Bitcoin 網路的本質是一個透明的通訊網路，因此會被許多攻擊者觀察到。透過 ECDH 金鑰 Exchange 計算出的共用秘密，再用來加密要傳輸的秘密資訊：寄件者的付款代碼 (Alice)。

我會總結我們剛才一起看過的步驟，來執行通知交易：


- Alice 擷取 Bob 的付款代碼和通知 Address；
- Alice 使用對應的金鑰，從 HD 組合中選取 UTXO；
- 它使用 ECDH 計算橢圓曲線上的秘密點；
- 它使用此密碼點來計算 HMAC，也就是致盲因子；
- 她利用這個致盲因子來加密個人付款代碼的有效載荷；
- 它使用 `OP_RETURN` 交易輸出，將隱藏的付款代碼傳達給 Bob。

![BTC204](assets/fr/226.webp)

### 交易通知：實務研究

為了更詳細瞭解其運作方式，特別是 `OP_RETURN` 的使用，讓我們來看看一個真實的通知交易。我在 Testnet 上進行了這樣一個交易，您可以 [點選這裡](https://Mempool.space/fr/Testnet/tx/0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e)。

![BTC204](assets/fr/227.webp)

觀察這個交易，我們已經可以看到它有一個輸入和 4 個輸出：


- 第一個輸出為「OP_RETURN」，其中包含我的隱藏付款代碼；
- 第二個輸出 546 Sats 指向我的收件人通知 Address；
- 第三筆輸出 15,000 Sats 代表服務費，因為我使用 Samourai Wallet 來建立這筆交易；
- 第四個輸出的 200 萬 Sats 代表 Exchange 率，也就是我輸入的剩餘差額，它會回到屬於我的另一個 Address。

最值得研究的顯然是使用 `OP_RETURN` 的輸出 0。讓我們仔細看看它包含什麼。下面是以十六進位表示的 `scriptPubKey` ：

```text
6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000
```

這個腳本有幾個部分。首先，.NET Framework 2.0 的".NET "腳本：

```text
6a4c
```

在運算碼中，我們可以辨認指定 `OP_RETURN` 的 `0x6a` 和指定 `OP_PUSHDATA1` 的 `0x4c`。

最後一個操作碼之後的位元組表示後續有效負載的大小。它表示 `0x50`，或 80 位元組：

```text
6a4c50
```

接下來，我們有我的付款代碼的明碼元資料：

```text
010002
```

我的付款代碼公開金鑰的加密餘值 ：

```text
b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164
```

我的付款代碼的加密字串代碼 ：

```text
927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d8
```

最後，填充為 80 位元組，這是 `OP_RETURN` 的標準大小：

```text
00000000000000000000000000
```

為了幫助您瞭解，以下是我的付款代碼，以純文字形式，基於 58 ：

```text
PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
```

而在基數 16 ：

```text
4701000277507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42add94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc000000000000000000000000008604e4db
```

如果我們將我的明文支付代碼與 `OP_RETURN`進行比較，我們可以看到 HRP (`0x47`) 和校驗和 (`0x8604e4db`)沒有傳輸。這是正常的，因為這些資訊是為人類準備的。

接下來，我們可以辨識版本 (`0x01`)、位元欄位 (`0x00`)，以及公開金鑰的奇偶校驗 (`0x02`)。在付款代碼的最後，是空位元組 (`0x00000000000000000000000000`)，允許填充總共 80 位元組。所有這些元資料都是未加密傳輸的。

最後，我們可以觀察到公鑰的餘數 (`0x77507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42a`)和字串代碼 (`0xdd94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc`)已經加密。這是付款代碼的有效載荷。

### 什麼是 XOR？

我們在前面的章節中看到，付款代碼是使用 XOR 運算加密傳輸的。讓我們仔細看看這個運算符是如何運作的，因為它在加密學中被廣泛使用。

XOR 是基於布林代數的位元邏輯運算符號。給定兩個操作數的位，如果相同位元的位元不同，則返回 `1`；如果相同位元的位元相等，則返回 `0`。下面是根據操作數 `D` 和 `E` 的值而得到的 XOR 真值表：

| d | e | d xor e |

| --- | --- | ------- |

| 0 | 0 | 0 |

| 0 | 1 | 1 |

| 1 | 0 | 1 |

| 1 | 1 | 0 |

例如：

$$
0110 \oplus 1110 = 1000
$$

或 ：

$$
010011 \oplus 110110 = 100101
$$

在 ECDH 中，使用 XOR 作為加密 Layer 特別一致。首先，由於這個運算符號，加密是對稱的。這表示收款人可以使用加密時使用的相同金鑰來解密付款代碼。加密和解密金鑰是使用 ECDH 從共用秘密中計算出來的。這種對稱性是由於 XOR 運算子的換算和聯立屬性：


- 其他屬性 ：

$$
D \oplus D = 0
$$

$$
D \oplus 0 = D
$$


- 互換性 ：

$$
D \oplus E = E \oplus D
$$


- 關聯性 ：

$$
D \oplus (E \oplus Z) = (D \oplus E) \oplus Z = D \oplus E \oplus Z
$$

如果 ：

$$
D \oplus E = L
$$

然後：

$$
D \oplus L = D \oplus (D \oplus E) = D \oplus D \oplus E = 0 \oplus E = E \\
\therefore D \oplus L = E
$$

其次，這種加密方法與 Vernam (One-Time Pad) 密碼非常相似，而 Vernam 密碼是迄今所知唯一具有無條件 (或絕對) 安全性的加密算法。要使 Vernam 密碼具有此特性，加密金鑰必須是完全隨機、與訊息大小相同且只使用一次。在這裡使用的 BIP47 加密方法中，密碼匙的大小確實與訊息相同，而致盲因數的大小正好與公開密碼匙的餘數與付款代碼的字串代碼的串聯數相同。此加密金鑰只使用一次。另一方面，由於它是 HMAC，所以這個金鑰不是從完美的隨機性衍生出來的。相反，它是偽隨機的。因此，它不是 Vernam 密碼，但方法接近。

### 收到通知交易

現在 Alice 已經傳送通知交易給 Bob，讓我們看看 Bob 如何解讀它。提醒一下，Bob 必須可以取得 Alice 的付款密碼。沒有這個資訊，就像我們在下一節會看到的，他就無法推導出 Alice 所建立的金鑰對，因此也就無法存取他透過 BIP47 所收到的 bitcoins。目前，Alice 的付款代碼有效載荷是加密的。讓我們看看 Bob 如何解密。

**1-** Bob 用他的通知 Address 監控建立輸出的交易。

**2-** 當交易在其通知 Address 上有輸出時，Bob 會分析它是否包含符合 BIP47 標準的 OP_RETURN 輸出。

**3-** 如果 OP_RETURN 有效負載的第一個位元組是 `0x01`，Bob 就會開始搜尋可能與 ECDH 共享的秘密：


- Bob 選擇交易的輸入公開金鑰。也就是說，Alice 的公開金鑰名為 $A$，帶有 ：

$$ A = a \cdot G $$


- Bob 選擇與他的個人通知 Address 相關的私人金鑰 $b$ ：

$$ b $$


- Bob 透過加點和倍點計算橢圓曲線上的秘密點 $S$（共用秘密 ECDH），將他的私人密碼匙 $b$ 應用於 Alice 的公開密碼匙 $A$ ：

$$ S = b \cdot A $$


- 鮑勃確定可使愛麗絲的付款代碼的有效載荷被解密的致盲因數 $f$。鮑勃將以與愛麗絲之前計算相同的方式，將 HMAC-SHA512 應用於 $x$（密碼點 $S$ 的餘值）和 $o$（作為此通知交易的輸入而消耗的 UTXO），從而找出 $f$：

$$ f = \text{HMAC-SHA512}(o, x) $$

**4-** Bob 將通知交易中的 OP_RETURN 資料解讀為付款代碼。他只需使用 $f$ 致盲因子解密此潛在付款代碼的有效負載：


- Bob 將盲因子 $f$ 分成 2 部分：$f$ 的前 32 位元組為 $f1$，後 32 位元組為 $f2$ ；
- Bob 從 Alice 的付款代碼的公開金鑰中，解密出加密後的餘值 $x'$：

$$ x = x' \oplus f1 $$


- Bob 從 Alice 的付款代碼中解密加密字串代碼 $c'$ 的值：

$$ c = c' \oplus f2 $$

**5-** Bob 檢查 Alice 付款代碼的公開密碼值是否屬於 secp256k1 組。如果是，他會將此解釋為有效的付款代碼。如果不是，他會忽略該交易。

既然鮑勃知道愛麗絲的付款代碼，愛麗絲就可以寄給他多達 `2^32` 的付款，而無需重複此類通知交易。

為什麼會成功？鮑勃如何判斷出與愛麗絲相同的致盲因子，進而破譯她的付款密碼？讓我們仔細看看 ECDH 在剛才所描述的行動。

首先，我們處理的是對稱加密。這表示加密金鑰和解密金鑰是相同的值。通知交易中的這個金鑰就是致盲因素：

$$ f = f1 || f2 $$

因此，Alice 和 Bob 必須取得 $f$ 的相同值，但不能直接傳送，因為攻擊者可能會竊取並解密秘密資訊。這個致盲因子是透過對 2 個值應用 HMAC-SHA512 來獲得的：


- 密點的餘量 ；
- 和 UTXO 在交易輸入端消耗。

因此，Bob 需要這兩項資訊來解密 Alice 的付款代碼有效載荷。對於輸入的 UTXO，Bob 只需透過觀察通知交易即可擷取。至於秘密點，Bob 則需要使用 ECDH。如上一節 Diffie-Hellman 所述，只要交換各自的公開金鑰，並秘密地將私密金鑰套用在對方的公開金鑰上，Alice 和 Bob 就可以在橢圓曲線上找到精確的秘密點。通知交易就是基於這個機制：


- Bob 的一對鑰匙 ：

$$ B = b \cdot G $$


- Alice 的金鑰對 ：

$$ A = a \cdot G $$


- 對於一個秘密 $S (x, y)$ ：

$$ S = a \cdot B = a \cdot (b \cdot G) = (b \cdot a) \cdot G = b \cdot A $$

![BTC204](assets/fr/228.webp)

既然 Bob 知道 Alice 的付款代碼，他就能偵測到她的 BIP47 付款，也就能推算出封鎖所收到的 bitcoins 的私密金鑰。

我會總結我們剛才一起看過的步驟，來接收並解釋通知交易：


- Bob 監控交易輸出到他的通知 Address；
- 當偵測到一個時，它會擷取 OP_RETURN 所包含的資訊；
- Bob 選擇公開金鑰作為輸入，並使用 ECDH 計算秘密點；
- 它使用此密碼點來計算 HMAC，也就是致盲因子；
- 它使用這個致盲因子來解密 OP_RETURN 中所包含的 Alice 付款代碼有效負載。

![BTC204](assets/fr/229.webp)

### BIP47 付款交易

讓我們來看看 BIP47 的付款流程。提醒您目前的情況 ：


- Alice 知道 Bob 的付款代碼，她只需從 Bob 的網站擷取即可；
- Bob 從通知交易中知道 Alice 的付款代碼；
- Alice 將向 Bob 支付第一筆款項。她可以用同樣的方式支付更多。

在解釋這個過程之前，我認為有必要記住我們目前正在處理哪些索引。付款代碼的衍生路徑描述如下：`m/47'/0'/0'`.以下深度將索引劃分如下：


- 第一個正常（非強化）子對是用來 generate 上一節討論的通知 Address：`m/47'/0'/0'/0` ；
- 正常子金鑰對在 ECDH 中使用於 generate BIP47 付款收據位址，我們會在本節中看到：從 `m/47'/0'/0「/0` 到 `m/47」/0'/0'/2,147,483,647` ；
- 強化子金鑰對是短暫的付款代碼：從`m/47'/0'/0'/0「`到`m/47」/0'/0'/2,147,483,647'`。

每次 Alice 要傳送付款給 Bob 時，她會再次使用 ECDH 通訊協定，產生一個新的、唯一的空白 Address：


- Alice 選擇第一個私密金鑰，該金鑰來自她個人的可重複使用付款代碼 ：

$$ a $$


- Alice 從 Bob 的付款代碼中選擇第一個未使用的公開密鑰。我們稱之為 $B$。它與只有 Bob 知道的私人密碼匙 $b$ 相關聯：

$$ B = b \cdot G $$


- Alice 運用她的私人密碼匙 $a$ 和 Bob 的公開密碼匙 $B$ 在橢圓曲線上計算一個秘密點 $S$ ：

$$ S = a \cdot B $$


- Alice 從這個秘密點計算共享秘密 $s$（小寫）。為此，她選擇秘密點 $S$ 的餘值，命名為 $Sx$，並將此值傳給 SHA256 Hash 函數：

$$ S = (Sx, Sy) $$

$$ s = \text{SHA256}(Sx) $$


- Alice 使用此共用秘密 $s$ 來計算 Bitcoin 付款接收 Address。首先，她檢查 $s$ 是否包含在 secp256k1 曲線的順序中。如果不是這樣，她會遞增 Bob 的公開密碼匙索引，以得出另一個共用秘密 ；
- 在第二步中，她將橢圓曲線上的 $B$ 和 $s-G$ 兩個點相加，計算出一個公開密碼匙 $K0$。換句話說，Alice 將從 Bob 的付款代碼 $B$ 得到的公開密碼加在橢圓曲線上的另一個點上，這個點是用 secp256k1 曲線產生點 $G$ 的共享密碼 $s$ 加倍計算出來的。這個新點代表一個公開金鑰，我們稱之為 $K0$ ：

$$ K0 = B + s \cdot G $$


- 有了此公開金鑰 $K0$，Alice 就能以標準方式 (例如 bech32 中的 SegWit V0) 推導出空白接收 Address。

一旦Alice取得Bob的$K0$接收Address，她就可以以標準方式進行Bitcoin交易。要做到這一點，她選擇一個她擁有的 UTXO，由她的 HD Wallet 的不同分支的密鑰對做擔保，並消耗它來滿足對 Bob 的 $K0$ Address 的輸出。值得注意的是，一旦 Address 被導出，這個付款就會遵循經典的流程，而不再取決於與 BIP47 相關的金鑰。

我來總結一下我們剛才一起看過的發送 BIP47 付款的步驟：


- Alice 選擇由她個人付款代碼衍生的第一個子私密金鑰 ；
- 它使用 ECDH 從 Bob 的付款代碼衍生出的第一個未使用子公開金鑰計算出橢圓曲線上的秘密點；
- 它使用此密碼點以 SHA256 計算共享密碼；
- 她使用這個共用的秘密在橢圓曲線上計算出一個新的秘密點；
- 她將這個新的秘密點加入 Bob 的公開金鑰；
- 她會得到一個新的短暫公開金鑰，只有 Bob 才有相關的私密金鑰；
- Alice 可以使用衍生的短暫接收 Address 向 Bob 進行傳統交易。

![BTC204](assets/fr/230.webp)

如果 Alice 想要進行第二次付款，她會遵循之前相同的步驟，只是這次她會選擇從 Bob 的付款代碼衍生出來的第二個公開金鑰。具體來說，她會使用下一個未使用的金鑰。因此，她將獲得屬於 Bob 的新接收 Address，指定為 $K1$ ：

![BTC204](assets/fr/231.webp)

它可以繼續以這種方式推導出多達 `2^32` 個屬於 Bob 的空白位址。

從外部的角度來看 Blockchain，理論上是無法區分 BIP47 付款和傳統付款的。以下是 Testnet 上 BIP47 付款交易的範例：

```text
94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254
```

它看起來像一個典型的交易，有一個消耗輸入、一個付款輸出和一個 Exchange 比率：

![BTC204](assets/fr/232.webp)

### 收到 BIP47 付款並衍生私密金鑰

Alice 剛向屬於 Bob 的空白 BIP47 Address 支付了第一筆款項。現在讓我們看看鮑勃是如何收到這筆款項的。我們也會看到為什麼 Alice 無法取得她自己剛產生的 Address 的私密金鑰，以及 Bob 如何找到這個金鑰來花掉他剛收到的 bitcoins。

鮑勃從愛麗絲收到通知交易後，即使在他的對應人還未發送付款之前，他就已經得到公開金鑰 BIP47 $K0$。因此，他可以觀察到相關 Address 的任何付款。事實上，他立即推導出他所觀察到的數個地址 ($K0$, $K1$, $K2$, $K3$...) 。以下是它如何推導出這個公開金鑰 $K0$ ：


- Bob 選擇從他的付款代碼衍生出來的第一個子私人密碼匙。此私人密碼匙命名為 $b$。它與上一步中 Alice 用來進行計算的公開密碼匙 $B$ 相關聯：

$$ b $$


- Bob 從 Alice 的付款代碼中選擇 Alice 的第一個公開密碼匙。這個金鑰被命名為 $A$。它與 Alice 用來進行計算的私人密碼匙 $a$ 相關聯，而這個私人密碼匙只有 Alice 知道。Bob 可以執行這個過程，因為他知道 Alice 的付款代碼，這個代碼是與通知交易一起傳送給他的：

$$ A = a \cdot G $$


- 鮑勃將他的私人密碼匙 $b$ 應用於愛麗絲的公開密碼匙 $A$，藉由在橢圓曲線上的加倍點來計算秘密點 $S$。這裡再次使用 ECDH 來保證這個點 $S$ 對 Bob 和 Alice 來說都是一樣的：

$$ S = b \cdot A $$


- 鮑勃以與愛麗絲相同的方式，分離出這個點的餘值 $S$。我們將此值命名為 $Sx$。他將此值傳給 SHA256 函數，以找出共享秘密 $s$（小寫）：

$$ s = \text{SHA256}(Sx) $$


- Bob 以與 Alice 相同的方式，計算出橢圓曲線上的 $s-G$ 點。然後，他將這個秘密點加入他的公開密碼匙 $B$。然後，他會得到橢圓曲線上的一個新點，並將其解釋為一個公開密碼匙 $K0$ ：

$$ K0 = B + s \cdot G $$

一旦 Bob 擁有此公開金鑰 $K0$，他就可以衍生出相關的私人金鑰來使用他的 bitcoins。只有他可以 generate 這個私人密碼匙：


- Bob 將他女兒的私人密碼 $b$ 加起來，而這個私人密碼是由他的個人付款代碼所衍生出來的。只有他能獲得$b$的值。然後，他將$b$加到共享密碼$s$中，得到$k0$，即$K0$的私人密碼匙：

$$ k0 = b + s $$

由於橢圓曲線的群法則，Bob 可以取得與 Alice 所使用的公開金鑰相對應的私人金鑰。因此，我們有 ：

$$ K0 = k0 \cdot G $$

我會總結我們剛才一起看過的步驟，來接收 BIP47 付款並計算相對應的私密金鑰：


- Bob 選擇從其個人付款代碼衍生出來的第一個子私密金鑰 ；
- 它使用 ECDH 從 Alice 的字串代碼所衍生的第一個子公開金鑰，計算出橢圓曲線上的秘密點；
- 它使用此密碼點以 SHA256 計算共享密碼；
- 他使用這個共用的秘密在橢圓曲線上計算出一個新的秘密點；
- 他將這個新的秘密點加入他的個人公開金鑰；
- 他取得一個新的短暫公開金鑰，也就是 Alice 將要傳送第一筆款項的金鑰；
- 鮑勃計算與此短暫公開金鑰相關的私密金鑰，方法是加入由他的付款代碼和共用秘密所衍生的子私密金鑰。

![BTC204](assets/fr/233.webp)

由於 Alice 無法取得 $b$（Bob 的私人密碼鑰），因此無法確定 $k0$（與 Bob 的 BIP47 接收 Address 相關的私人密碼鑰）。在結構上，我們可以將共用秘密 $S$ 的計算表示如下：

![BTC204](assets/fr/228.webp)

一旦使用 ECDH 找到共用秘密，Alice 和 Bob 會計算 BIP47 支付公開金鑰 $K0$，Bob 也會計算相關的私人金鑰 $k0$：

![BTC204](assets/fr/234.webp)

### 退還 BIP47 付款

由於 Bob 知道 Alice 可重複使用的付款代碼，因此他已經有了向她寄送退款所需的所有資訊。他不需要再聯絡 Alice 索取任何資訊。他只需要用通知交易通知她，讓她可以用 seed 擷取她的 BIP47 位址，然後他也可以寄給她最多 `2^32` 的付款。

退款功能是 BIP47 所特有的，也是它相較於其他方法的優勢之一，例如我們將在後面的章節中介紹的 Silent Payments。

然後，Bob 可以用 Alice 寄給他付款的相同方式償還 Alice。角色反轉：

![BTC204](assets/fr/235.webp)

*非常感謝 [Fanis Michalakis](https://x.com/FanisMichalakis)，感謝他對文章的校對和專家意見，啟發了本章的撰寫！

https://planb.network/tutorials/privacy/on-chain/paynym-bip47-a492a70b-50eb-4f95-a766-bae2c5535093
## 無聲付款

<chapterId>2871d594-414e-4598-a830-91c9eb84dfb8</chapterId>

BIP47 因其鏈上效率低而廣受批評。如前一章所述，它需要為每個新的收款人進行通知交易。如果我們打算與收款人建立一個可持續的付款管道，這個限制就變得微不足道。事實上，單一的通知交易就可以為後續幾乎無限次的 BIP47 付款鋪路。

然而，在某些情況下，通知交易可能會成為使用者的障礙。讓我們以一次性捐款給受助人為例：使用經典的 Bitcoin Address，一次交易就足以完成捐款。但使用 BIP47，則需要兩筆交易：一筆用於通知，另一筆用於實際付款。當區塊空間需求低、交易費用低時，這個額外的步驟通常不是問題。但是，在擁擠時期，單次付款的交易費用可能會變得非常高昂，與標準的 Bitcoin 交易相比，用戶的成本可能會增加一倍，這對用戶來說可能是無法接受的。

對於使用者只計劃向靜態識別碼支付數筆款項的情況，已開發出其他解決方案。這些解決方案包括 [BIP352](https://github.com/Bitcoin/bips/blob/master/bip-0352.mediawiki) 中描述的 Silent Payments。此協定讓使用靜態識別碼接收付款成為可能，而不會產生 Address 重複使用，也不需要使用通知交易。讓我們來看看這個通訊協定是如何運作的。

---
*要完全理解本章內容，必須先掌握 ECDH（橢圓曲線 Diffie-Hellman）的工作原理，以及 HD Wallet 的加密金鑰推演。這些概念已在前面有關 BIP47 的章節中詳細說明。在此不再重複。如果您還不熟悉這些概念，我建議您先參考前一章，再繼續這一章。我不會再重複與重複使用收款位址相關的風險，也不會再重複為收款設定唯一識別碼的重要性。

---
### 為何不移動通知？

如 BIP47 章節所述，通知交易有兩個主要功能：


- 它會通知收件人 ；
- 它會傳送寄件者的付款代碼。

人們可能會天真的以為這個通知程序可以用 off-chain 來進行。理論上，這是完全可行的：收件人所要做的就是指出一種通訊方式，以接收寄件者的 BIP47 付款代碼。然而，這個方法有兩個主要問題：


- 首先，它會將代碼傳輸程序轉移到另一個通訊協定。與 Exchange 的成本和機密性相關的問題仍會存在，但只是轉移到這個新的通訊協定。就機密性而言，這也可能會在使用者的身份和上鏈活動之間建立連結，而這正是我們直接在 Blockchain 上執行通知所要避免的。此外，在 Blockchain 外部執行通知會引入 Bitcoin 上不存在的審查風險（例如封鎖資金）；
- 其次，這會造成回收問題。使用 BIP47 時，收款人必須知道發款人的付款代碼才能存取資金。收款時是如此，但如果 Wallet 遺失，透過 seed 追回資金時也是如此。有了 onchain 通知，這個風險就可以避免，因為使用者只要知道他的 seed，就可以擷取和解密通知交易。但是，如果通知是在 Blockchain 外部進行，使用者就必須維持所有收到的付款代碼的動態備份，這對一般使用者來說並不可行。

所有這些限制使得使用鏈上通知對 BIP47 來說是必不可少的。然而，Silent Payments 卻恰恰因為其成本而試圖避免這個鏈上通知步驟。因此，所採用的解決方案不是移動通知，而是完全消除通知。為了實現這一目標，必須接受折衷方案：掃描。與 BIP47 不同的是，在 BIP47 中，由於有了通知交易，用戶可以準確地知道在哪裡可以找到他的資金，而在 Silent Payments 中，用戶必須檢查所有現有的 Bitcoin 交易，才能發現任何為他準備的付款。為了減輕操作負擔，Silent Payments 的搜尋僅限於可能包含此類付款的交易，即至少有一個 Taproot P2TR 輸出的交易。掃描也只針對 Wallet 建立日期起的交易 (如果 Wallet 是在 2024 年建立，就不需要掃描 2009 年的交易)。

因此，您可以理解為什麼 BIP47 和無聲支付雖然目標相似，卻涉及不同的取捨，因此 ** 實際上符合不同的使用情況**。對於一次性付款，例如一次性捐款，無聲付款因其較低的成本而更為合適。另一方面，對於定期向同一收款人進行的交易，如 Exchange 平台或 Mining 池，BIP47 可能是首選。

讓我們來看看 Silent Payments 的技術操作，以便更好地瞭解其中的利害關係。為此，我建議我們採用與 BIP352 說明文件相同的方法。我們將逐個元素逐步分解要進行的計算，證明每個新增加的元素的合理性。

### 需要瞭解的幾個概念

在開始之前，有必要指出 Silent Payments 完全依賴使用 P2TR (*Pay to Taproot*)腳本類型。與 BIP47 不同的是，不需要從子公開金鑰透過散列推導出接收位址。在 P2TR 標準中，經調整過的公開金鑰會直接使用在 Address 中，而且未經加密。因此，Taproot 接收 Address 本質上是一個帶有一些元資料的公開金鑰。此經調整的公開金鑰是另外兩個公開金鑰的集合：一個透過簡單簽章可直接使用傳統的花費，另一個則代表 MAST 的 Merkle Root，它授權花費必須滿足 Merkle Tree 中可能記載的條件之一。

![BTC204](assets/fr/068.webp)

決定將 Silent Payments 侷限於 Taproot 有兩個主要原因：


- 首先，它大大方便了組合軟體的實施和未來升級，因為只需要遵守一個標準；
- 其次，這種方法有助於改善使用者的自發性，鼓勵他們不要將自己分為不同類型的腳本，在連鎖分析中，generate 不同的組合指紋（有關此概念的詳細資訊，請參閱第 2 部分的第 4 章）。

### 沉默支付公開金鑰的簡單推導

讓我們從一個簡單的例子開始，了解 SP（無聲付費）如何運作。以 Alice 和 Bob 這兩位 Bitcoin 使用者為例。Alice 希望在空白接收 Address 上發送比特幣給 Bob。這個過程有三個目標：


- Alice 必須能夠 generate 空白的 Address；
- Bob 必須能夠識別寄給此特定 Address 的付款；
- Bob 需要能夠取得與此 Address 相關的私人金鑰，才能使用他的資金。

Alice 在她的安全 Bitcoin Wallet 中有一個 UTXO，其金鑰對如下：


- $a$: 私密金鑰 ；
- $A$: 公開金鑰 ($A = a\cdot G$)

Bob 有一個 SP Address，他已經在網際網路上用 .NET 發佈了：


- $b$: 私密金鑰 ；
- $B$: 公開金鑰 ($B = b \cdot G$)

透過擷取 Bob 的 Address，Alice 可以使用 ECDH 計算出一個屬於 Bob 的新空白 Address。我們稱這個 Address 為 $P$ ：

$$ P = B + \text{Hash}(a \cdot B) \cdot G $$

在這個方程式中，Alice 只需計算她的私人密碼匙 $a$ 和 Bob 的公開密碼匙 $B$ 的縮放乘積。她將這個結果傳入一個每個人都知道的 Hash 函數。所得的數值再乘以橢圓曲線 `secp256k1` 的生成點 $G$。最後，Alice 將產生的點加到 Bob 的公開密碼匙 $B$。一旦 Alice 得到這個 Address $P$，她就會在交易中使用它作為輸出，也就是說，她會向它發送比特幣。

> *在 Silent Payments 的情況下，「Hash」函式對應於特別標記為 `BIP0352/SharedSecret` 的 SHA256 Hash 函式，可確保產生的雜湊值對此通訊協定而言是唯一的，且無法在其他情況下重複使用，同時提供額外的保護，以防止在簽章中重複使用 nonces。此標準對應 [BIP340 中指定的 Schnorr 簽署](https://github.com/Bitcoin/bips/blob/master/bip-0340.mediawiki) `secp256k1`.* 上的標準。
由於 ECDH 所基礎的橢圓曲線的特性，我們知道 ：

$$ a \cdot B = b \cdot A $$

因此，Bob 將能夠計算出 Alice 將 bitcoins 寄給的收款 Address。要做到這一點，他會監控所有符合無聲支付條件的 Bitcoin 交易，並對每筆交易進行以下計算，以查看付款是否寄給他（*掃描*）：

$$ P' = B + \text{Hash}(b \cdot A) \cdot G $$

當他掃描 Alice 的交易時，他意識到 $P'$ 等於 $P$。因此，他知道這筆款項是寄給她的：

$$ P' = B + \text{Hash}(b \cdot A) \cdot G = B + \text{Hash}(a \cdot B) \cdot G = P $$

從這裡，Bob 將能夠計算出私密金鑰 $p$，讓 Address $P$ 得以使用：

$$ p = (b + text{Hash}(b \cdot A))\bmod n $$

如您所見，要計算私人密碼匙 $p$，您必須擁有私人密碼匙 $b$。只有 Bob 有這個私人密碼匙 $b$。因此，只有他能夠花費發送給他的無聲支付 Address 的比特幣。

![BTC204](assets/fr/236.webp)

*圖例：*


- $B$ : Bob 發佈的公開金鑰/靜態 Address
- $b$ : Bob 的私人密碼匙
- $A$ : Alice 的 UTXO 公開金鑰作為交易輸入
- $a$ : Alice 的私人密碼匙
- $G$ : 橢圓曲線 `secp256k1` 的產生點
- $\text{SHA256}$ : 標記為 `BIP0352/SharedSecret` 的 SHA256 Hash 函式
- $s$ : ECDH 共通秘密
- $P$ : 支付給 Bob 的公開金鑰/唯一 Address

這裡有一個相當幼稚的初始方法，使用 Bob 的靜態 Address，記下 $B$，推導出一個唯一的 Address $P$ 來發送比特幣。但是，這個方法太簡單了，而且有幾個缺陷需要糾正。第一個問題是，在此方案中，Alice 無法在同一筆交易中建立多個輸出至 Bob。

### 如何建立多重輸出？

在上一節的範例中，Alice 建立一個單一輸出，將傳送到 Bob 唯一的 Address $P$。在選擇相同輸入的情況下，Alice 不可能為 Bob 建立兩個獨立的空白位址，因為所使用的方法永遠會為 $P$ 帶來相同的結果，也就是相同的 Address。然而，在許多情況下，Alice 可能希望將支付給 Bob 的款項分成數筆較小的金額，因此會產生數個 UTXO。因此，有必要找到一種方法來實現這一目標。

為了達到這個目的，我們要稍微修改Alice為求出$P$所執行的計算，讓她可以為Bob generate兩個不同的位址，即$P_0$和$P_1$。

若要修改計算並獲得 2 個不同的位址，只需加入一個整數來修改結果即可。因此，Alice 會在她的計算中加入 $0$，以獲得 Address $P_0$，並加入 $1$，以獲得 Address $P_1$。我們稱這個整數為 $i$ ：

$$ P_i = B + text{Hash}(a \cdot B \text{ ‖ } i) \cdot G $$

計算過程與之前的方法相同，只是這次 Alice 會在進行 Hash 之前將 $a \cdot B$ 與 $i$ 連接。然後，您只需修改 $i$ 即可獲得屬於 Bob 的新 Address。例如：

$$ P_0 = B + text{Hash}(a \cdot B \text{ ‖ } 0) \cdot G $$

$$ P_1 = B + text{Hash}(a \cdot B \text{ ‖ } 1) \cdot G $$

當 Bob 掃描 Blockchain 是否有預定給他的無聲付款時，他首先使用 $i = 0$ 掃描 Address $P_0$。如果他沒有在 $P_0$ 上找到任何付款，他的結論是這筆交易沒有為他準備的無聲付款，並放棄掃描。但是，如果 $P_0$ 是有效的，並且包含了他的付款，他繼續在同一筆交易中的 $P_1$ 檢查 Alice 是否已經做了第二筆付款。如果 $P_1$ 結果是無效的，它會停止搜尋這筆交易；否則，它會繼續測試連續的 $i$ 值：

$$ P_0 = B + text{Hash}(b \cdot A \text{ ‖ } 0) \cdot G $$

$$ P_1 = B + text{Hash}(b \cdot A \text{ ‖ } 1) \cdot G $$

由於如果 $P_0$ 不起作用，Bob 會立即在 $i = 0$ 停止，因此使用這個整數幾乎不會增加 Bob 在交易掃描階段的額外作業負載。

Bob 就可以用同樣的方法計算出私人密碼匙：

$$
p_0 = (b + \text{hash}(b \cdot A \text{ ‖ } 0)) \bmod n
$$

$$
p_1 = (b + \text{hash}(b \cdot A \text{ ‖ } 1)) \bmod n
$$

![BTC204](assets/fr/237.webp)

*圖例：*


- $B$ : Bob 發佈的公開金鑰/靜態 Address
- $b$ : Bob 的私人密碼匙
- $A$ : Alice 的 UTXO 公開金鑰作為交易輸入
- $a$ : Alice 的私人密碼匙
- $G$ : 橢圓曲線 `secp256k1` 的產生點
- $\text{SHA256}$ : 標記為 `BIP0352/SharedSecret` 的 SHA256 Hash 函式
- $s_0$ : 第一個共同秘密 ECDH
- $s_1$ : 第二個 ECDH 共同秘密
- $P_0$ : 支付給 Bob 的第一個公開金鑰 / 唯一的 Address
- $P_1$ : 支付給 Bob 的第二個公開金鑰 / 唯一的 Address

有了這個方法，我們開始得到一個不錯的通訊協定，但仍有一些挑戰需要克服，尤其是防止 Address 重複使用。

### 如何避免 Address 重複使用？

正如我們在前幾節所看到的，Alice 使用保護她的 UTXO 的金鑰對，她將花費這個金鑰對來計算與 Bob 的 ECDH 共享秘密。這個秘密可以讓她推導出唯一的 Address $P_0$。然而，如果Alice多次重複使用這個Address，她所使用的金鑰對($a$, $A$)可以保護數個UTXO。如果Alice使用同一個金鑰$A$所保護的兩個UTXO向Bob的靜態Address $B$支付兩筆款項，這將導致Bob重複使用Address。

> *就使用者機密性而言，Address 重複使用是非常不好的做法。若要瞭解原因，我建議您複習本訓練課程的第一部分*。
事實上，由於唯一的Address $P_0$是由$A$和$B$所衍生出來的，如果Alice用相同的鑰匙$A$衍生出第二個Address來支付第二筆款項給$B$的話，她最後會使用完全相同的Address $P_0$。為了避免這個風險，並防止 Address 在 Silent Payments 中重複使用，我們需要稍微修改我們的計算。

我們想要的是，Alice 用來作為付款輸入的每個 UTXO 都能在 Bob 這邊產生一個唯一的 Address，即使有幾個 UTXO 是由相同的金鑰對所保護。因此，我們只需要在計算唯一的 Address $P_0$ 時，加入 UTXO 的參照。這個參照將只是作為輸入消耗的 UTXO 的 Hash：

$$ \text{inputHash} = \text{Hash}(\text{outpoint} \text{ ‖ } A) $$

而 Alice 在計算唯一的 Address $P_0$ 時，會將這個參照加入到輸入中：

$$ P_0 = B + \text{Hash}(\text{inputHash} \cdot a \cdot B \text{ ‖ } 0) \cdot G $$

當掃描時，Bob 也可以加入 $\text{inputHash}$，因為他所要做的就是觀察交易來推斷 $\text{outpoint}$：

$$ P_0 = B + \text{Hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0) \cdot G $$

當它找到一個有效的 $P_0$，它就可以計算出相對應的 $p_0$ 私密金鑰：

$$
p_0 = (b + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0)) \bmod n
$$

![BTC204](assets/fr/238.webp)

*圖例：*


- $B$ : Bob 發佈的公開金鑰/靜態 Address
- $b$ : Bob 的私人密碼匙
- $A$ : Alice 的 UTXO 公開金鑰用於交易輸入
- $a$ : Alice 的私人密碼匙
- $H$ : UTXO Hash 用作輸入
- $G$ : 橢圓曲線 `secp256k1` 的產生點
- $\text{SHA256}$ : 標記為 `BIP0352/SharedSecret` 的 SHA256 Hash 函式
- $s_0$ : 第一個 ECDH 共通秘密
- $P_0$ : 支付給 Bob 的第一個公開金鑰 / 唯一的 Address

目前，我們的計算假設 Alice 在交易中使用單一輸入。但是，她應該可以使用多個輸入。因此，在 Bob 方面，對於涉及多個輸入的每筆交易，理論上他應該計算每個輸入的 ECDH，以判斷是否有款項要付給他。這個方法並不令人滿意，因此我們需要找到一個解決方案來減少工作量！

### 將公開金鑰調整為輸入

為了解決這個問題，我們不使用確保 Alice 一方特定輸入的金鑰對，而是使用交易輸入中使用的所有金鑰對的總和。這個總和就會被視為新的金鑰對。這種技術稱為「調整」。

例如，讓我們想像 Alice 的交易有 3 個輸入，每個都使用不同的金鑰對來保護：


- $a_0$ 用來保護輸入 #0 ；
- $a_1$ 用來保護輸入 #1；
- $a_2$ 確保輸入 #2。

![BTC204](assets/fr/239.webp)

按照之前描述的方法，Alice 將必須從 $a_0$、$a_1$ 和 $a_2$ 中選擇單一密鑰對來計算 ECDH 秘 密，並從 Bob 的靜態 Address $B$ 中 generate 單一支付 Address $P$。然而，此方法需要 Bob 依序測試每種可能性，從 $a_0$開始，然後是 $a_1$，如此類推，直到他找出可產生有效 $P$ Address 的一對。這個過程需要 Bob 對所有交易的所有輸入執行 ECDH 計算，這大大增加了掃描的作業負荷。

為了避免這種情況，我們會要求 Alice 使用所有輸入金鑰的總和來計算 $P$。使用我們的範例，經調整的私人密碼匙 $a$ 的計算方式如下：

$$ a = a_0 + a_1 + a_2 $$

以同樣的方式，Alice 和 Bob 可以計算出調整後的公開金鑰：

$$ a = a_0 + a_1 + a_2 $$

使用此方法，Bob 只需計算交易的公開金鑰總和，然後單從 $A$ 計算 ECDH 密碼，這可大幅減少掃描階段所需的計算次數。

但是，請記住上一節。我們曾在計算中加入 $\text{inputHash}$ Hash，作為 Nonce 使用，以避免 Address 重複使用：

$$ \text{inputHash} = \text{Hash}(\text{outpoint} \text{ ‖ } A) $$

但是如果您在一個交易中有多個輸入，您需要能夠決定在這個計算中選擇哪一個 $\text{outpoint}$。根據 BIP352，要使用的 $\text{outpoint}$ 選擇標準是按詞彙順序選擇最小的，也就是選擇按字母順序最先出現的 UTXO。此方法將每筆交易中選擇的 UTXO 標準化。例如，如果這個詞彙最小的 $\text{outpoint}$ 是 $\text{outpoint}_L$，$\text{inputHash}$ 的計算將是 ：

$$ \text{inputHash} = \text{Hash}(\text{outpoint}_L \text{ ‖ } A) $$

接下來的計算仍與上一節所提出的相同，只是私人密碼匙 $a$ 及其對應的公開密碼匙 $A$ 不再是用來保護單一輸入的一對，而是現在代表輸入中所有密碼匙對的調整。

### 獨立的支出和掃描鍵

目前，我們將無聲支付靜態 Address $B$ 稱為唯一公開密鑰。請記住，Alice 正是使用此公開金鑰 $B$ 來建立共用秘密 ECDH，進而計算出獨一無二的付款 Address $P$。Bob 在掃描階段會使用這個公開金鑰 $B$ 和相對應的私人金鑰 $b$。但他也會使用私人密碼匙$b$來計算私人密碼匙$p$，以便從Address $P$進行消費。

此方法的缺點是 $b$ 私密金鑰會被 Bob 用來計算所有收到無聲付款的地址的私密金鑰，也會被 Bob 用來掃描交易。此步驟需要 $b$ 金鑰可在連線至網際網路的 Wallet 軟體上使用，這比將其保存在 Cold Wallet 上更容易遭受竊取的風險。理想的情況是，能夠利用無聲支付的優勢，同時將控制所有其他私密金鑰存取的 $b$ 私密金鑰安全地保存在 Hardware Wallet 上。幸運的是，協定已經能夠做到這一點。

為此，BIP352 要求接收器使用 2 組不同的鑰匙：


- b_{text{spend}}$：計算唯一付款地址的私密金鑰；
- b_{text{scan}}$: 尋找唯一的付款位址。

這樣，Bob 就可以將私人密碼匙 $b_{\text{spend}}$ 保存在 Hardware Wallet 中，並在線上軟體中使用私人密碼匙 $b_{\text{scan}}$ 來尋找他的 Silent Payments，而不會洩露 $b_{\text{spend}}$。另一方面，公鑰 $B_{\text{scan}}$ 和 $B_{\text{spend}}$ 都是公開的，因為它們位於 Bob 的靜態 Address $B$ 中：

$$ B = B_{\text{scan}}\text{ ‖ }B_{text{spend}}$$

為了計算屬於 Bob 的唯一付款 Address $P_0$，Alice 現在將執行以下計算：

$$ P_0 = B_{text{spend}}+ \text{Hash}(\text{inputHash} \cdot a \cdot B_{text{scan}} \text{ ‖ } 0) \cdot G $$

為了找出寄給他的付款，Bob 將執行以下計算：

$$ P_0 = B_{text{spend}}+ \text{Hash}(\text{inputHash} \cdot b_{text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$

如您所見，到目前為止 Bob 還不需要使用 $b_{\text{spend}}$，它在他的 Hardware Wallet 上。當他要花 $P_0$ 時，他可以做以下的計算來找出私人密碼匙 $p_0$ ：

$$ p_0 = (b_{text\{spend}}+ \text{Hash}(\text{inputHash} \cdot b_{text{scan}} \cdot A \text{ ‖ } 0)) \bmod n $$

![BTC204](assets/fr/240.webp)

*圖例：*


- $B_{text{scan}}$: Bob 的公開掃描金鑰 (靜態 Address)
- $b_{text{scan}}$ : Bob 的私人掃描金鑰
- $B_{text{spend}}$ : Bob 的公開支出金鑰 (靜態 Address)
- $b_{text{spend}}$ : Bob 的私人支出金鑰
- $A$ : 公鑰輸入總和 (調整)
- $a$ : 私密金鑰對應經調整的公開金鑰
- $H$ : 作為輸入的最小 UTXO 的 Hash (詞彙)
- $G$ : 橢圓曲線 `secp256k1` 的產生點
- $\text{SHA256}$ : 標記為 `BIP0352/SharedSecret` 的 SHA256 Hash 函式
- $s_0$ : 第一個共同秘密 ECDH
- $P_0$ : 支付給 Bob 的第一個公開金鑰 / 唯一的 Address

### 使用標籤的 SP 位址

因此，鮑勃有一個靜態的 Address $B$，用於無聲支付，如 ：

$$ B = B_{\text{scan}}\text{ ‖ }B_{text{spend}}$$

此方法的問題在於無法區分傳送至 Address 的不同付款。舉例來說，如果 Bob 的生意有 2 個不同的客戶，而他想要區分對每個客戶的付款，他就需要 2 個不同的靜態位址。根據目前的方法，一個天真的解決方案是 Bob 建立兩個獨立的錢包，每個錢包都有自己的靜態 Address，或甚至在同一個 Wallet 中建立兩個不同的靜態位址。然而，此解決方案需要掃描整個 Blockchain 兩次 (每個 Address 一次)，才能偵測到分別寄給每個 Address 的付款。這種雙重掃描不合理地增加了 Bob 的作業負載。

為了解決這個問題，BIP352 使用標籤系統，允許不同的靜態地址，而不會不合理地增加在 Blockchain 上尋找 Silent Payments 的工作量。為此，我們在公共支出金鑰 $B_{\text{spend}}$ 中加入一個整數 $m$。對於第一個靜態 Address，這個整數的值可以是 $1$，然後對於第二個靜態 Address，這個整數的值可以是 $2$，以此類推。支出鑰匙 $B_{\text{spend}}$ 現在將稱為 $B_m$，並將以這種方式構建：

$$ B_m = B_{text{spend}}+ text{Hash}(b_{text{scan}} \text{ ‖ } m) \cdot G $$

例如，對於第一個標籤為 $1$ 的支出鍵 ：

$$ B_1 = B_{text{spend}}+ text{Hash}(b_{text{scan}} \text{ ‖ } 1) \cdot G $$

Bob 發佈的靜態 Address 現在將由 $B_{text{scan}$ 和 $B_m$ 組成。例如，第一個標籤為 $1$ 的靜態 Address 將為 ：

$$ B = B_{\text{scan}}\text{ ‖ }B_1 $$

> *我們只從標籤 1 開始，因為標籤 0 是預留給變更的。
Alice 則會以與之前相同的方式推導出單筆付款 Address $P$，但使用新的 $B_1$ 而非 $B_{text{spend}}$ ：

$$ P_0 = B_1 + \text{Hash}(\text{inputHash} \cdot a \cdot B_{\text{scan}} \text{ ‖ } 0) \cdot G $$

實際上，Alice 甚至不一定知道 Bob 有標籤的 Address，因為她只是使用他提供的靜態 Address 的第二部分，在此情況下，是值 $B_1$ 而不是 $B_{text{spend}}$。

為了掃描付款，Bob 將始終以這種方式使用其初始靜態 Address 的值與 $B_{text{spend}}$：

$$ P_0 = B_{text{spend}}+ \text{Hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$

然後，他只需從每個輸出中逐一減去他找到的 $P_0$ 值。然後，他檢查這些減法的結果之一是否與他在組合中使用的標籤之一的值相符。例如，如果輸出 #4 與 $1$ 標籤相匹配，這意味著此輸出是與其靜態標記 Address $B_1$ 相關的默許支付：

$$ Out_4 - P_0 = \text{Hash}(b_{text{scan}} \text{ ‖ } 1) \cdot G $$

它之所以有效，是因為 ：

$$ B_1 = B_{text{spend}}+ text{Hash}(b_{text{scan}} \text{ ‖ } 1) \cdot G $$

有了這個方法，Bob 可以使用許多靜態位址 ($B_1$、$B_2$、$B_3$...)，這些位址都來自於他的基本靜態 Address ($B = B_{\text{scan}} \text{ ‖ } B_{\text{spend}}$)，以便分開使用。

但請注意，這種分隔靜態位址的做法僅在個人組合管理的觀點上有效，並不能分隔身份。由於它們都具有相同的 $B_{text/{scan}}$，因此很容易將所有靜態位址聯繫在一起，並推斷出它們屬於同一個實體。

![BTC204](assets/fr/241.webp)

*圖例：*


- $B_{text{scan}}$: Bob 的公開掃描金鑰 (靜態 Address)
- $b_{text{scan}}$ : Bob 的私人掃描金鑰
- $B_{text{spend}}$ : Bob 的公開支出金鑰 (初始 Address)
- $B_m$ : Bob 的公開支出金鑰標籤 (靜態 Address)
- $b_m$: Bob 的私人支出金鑰，標示為
- $A$ : 公鑰輸入總和 (調整)
- $a$ : 私密金鑰對應經調整的公開金鑰
- $H$ : 作為輸入的最小 UTXO 的 Hash (詞彙)
- $G$ : 橢圓曲線 `secp256k1` 的產生點
- $\text{SHA256}$ : 標記為 `BIP0352/SharedSecret` 的 SHA256 Hash 函式
- $s_0$ : 第一個 ECDH 共通秘密
- $P_0$ : 支付給 Bob 的第一個公開金鑰 / 唯一的 Address
- $p_0$ : 給 Bob 的第一筆唯一付款 Address 的私人金鑰
- $X$ : 掃描私人密碼匙的 Hash 標籤

### 如何建立 Silent Payments Address？

若要建立專用於無聲支付的 Address，您首先需要從 Bitcoin HD Wallet 中衍生出 2 個金鑰對：


- 對 $b_{\text{scan}}$、$B_{\text{scan}}$ 來搜尋給我們的付款；
- 對 $b_{\text{spend}}$，$B_{\text{spend}}$ 來想我們收到的比特幣。

這些配對使用下列路徑 (*Bitcoin Mainnet*)：

```text
scan : m / 352' / 0' / 0' / 1' / 0
spend : m / 352' / 0' / 0' / 0' / 0
```

有了這兩對金鑰之後，我們只要將它們（端對端）串連起來，就可以建立靜態的 Address 有效負載：

$$ B = B_{\text{scan}}\text{ ‖ }B_{text{spend}}$$

如果我們要使用標籤，我們將用 $B_m$ 取代 $B_{text{spend}}$ ：

$$ B = B_{\text{scan}}\text{ ‖ }B_m $$

標籤為 $m$ ：

$$ B_m = B_{text{spend}}+ text{Hash}(b_{text{scan}} \text{ ‖ } m) \cdot G $$

一旦有了這個有效載荷，我們就會加入 HRP (*Human-Readable Part*) `sp` 和版本 `q` (= 版本 0)。我們也會加入校驗和，並將 Address 格式化為 bech32m。

例如，這是我的 Silent Payments 靜態 Address：

```text
sp1qqvhjvsq2vz8zwrw372vuzle7472zup2ql3pz64yn5cpkw5ngv2n6jq4nl8cgm6zmu48yk3eq33ryc7aam6jrvrg0d0uuyzecfhx2wgsumcurv77e
```

關於靜態地址的一個重要觀點，您可能已經在前面的章節中掌握了，那就是這些地址在 Bitcoin 交易中是看不到的。只有在輸出中使用的 $P$ 付款地址會以標準的 Taproot 格式出現在 Blockchain 上。因此，從外面看，無法區分涉及無聲支付的交易和使用 P2TR 輸出的普通交易。

與 BIP47 一樣，靜態 Address $B$ 與從 $B$ 衍生出的付款 Address $P$ 之間不可能建立連線。事實上，即使潛在的攻擊者 Eve 嘗試用 Bob 的靜態 $B$ Address 掃描 Blockchain，她也無法執行確定 $P$ 所需的計算。要做到這一點，她需要 Bob 的私人密碼匙 $b_{\text{scan}}$，或者發件人的私人密碼匙 $a$，但兩者當然都是私有的。因此，可以明確地將一個人的靜態 Address 與某種形式的個人身份聯繫起來。

### 如何使用 Silent Payments？

Silent Payments 方案是最近才提出的，目前只有極少數的錢包實施。據我所知，目前只有 3 款軟體產品支援：


- [CakeWallet](https://cakewallet.com/)
- [Silentium](https://app.silentium.dev/)
- [DonationWallet](https://github.com/Sosthene00/donationwallet)

我們即將為您提供如何設定您自己的 Silent Payments 靜態 Address 的詳細教學。

由於此功能是新功能，我們建議您謹慎行事，避免在 Mainnet 上使用大筆金額的靜音付款。

*為了撰寫這章關於無聲付款的內容，我使用了 [無聲付款說明網站](https://silentpayments.xyz/) 和 [BIP352 說明文件](https://github.com/Bitcoin/bips/blob/master/bip-0352.mediawiki)。*

# 總結

<partId>2aee56c0-b285-4799-b4f7-373a552ee2b2</partId>

## 評論與評分

<chapterId>195d149f-80fa-5816-8b46-995a9226d082</chapterId>

<isCourseReview>true</isCourseReview>
## 期末考試

<chapterId>e803d394-e3c1-5816-a6b4-a69a2472019c</chapterId>

<isCourseExam>true</isCourseExam>
## 總結

<chapterId>cd8e5c67-50e4-4dcd-8e04-88ba5ec95305</chapterId>

<isCourseConclusion>true</isCourseConclusion>